(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_c07253._.js", {

"[project]/Documents/instant-demo/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE$2 ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_CONTEXT_TYPE:
                return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function disabledLog() {}
    function disableLogs() {
        if (0 === disabledDepth) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
                configurable: !0,
                enumerable: !0,
                value: disabledLog,
                writable: !0
            };
            Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
            });
        }
        disabledDepth++;
    }
    function reenableLogs() {
        disabledDepth--;
        if (0 === disabledDepth) {
            var props = {
                configurable: !0,
                enumerable: !0,
                writable: !0
            };
            Object.defineProperties(console, {
                log: assign({}, props, {
                    value: prevLog
                }),
                info: assign({}, props, {
                    value: prevInfo
                }),
                warn: assign({}, props, {
                    value: prevWarn
                }),
                error: assign({}, props, {
                    value: prevError
                }),
                group: assign({}, props, {
                    value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                    value: prevGroupEnd
                })
            });
        }
        0 > disabledDepth && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix) try {
            throw Error();
        } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
            suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
        return "\n" + prefix + name + suffix;
    }
    function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) return "";
        var frame = componentFrameCache.get(fn);
        if (void 0 !== frame) return frame;
        reentry = !0;
        frame = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher = null;
        previousDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = null;
        disableLogs();
        try {
            var RunInRootFrame = {
                DetermineComponentFrameRoot: function() {
                    try {
                        if (construct) {
                            var Fake = function() {
                                throw Error();
                            };
                            Object.defineProperty(Fake.prototype, "props", {
                                set: function() {
                                    throw Error();
                                }
                            });
                            if ("object" === typeof Reflect && Reflect.construct) {
                                try {
                                    Reflect.construct(Fake, []);
                                } catch (x) {
                                    var control = x;
                                }
                                Reflect.construct(fn, [], Fake);
                            } else {
                                try {
                                    Fake.call();
                                } catch (x$0) {
                                    control = x$0;
                                }
                                fn.call(Fake.prototype);
                            }
                        } else {
                            try {
                                throw Error();
                            } catch (x$1) {
                                control = x$1;
                            }
                            (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {});
                        }
                    } catch (sample) {
                        if (sample && control && "string" === typeof sample.stack) return [
                            sample.stack,
                            control.stack
                        ];
                    }
                    return [
                        null,
                        null
                    ];
                }
            };
            RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", {
                value: "DetermineComponentFrameRoot"
            });
            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
            if (sampleStack && controlStack) {
                var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
                for(_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes("DetermineComponentFrameRoot");)namePropDescriptor++;
                for(; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot");)_RunInRootFrame$Deter++;
                if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for(namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];)_RunInRootFrame$Deter--;
                for(; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                    if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                        do if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                            var _frame = "\n" + sampleLines[namePropDescriptor].replace(" at new ", " at ");
                            fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                            "function" === typeof fn && componentFrameCache.set(fn, _frame);
                            return _frame;
                        }
                        while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter)
                    }
                    break;
                }
            }
        } finally{
            reentry = !1, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;
        }
        sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
        "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
        return sampleLines;
    }
    function describeUnknownElementTypeFrameInDEV(type) {
        if (null == type) return "";
        if ("function" === typeof type) {
            var prototype = type.prototype;
            return describeNativeComponentFrame(type, !(!prototype || !prototype.isReactComponent));
        }
        if ("string" === typeof type) return describeBuiltInComponentFrame(type);
        switch(type){
            case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
        }
        if ("object" === typeof type) switch(type.$$typeof){
            case REACT_FORWARD_REF_TYPE:
                return type = describeNativeComponentFrame(type.render, !1), type;
            case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type);
            case REACT_LAZY_TYPE:
                prototype = type._payload;
                type = type._init;
                try {
                    return describeUnknownElementTypeFrameInDEV(type(prototype));
                } catch (x) {}
        }
        return "";
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props) {
        self = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self) {
        if ("string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE$1 || void 0 !== type.getModuleId)) {
            var children = config.children;
            if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {
                for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren], type);
                Object.freeze && Object.freeze(children);
            } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else validateChildKeys(children, type);
        } else {
            children = "";
            if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length) children += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            null === type ? isStaticChildren = "null" : isArrayImpl(type) ? isStaticChildren = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (isStaticChildren = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", children = " Did you accidentally export a JSX literal instead of a component?") : isStaticChildren = typeof type;
            console.error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", isStaticChildren, children);
        }
        if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
                return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, children, self, source, getOwner(), maybeKey);
    }
    function validateChildKeys(node, parentType) {
        if ("object" === typeof node && node && node.$$typeof !== REACT_CLIENT_REFERENCE) {
            if (isArrayImpl(node)) for(var i = 0; i < node.length; i++){
                var child = node[i];
                isValidElement(child) && validateExplicitKey(child, parentType);
            }
            else if (isValidElement(node)) node._store && (node._store.validated = 1);
            else if (null === node || "object" !== typeof node ? i = null : (i = MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL] || node["@@iterator"], i = "function" === typeof i ? i : null), "function" === typeof i && i !== node.entries && (i = i.call(node), i !== node)) for(; !(node = i.next()).done;)isValidElement(node.value) && validateExplicitKey(node.value, parentType);
        }
    }
    function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function validateExplicitKey(element, parentType) {
        if (element._store && !element._store.validated && null == element.key && (element._store.validated = 1, parentType = getCurrentComponentErrorInfo(parentType), !ownerHasKeyUseWarning[parentType])) {
            ownerHasKeyUseWarning[parentType] = !0;
            var childOwner = "";
            element && null != element._owner && element._owner !== getOwner() && (childOwner = null, "number" === typeof element._owner.tag ? childOwner = getComponentNameFromType(element._owner.type) : "string" === typeof element._owner.name && (childOwner = element._owner.name), childOwner = " It was passed a child from " + childOwner + ".");
            var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;
            ReactSharedInternals.getCurrentStack = function() {
                var stack = describeUnknownElementTypeFrameInDEV(element.type);
                prevGetCurrentStack && (stack += prevGetCurrentStack() || "");
                return stack;
            };
            console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', parentType, childOwner);
            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
        }
    }
    function getCurrentComponentErrorInfo(parentType) {
        var info = "", owner = getOwner();
        owner && (owner = getComponentNameFromType(owner.type)) && (info = "\n\nCheck the render method of `" + owner + "`.");
        info || (parentType = getComponentNameFromType(parentType)) && (info = "\n\nCheck the top-level render call using <" + parentType + ">.");
        return info;
    }
    var React = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE$2 = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, assign = Object.assign, REACT_CLIENT_REFERENCE$1 = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
    disabledLog.__reactDisabledLog = !0;
    var prefix, suffix, reentry = !1;
    var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
    var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var didWarnAboutKeySpread = {}, ownerHasKeyUseWarning = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren, source, self) {
        return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self);
    };
}();
}}),
"[project]/Documents/instant-demo/node_modules/next/dist/compiled/react/jsx-dev-runtime.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)");
}
}}),
"[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/image-blur-svg.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/**
 * A shared function, used on both client and server, to generate a SVG blur placeholder.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getImageBlurSvg", {
    enumerable: true,
    get: function() {
        return getImageBlurSvg;
    }
});
function getImageBlurSvg(param) {
    let { widthInt, heightInt, blurWidth, blurHeight, blurDataURL, objectFit } = param;
    const std = 20;
    const svgWidth = blurWidth ? blurWidth * 40 : widthInt;
    const svgHeight = blurHeight ? blurHeight * 40 : heightInt;
    const viewBox = svgWidth && svgHeight ? "viewBox='0 0 " + svgWidth + " " + svgHeight + "'" : '';
    const preserveAspectRatio = viewBox ? 'none' : objectFit === 'contain' ? 'xMidYMid' : objectFit === 'cover' ? 'xMidYMid slice' : 'none';
    return "%3Csvg xmlns='http://www.w3.org/2000/svg' " + viewBox + "%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='" + std + "'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='" + std + "'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='" + preserveAspectRatio + "' style='filter: url(%23b);' href='" + blurDataURL + "'/%3E%3C/svg%3E";
} //# sourceMappingURL=image-blur-svg.js.map
}}),
"[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/image-config.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    VALID_LOADERS: null,
    imageConfigDefault: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    VALID_LOADERS: function() {
        return VALID_LOADERS;
    },
    imageConfigDefault: function() {
        return imageConfigDefault;
    }
});
const VALID_LOADERS = [
    'default',
    'imgix',
    'cloudinary',
    'akamai',
    'custom'
];
const imageConfigDefault = {
    deviceSizes: [
        640,
        750,
        828,
        1080,
        1200,
        1920,
        2048,
        3840
    ],
    imageSizes: [
        16,
        32,
        48,
        64,
        96,
        128,
        256,
        384
    ],
    path: '/_next/image',
    loader: 'default',
    loaderFile: '',
    domains: [],
    disableStaticImages: false,
    minimumCacheTTL: 60,
    formats: [
        'image/webp'
    ],
    dangerouslyAllowSVG: false,
    contentSecurityPolicy: "script-src 'none'; frame-src 'none'; sandbox;",
    contentDispositionType: 'attachment',
    localPatterns: undefined,
    remotePatterns: [],
    qualities: undefined,
    unoptimized: false
}; //# sourceMappingURL=image-config.js.map
}}),
"[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/get-img-props.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getImgProps", {
    enumerable: true,
    get: function() {
        return getImgProps;
    }
});
const _warnonce = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/utils/warn-once.js [app-client] (ecmascript)");
const _imageblursvg = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/image-blur-svg.js [app-client] (ecmascript)");
const _imageconfig = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/image-config.js [app-client] (ecmascript)");
const VALID_LOADING_VALUES = [
    'lazy',
    'eager',
    undefined
];
function isStaticRequire(src) {
    return src.default !== undefined;
}
function isStaticImageData(src) {
    return src.src !== undefined;
}
function isStaticImport(src) {
    return !!src && typeof src === 'object' && (isStaticRequire(src) || isStaticImageData(src));
}
const allImgs = new Map();
let perfObserver;
function getInt(x) {
    if (typeof x === 'undefined') {
        return x;
    }
    if (typeof x === 'number') {
        return Number.isFinite(x) ? x : NaN;
    }
    if (typeof x === 'string' && /^[0-9]+$/.test(x)) {
        return parseInt(x, 10);
    }
    return NaN;
}
function getWidths(param, width, sizes) {
    let { deviceSizes, allSizes } = param;
    if (sizes) {
        // Find all the "vw" percent sizes used in the sizes prop
        const viewportWidthRe = /(^|\s)(1?\d?\d)vw/g;
        const percentSizes = [];
        for(let match; match = viewportWidthRe.exec(sizes); match){
            percentSizes.push(parseInt(match[2]));
        }
        if (percentSizes.length) {
            const smallestRatio = Math.min(...percentSizes) * 0.01;
            return {
                widths: allSizes.filter((s)=>s >= deviceSizes[0] * smallestRatio),
                kind: 'w'
            };
        }
        return {
            widths: allSizes,
            kind: 'w'
        };
    }
    if (typeof width !== 'number') {
        return {
            widths: deviceSizes,
            kind: 'w'
        };
    }
    const widths = [
        ...new Set(// > are actually 3x in the green color, but only 1.5x in the red and
        // > blue colors. Showing a 3x resolution image in the app vs a 2x
        // > resolution image will be visually the same, though the 3x image
        // > takes significantly more data. Even true 3x resolution screens are
        // > wasteful as the human eye cannot see that level of detail without
        // > something like a magnifying glass.
        // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html
        [
            width,
            width * 2 /*, width * 3*/ 
        ].map((w)=>allSizes.find((p)=>p >= w) || allSizes[allSizes.length - 1]))
    ];
    return {
        widths,
        kind: 'x'
    };
}
function generateImgAttrs(param) {
    let { config, src, unoptimized, width, quality, sizes, loader } = param;
    if (unoptimized) {
        return {
            src,
            srcSet: undefined,
            sizes: undefined
        };
    }
    const { widths, kind } = getWidths(config, width, sizes);
    const last = widths.length - 1;
    return {
        sizes: !sizes && kind === 'w' ? '100vw' : sizes,
        srcSet: widths.map((w, i)=>loader({
                config,
                src,
                quality,
                width: w
            }) + " " + (kind === 'w' ? w : i + 1) + kind).join(', '),
        // It's intended to keep `src` the last attribute because React updates
        // attributes in order. If we keep `src` the first one, Safari will
        // immediately start to fetch `src`, before `sizes` and `srcSet` are even
        // updated by React. That causes multiple unnecessary requests if `srcSet`
        // and `sizes` are defined.
        // This bug cannot be reproduced in Chrome or Firefox.
        src: loader({
            config,
            src,
            quality,
            width: widths[last]
        })
    };
}
function getImgProps(param, _state) {
    let { src, sizes, unoptimized = false, priority = false, loading, className, quality, width, height, fill = false, style, overrideSrc, onLoad, onLoadingComplete, placeholder = 'empty', blurDataURL, fetchPriority, decoding = 'async', layout, objectFit, objectPosition, lazyBoundary, lazyRoot, ...rest } = param;
    const { imgConf, showAltText, blurComplete, defaultLoader } = _state;
    let config;
    let c = imgConf || _imageconfig.imageConfigDefault;
    if ('allSizes' in c) {
        config = c;
    } else {
        var _c_qualities;
        const allSizes = [
            ...c.deviceSizes,
            ...c.imageSizes
        ].sort((a, b)=>a - b);
        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);
        const qualities = (_c_qualities = c.qualities) == null ? void 0 : _c_qualities.sort((a, b)=>a - b);
        config = {
            ...c,
            allSizes,
            deviceSizes,
            qualities
        };
    }
    if (typeof defaultLoader === 'undefined') {
        throw new Error('images.loaderFile detected but the file is missing default export.\nRead more: https://nextjs.org/docs/messages/invalid-images-config');
    }
    let loader = rest.loader || defaultLoader;
    // Remove property so it's not spread on <img> element
    delete rest.loader;
    delete rest.srcSet;
    // This special value indicates that the user
    // didn't define a "loader" prop or "loader" config.
    const isDefaultLoader = '__next_img_default' in loader;
    if (isDefaultLoader) {
        if (config.loader === 'custom') {
            throw new Error('Image with src "' + src + '" is missing "loader" prop.' + "\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader");
        }
    } else {
        // The user defined a "loader" prop or config.
        // Since the config object is internal only, we
        // must not pass it to the user-defined "loader".
        const customImageLoader = loader;
        loader = (obj)=>{
            const { config: _, ...opts } = obj;
            return customImageLoader(opts);
        };
    }
    if (layout) {
        if (layout === 'fill') {
            fill = true;
        }
        const layoutToStyle = {
            intrinsic: {
                maxWidth: '100%',
                height: 'auto'
            },
            responsive: {
                width: '100%',
                height: 'auto'
            }
        };
        const layoutToSizes = {
            responsive: '100vw',
            fill: '100vw'
        };
        const layoutStyle = layoutToStyle[layout];
        if (layoutStyle) {
            style = {
                ...style,
                ...layoutStyle
            };
        }
        const layoutSizes = layoutToSizes[layout];
        if (layoutSizes && !sizes) {
            sizes = layoutSizes;
        }
    }
    let staticSrc = '';
    let widthInt = getInt(width);
    let heightInt = getInt(height);
    let blurWidth;
    let blurHeight;
    if (isStaticImport(src)) {
        const staticImageData = isStaticRequire(src) ? src.default : src;
        if (!staticImageData.src) {
            throw new Error("An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received " + JSON.stringify(staticImageData));
        }
        if (!staticImageData.height || !staticImageData.width) {
            throw new Error("An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received " + JSON.stringify(staticImageData));
        }
        blurWidth = staticImageData.blurWidth;
        blurHeight = staticImageData.blurHeight;
        blurDataURL = blurDataURL || staticImageData.blurDataURL;
        staticSrc = staticImageData.src;
        if (!fill) {
            if (!widthInt && !heightInt) {
                widthInt = staticImageData.width;
                heightInt = staticImageData.height;
            } else if (widthInt && !heightInt) {
                const ratio = widthInt / staticImageData.width;
                heightInt = Math.round(staticImageData.height * ratio);
            } else if (!widthInt && heightInt) {
                const ratio = heightInt / staticImageData.height;
                widthInt = Math.round(staticImageData.width * ratio);
            }
        }
    }
    src = typeof src === 'string' ? src : staticSrc;
    let isLazy = !priority && (loading === 'lazy' || typeof loading === 'undefined');
    if (!src || src.startsWith('data:') || src.startsWith('blob:')) {
        // https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs
        unoptimized = true;
        isLazy = false;
    }
    if (config.unoptimized) {
        unoptimized = true;
    }
    if (isDefaultLoader && !config.dangerouslyAllowSVG && src.split('?', 1)[0].endsWith('.svg')) {
        // Special case to make svg serve as-is to avoid proxying
        // through the built-in Image Optimization API.
        unoptimized = true;
    }
    const qualityInt = getInt(quality);
    if ("TURBOPACK compile-time truthy", 1) {
        if (config.output === 'export' && isDefaultLoader && !unoptimized) {
            throw new Error("Image Optimization using the default loader is not compatible with `{ output: 'export' }`.\n  Possible solutions:\n    - Remove `{ output: 'export' }` and run \"next start\" to run server mode including the Image Optimization API.\n    - Configure `{ images: { unoptimized: true } }` in `next.config.js` to disable the Image Optimization API.\n  Read more: https://nextjs.org/docs/messages/export-image-api");
        }
        if (!src) {
            // React doesn't show the stack trace and there's
            // no `src` to help identify which image, so we
            // instead console.error(ref) during mount.
            unoptimized = true;
        } else {
            if (fill) {
                if (width) {
                    throw new Error('Image with src "' + src + '" has both "width" and "fill" properties. Only one should be used.');
                }
                if (height) {
                    throw new Error('Image with src "' + src + '" has both "height" and "fill" properties. Only one should be used.');
                }
                if ((style == null ? void 0 : style.position) && style.position !== 'absolute') {
                    throw new Error('Image with src "' + src + '" has both "fill" and "style.position" properties. Images with "fill" always use position absolute - it cannot be modified.');
                }
                if ((style == null ? void 0 : style.width) && style.width !== '100%') {
                    throw new Error('Image with src "' + src + '" has both "fill" and "style.width" properties. Images with "fill" always use width 100% - it cannot be modified.');
                }
                if ((style == null ? void 0 : style.height) && style.height !== '100%') {
                    throw new Error('Image with src "' + src + '" has both "fill" and "style.height" properties. Images with "fill" always use height 100% - it cannot be modified.');
                }
            } else {
                if (typeof widthInt === 'undefined') {
                    throw new Error('Image with src "' + src + '" is missing required "width" property.');
                } else if (isNaN(widthInt)) {
                    throw new Error('Image with src "' + src + '" has invalid "width" property. Expected a numeric value in pixels but received "' + width + '".');
                }
                if (typeof heightInt === 'undefined') {
                    throw new Error('Image with src "' + src + '" is missing required "height" property.');
                } else if (isNaN(heightInt)) {
                    throw new Error('Image with src "' + src + '" has invalid "height" property. Expected a numeric value in pixels but received "' + height + '".');
                }
                // eslint-disable-next-line no-control-regex
                if (/^[\x00-\x20]/.test(src)) {
                    throw new Error('Image with src "' + src + '" cannot start with a space or control character. Use src.trimStart() to remove it or encodeURIComponent(src) to keep it.');
                }
                // eslint-disable-next-line no-control-regex
                if (/[\x00-\x20]$/.test(src)) {
                    throw new Error('Image with src "' + src + '" cannot end with a space or control character. Use src.trimEnd() to remove it or encodeURIComponent(src) to keep it.');
                }
            }
        }
        if (!VALID_LOADING_VALUES.includes(loading)) {
            throw new Error('Image with src "' + src + '" has invalid "loading" property. Provided "' + loading + '" should be one of ' + VALID_LOADING_VALUES.map(String).join(',') + ".");
        }
        if (priority && loading === 'lazy') {
            throw new Error('Image with src "' + src + '" has both "priority" and "loading=\'lazy\'" properties. Only one should be used.');
        }
        if (placeholder !== 'empty' && placeholder !== 'blur' && !placeholder.startsWith('data:image/')) {
            throw new Error('Image with src "' + src + '" has invalid "placeholder" property "' + placeholder + '".');
        }
        if (placeholder !== 'empty') {
            if (widthInt && heightInt && widthInt * heightInt < 1600) {
                (0, _warnonce.warnOnce)('Image with src "' + src + '" is smaller than 40x40. Consider removing the "placeholder" property to improve performance.');
            }
        }
        if (placeholder === 'blur' && !blurDataURL) {
            const VALID_BLUR_EXT = [
                'jpeg',
                'png',
                'webp',
                'avif'
            ] // should match next-image-loader
            ;
            throw new Error('Image with src "' + src + '" has "placeholder=\'blur\'" property but is missing the "blurDataURL" property.\n        Possible solutions:\n          - Add a "blurDataURL" property, the contents should be a small Data URL to represent the image\n          - Change the "src" property to a static import with one of the supported file types: ' + VALID_BLUR_EXT.join(',') + ' (animated images not supported)\n          - Remove the "placeholder" property, effectively no blur effect\n        Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url');
        }
        if ('ref' in rest) {
            (0, _warnonce.warnOnce)('Image with src "' + src + '" is using unsupported "ref" property. Consider using the "onLoad" property instead.');
        }
        if (!unoptimized && !isDefaultLoader) {
            const urlStr = loader({
                config,
                src,
                width: widthInt || 400,
                quality: qualityInt || 75
            });
            let url;
            try {
                url = new URL(urlStr);
            } catch (err) {}
            if (urlStr === src || url && url.pathname === src && !url.search) {
                (0, _warnonce.warnOnce)('Image with src "' + src + '" has a "loader" property that does not implement width. Please implement it or use the "unoptimized" property instead.' + "\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width");
            }
        }
        if (onLoadingComplete) {
            (0, _warnonce.warnOnce)('Image with src "' + src + '" is using deprecated "onLoadingComplete" property. Please use the "onLoad" property instead.');
        }
        for (const [legacyKey, legacyValue] of Object.entries({
            layout,
            objectFit,
            objectPosition,
            lazyBoundary,
            lazyRoot
        })){
            if (legacyValue) {
                (0, _warnonce.warnOnce)('Image with src "' + src + '" has legacy prop "' + legacyKey + '". Did you forget to run the codemod?' + "\nRead more: https://nextjs.org/docs/messages/next-image-upgrade-to-13");
            }
        }
        if (typeof window !== 'undefined' && !perfObserver && window.PerformanceObserver) {
            perfObserver = new PerformanceObserver((entryList)=>{
                for (const entry of entryList.getEntries()){
                    var _entry_element;
                    // @ts-ignore - missing "LargestContentfulPaint" class with "element" prop
                    const imgSrc = (entry == null ? void 0 : (_entry_element = entry.element) == null ? void 0 : _entry_element.src) || '';
                    const lcpImage = allImgs.get(imgSrc);
                    if (lcpImage && !lcpImage.priority && lcpImage.placeholder === 'empty' && !lcpImage.src.startsWith('data:') && !lcpImage.src.startsWith('blob:')) {
                        // https://web.dev/lcp/#measure-lcp-in-javascript
                        (0, _warnonce.warnOnce)('Image with src "' + lcpImage.src + '" was detected as the Largest Contentful Paint (LCP). Please add the "priority" property if this image is above the fold.' + "\nRead more: https://nextjs.org/docs/api-reference/next/image#priority");
                    }
                }
            });
            try {
                perfObserver.observe({
                    type: 'largest-contentful-paint',
                    buffered: true
                });
            } catch (err) {
                // Log error but don't crash the app
                console.error(err);
            }
        }
    }
    const imgStyle = Object.assign(fill ? {
        position: 'absolute',
        height: '100%',
        width: '100%',
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        objectFit,
        objectPosition
    } : {}, showAltText ? {} : {
        color: 'transparent'
    }, style);
    const backgroundImage = !blurComplete && placeholder !== 'empty' ? placeholder === 'blur' ? 'url("data:image/svg+xml;charset=utf-8,' + (0, _imageblursvg.getImageBlurSvg)({
        widthInt,
        heightInt,
        blurWidth,
        blurHeight,
        blurDataURL: blurDataURL || '',
        objectFit: imgStyle.objectFit
    }) + '")' : 'url("' + placeholder + '")' // assume `data:image/`
     : null;
    let placeholderStyle = backgroundImage ? {
        backgroundSize: imgStyle.objectFit || 'cover',
        backgroundPosition: imgStyle.objectPosition || '50% 50%',
        backgroundRepeat: 'no-repeat',
        backgroundImage
    } : {};
    if ("TURBOPACK compile-time truthy", 1) {
        if (placeholderStyle.backgroundImage && placeholder === 'blur' && (blurDataURL == null ? void 0 : blurDataURL.startsWith('/'))) {
            // During `next dev`, we don't want to generate blur placeholders with webpack
            // because it can delay starting the dev server. Instead, `next-image-loader.js`
            // will inline a special url to lazily generate the blur placeholder at request time.
            placeholderStyle.backgroundImage = 'url("' + blurDataURL + '")';
        }
    }
    const imgAttributes = generateImgAttrs({
        config,
        src,
        unoptimized,
        width: widthInt,
        quality: qualityInt,
        sizes,
        loader
    });
    if ("TURBOPACK compile-time truthy", 1) {
        if (typeof window !== 'undefined') {
            let fullUrl;
            try {
                fullUrl = new URL(imgAttributes.src);
            } catch (e) {
                fullUrl = new URL(imgAttributes.src, window.location.href);
            }
            allImgs.set(fullUrl.href, {
                src,
                priority,
                placeholder
            });
        }
    }
    const props = {
        ...rest,
        loading: isLazy ? 'lazy' : loading,
        fetchPriority,
        width: widthInt,
        height: heightInt,
        decoding,
        className,
        style: {
            ...imgStyle,
            ...placeholderStyle
        },
        sizes: imgAttributes.sizes,
        srcSet: imgAttributes.srcSet,
        src: overrideSrc || imgAttributes.src
    };
    const meta = {
        unoptimized,
        priority,
        placeholder,
        fill
    };
    return {
        props,
        meta
    };
} //# sourceMappingURL=get-img-props.js.map
}}),
"[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/side-effect.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return SideEffect;
    }
});
const _react = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
const isServer = typeof window === 'undefined';
const useClientOnlyLayoutEffect = isServer ? ()=>{} : _react.useLayoutEffect;
const useClientOnlyEffect = isServer ? ()=>{} : _react.useEffect;
function SideEffect(props) {
    const { headManager, reduceComponentsToState } = props;
    function emitChange() {
        if (headManager && headManager.mountedInstances) {
            const headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));
            headManager.updateHead(reduceComponentsToState(headElements, props));
        }
    }
    if (isServer) {
        var _headManager_mountedInstances;
        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);
        emitChange();
    }
    useClientOnlyLayoutEffect({
        "SideEffect.useClientOnlyLayoutEffect": ()=>{
            var _headManager_mountedInstances;
            headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);
            return ({
                "SideEffect.useClientOnlyLayoutEffect": ()=>{
                    var _headManager_mountedInstances;
                    headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.delete(props.children);
                }
            })["SideEffect.useClientOnlyLayoutEffect"];
        }
    }["SideEffect.useClientOnlyLayoutEffect"]);
    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all
    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s
    // being rendered, we only trigger the method from the last one.
    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`
    // singleton in the layout effect pass, and actually trigger it in the effect pass.
    useClientOnlyLayoutEffect({
        "SideEffect.useClientOnlyLayoutEffect": ()=>{
            if (headManager) {
                headManager._pendingUpdate = emitChange;
            }
            return ({
                "SideEffect.useClientOnlyLayoutEffect": ()=>{
                    if (headManager) {
                        headManager._pendingUpdate = emitChange;
                    }
                }
            })["SideEffect.useClientOnlyLayoutEffect"];
        }
    }["SideEffect.useClientOnlyLayoutEffect"]);
    useClientOnlyEffect({
        "SideEffect.useClientOnlyEffect": ()=>{
            if (headManager && headManager._pendingUpdate) {
                headManager._pendingUpdate();
                headManager._pendingUpdate = null;
            }
            return ({
                "SideEffect.useClientOnlyEffect": ()=>{
                    if (headManager && headManager._pendingUpdate) {
                        headManager._pendingUpdate();
                        headManager._pendingUpdate = null;
                    }
                }
            })["SideEffect.useClientOnlyEffect"];
        }
    }["SideEffect.useClientOnlyEffect"]);
    return null;
} //# sourceMappingURL=side-effect.js.map
}}),
"[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/amp-context.shared-runtime.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "AmpStateContext", {
    enumerable: true,
    get: function() {
        return AmpStateContext;
    }
});
const _interop_require_default = __turbopack_require__("[project]/Documents/instant-demo/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_default._(__turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const AmpStateContext = _react.default.createContext({});
if ("TURBOPACK compile-time truthy", 1) {
    AmpStateContext.displayName = 'AmpStateContext';
} //# sourceMappingURL=amp-context.shared-runtime.js.map
}}),
"[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/amp-mode.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isInAmpMode", {
    enumerable: true,
    get: function() {
        return isInAmpMode;
    }
});
function isInAmpMode(param) {
    let { ampFirst = false, hybrid = false, hasQuery = false } = param === void 0 ? {} : param;
    return ampFirst || hybrid && hasQuery;
} //# sourceMappingURL=amp-mode.js.map
}}),
"[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/head.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    defaultHead: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    defaultHead: function() {
        return defaultHead;
    }
});
const _interop_require_default = __turbopack_require__("[project]/Documents/instant-demo/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _interop_require_wildcard = __turbopack_require__("[project]/Documents/instant-demo/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)");
const _jsxruntime = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const _sideeffect = /*#__PURE__*/ _interop_require_default._(__turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/side-effect.js [app-client] (ecmascript)"));
const _ampcontextsharedruntime = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/amp-context.shared-runtime.js [app-client] (ecmascript)");
const _headmanagercontextsharedruntime = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js [app-client] (ecmascript)");
const _ampmode = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/amp-mode.js [app-client] (ecmascript)");
const _warnonce = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/utils/warn-once.js [app-client] (ecmascript)");
function defaultHead(inAmpMode) {
    if (inAmpMode === void 0) inAmpMode = false;
    const head = [
        /*#__PURE__*/ (0, _jsxruntime.jsx)("meta", {
            charSet: "utf-8"
        }, "charset")
    ];
    if (!inAmpMode) {
        head.push(/*#__PURE__*/ (0, _jsxruntime.jsx)("meta", {
            name: "viewport",
            content: "width=device-width"
        }, "viewport"));
    }
    return head;
}
function onlyReactElement(list, child) {
    // React children can be "string" or "number" in this case we ignore them for backwards compat
    if (typeof child === 'string' || typeof child === 'number') {
        return list;
    }
    // Adds support for React.Fragment
    if (child.type === _react.default.Fragment) {
        return list.concat(_react.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild)=>{
            if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {
                return fragmentList;
            }
            return fragmentList.concat(fragmentChild);
        }, []));
    }
    return list.concat(child);
}
const METATYPES = [
    'name',
    'httpEquiv',
    'charSet',
    'itemProp'
];
/*
 returns a function for filtering head child elements
 which shouldn't be duplicated, like <title/>
 Also adds support for deduplicated `key` properties
*/ function unique() {
    const keys = new Set();
    const tags = new Set();
    const metaTypes = new Set();
    const metaCategories = {};
    return (h)=>{
        let isUnique = true;
        let hasKey = false;
        if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {
            hasKey = true;
            const key = h.key.slice(h.key.indexOf('$') + 1);
            if (keys.has(key)) {
                isUnique = false;
            } else {
                keys.add(key);
            }
        }
        // eslint-disable-next-line default-case
        switch(h.type){
            case 'title':
            case 'base':
                if (tags.has(h.type)) {
                    isUnique = false;
                } else {
                    tags.add(h.type);
                }
                break;
            case 'meta':
                for(let i = 0, len = METATYPES.length; i < len; i++){
                    const metatype = METATYPES[i];
                    if (!h.props.hasOwnProperty(metatype)) continue;
                    if (metatype === 'charSet') {
                        if (metaTypes.has(metatype)) {
                            isUnique = false;
                        } else {
                            metaTypes.add(metatype);
                        }
                    } else {
                        const category = h.props[metatype];
                        const categories = metaCategories[metatype] || new Set();
                        if ((metatype !== 'name' || !hasKey) && categories.has(category)) {
                            isUnique = false;
                        } else {
                            categories.add(category);
                            metaCategories[metatype] = categories;
                        }
                    }
                }
                break;
        }
        return isUnique;
    };
}
/**
 *
 * @param headChildrenElements List of children of <Head>
 */ function reduceComponents(headChildrenElements, props) {
    const { inAmpMode } = props;
    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead(inAmpMode).reverse()).filter(unique()).reverse().map((c, i)=>{
        const key = c.key || i;
        if ("TURBOPACK compile-time falsy", 0) {
            "TURBOPACK unreachable";
        }
        if ("TURBOPACK compile-time truthy", 1) {
            // omit JSON-LD structured data snippets from the warning
            if (c.type === 'script' && c.props['type'] !== 'application/ld+json') {
                const srcMessage = c.props['src'] ? '<script> tag with src="' + c.props['src'] + '"' : "inline <script>";
                (0, _warnonce.warnOnce)("Do not add <script> tags using next/head (see " + srcMessage + "). Use next/script instead. \nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component");
            } else if (c.type === 'link' && c.props['rel'] === 'stylesheet') {
                (0, _warnonce.warnOnce)('Do not add stylesheets using next/head (see <link rel="stylesheet"> tag with href="' + c.props['href'] + '"). Use Document instead. \nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component');
            }
        }
        return /*#__PURE__*/ _react.default.cloneElement(c, {
            key
        });
    });
}
/**
 * This component injects elements to `<head>` of your page.
 * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.
 */ function Head(param) {
    let { children } = param;
    const ampState = (0, _react.useContext)(_ampcontextsharedruntime.AmpStateContext);
    const headManager = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_sideeffect.default, {
        reduceComponentsToState: reduceComponents,
        headManager: headManager,
        inAmpMode: (0, _ampmode.isInAmpMode)(ampState),
        children: children
    });
}
const _default = Head;
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=head.js.map
}}),
"[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ImageConfigContext", {
    enumerable: true,
    get: function() {
        return ImageConfigContext;
    }
});
const _interop_require_default = __turbopack_require__("[project]/Documents/instant-demo/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_default._(__turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const _imageconfig = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/image-config.js [app-client] (ecmascript)");
const ImageConfigContext = _react.default.createContext(_imageconfig.imageConfigDefault);
if ("TURBOPACK compile-time truthy", 1) {
    ImageConfigContext.displayName = 'ImageConfigContext';
} //# sourceMappingURL=image-config-context.shared-runtime.js.map
}}),
"[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/router-context.shared-runtime.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "RouterContext", {
    enumerable: true,
    get: function() {
        return RouterContext;
    }
});
const _interop_require_default = __turbopack_require__("[project]/Documents/instant-demo/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_default._(__turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const RouterContext = _react.default.createContext(null);
if ("TURBOPACK compile-time truthy", 1) {
    RouterContext.displayName = 'RouterContext';
} //# sourceMappingURL=router-context.shared-runtime.js.map
}}),
"[project]/Documents/instant-demo/node_modules/next/dist/compiled/picomatch/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
(()=>{
    "use strict";
    var t = {
        170: (t, e, u)=>{
            const n = u(510);
            const isWindows = ()=>{
                if (typeof navigator !== "undefined" && navigator.platform) {
                    const t = navigator.platform.toLowerCase();
                    return t === "win32" || t === "windows";
                }
                if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== "undefined" && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform) {
                    return __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform === "win32";
                }
                return false;
            };
            function picomatch(t, e, u = false) {
                if (e && (e.windows === null || e.windows === undefined)) {
                    e = {
                        ...e,
                        windows: isWindows()
                    };
                }
                return n(t, e, u);
            }
            Object.assign(picomatch, n);
            t.exports = picomatch;
        },
        154: (t)=>{
            const e = "\\\\/";
            const u = `[^${e}]`;
            const n = "\\.";
            const o = "\\+";
            const s = "\\?";
            const r = "\\/";
            const a = "(?=.)";
            const i = "[^/]";
            const c = `(?:${r}|$)`;
            const p = `(?:^|${r})`;
            const l = `${n}{1,2}${c}`;
            const f = `(?!${n})`;
            const A = `(?!${p}${l})`;
            const _ = `(?!${n}{0,1}${c})`;
            const R = `(?!${l})`;
            const E = `[^.${r}]`;
            const h = `${i}*?`;
            const g = "/";
            const b = {
                DOT_LITERAL: n,
                PLUS_LITERAL: o,
                QMARK_LITERAL: s,
                SLASH_LITERAL: r,
                ONE_CHAR: a,
                QMARK: i,
                END_ANCHOR: c,
                DOTS_SLASH: l,
                NO_DOT: f,
                NO_DOTS: A,
                NO_DOT_SLASH: _,
                NO_DOTS_SLASH: R,
                QMARK_NO_DOT: E,
                STAR: h,
                START_ANCHOR: p,
                SEP: g
            };
            const C = {
                ...b,
                SLASH_LITERAL: `[${e}]`,
                QMARK: u,
                STAR: `${u}*?`,
                DOTS_SLASH: `${n}{1,2}(?:[${e}]|$)`,
                NO_DOT: `(?!${n})`,
                NO_DOTS: `(?!(?:^|[${e}])${n}{1,2}(?:[${e}]|$))`,
                NO_DOT_SLASH: `(?!${n}{0,1}(?:[${e}]|$))`,
                NO_DOTS_SLASH: `(?!${n}{1,2}(?:[${e}]|$))`,
                QMARK_NO_DOT: `[^.${e}]`,
                START_ANCHOR: `(?:^|[${e}])`,
                END_ANCHOR: `(?:[${e}]|$)`,
                SEP: "\\"
            };
            const y = {
                alnum: "a-zA-Z0-9",
                alpha: "a-zA-Z",
                ascii: "\\x00-\\x7F",
                blank: " \\t",
                cntrl: "\\x00-\\x1F\\x7F",
                digit: "0-9",
                graph: "\\x21-\\x7E",
                lower: "a-z",
                print: "\\x20-\\x7E ",
                punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
                space: " \\t\\r\\n\\v\\f",
                upper: "A-Z",
                word: "A-Za-z0-9_",
                xdigit: "A-Fa-f0-9"
            };
            t.exports = {
                MAX_LENGTH: 1024 * 64,
                POSIX_REGEX_SOURCE: y,
                REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
                REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
                REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
                REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
                REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
                REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
                REPLACEMENTS: {
                    "***": "*",
                    "**/**": "**",
                    "**/**/**": "**"
                },
                CHAR_0: 48,
                CHAR_9: 57,
                CHAR_UPPERCASE_A: 65,
                CHAR_LOWERCASE_A: 97,
                CHAR_UPPERCASE_Z: 90,
                CHAR_LOWERCASE_Z: 122,
                CHAR_LEFT_PARENTHESES: 40,
                CHAR_RIGHT_PARENTHESES: 41,
                CHAR_ASTERISK: 42,
                CHAR_AMPERSAND: 38,
                CHAR_AT: 64,
                CHAR_BACKWARD_SLASH: 92,
                CHAR_CARRIAGE_RETURN: 13,
                CHAR_CIRCUMFLEX_ACCENT: 94,
                CHAR_COLON: 58,
                CHAR_COMMA: 44,
                CHAR_DOT: 46,
                CHAR_DOUBLE_QUOTE: 34,
                CHAR_EQUAL: 61,
                CHAR_EXCLAMATION_MARK: 33,
                CHAR_FORM_FEED: 12,
                CHAR_FORWARD_SLASH: 47,
                CHAR_GRAVE_ACCENT: 96,
                CHAR_HASH: 35,
                CHAR_HYPHEN_MINUS: 45,
                CHAR_LEFT_ANGLE_BRACKET: 60,
                CHAR_LEFT_CURLY_BRACE: 123,
                CHAR_LEFT_SQUARE_BRACKET: 91,
                CHAR_LINE_FEED: 10,
                CHAR_NO_BREAK_SPACE: 160,
                CHAR_PERCENT: 37,
                CHAR_PLUS: 43,
                CHAR_QUESTION_MARK: 63,
                CHAR_RIGHT_ANGLE_BRACKET: 62,
                CHAR_RIGHT_CURLY_BRACE: 125,
                CHAR_RIGHT_SQUARE_BRACKET: 93,
                CHAR_SEMICOLON: 59,
                CHAR_SINGLE_QUOTE: 39,
                CHAR_SPACE: 32,
                CHAR_TAB: 9,
                CHAR_UNDERSCORE: 95,
                CHAR_VERTICAL_LINE: 124,
                CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
                extglobChars (t) {
                    return {
                        "!": {
                            type: "negate",
                            open: "(?:(?!(?:",
                            close: `))${t.STAR})`
                        },
                        "?": {
                            type: "qmark",
                            open: "(?:",
                            close: ")?"
                        },
                        "+": {
                            type: "plus",
                            open: "(?:",
                            close: ")+"
                        },
                        "*": {
                            type: "star",
                            open: "(?:",
                            close: ")*"
                        },
                        "@": {
                            type: "at",
                            open: "(?:",
                            close: ")"
                        }
                    };
                },
                globChars (t) {
                    return t === true ? C : b;
                }
            };
        },
        697: (t, e, u)=>{
            const n = u(154);
            const o = u(96);
            const { MAX_LENGTH: s, POSIX_REGEX_SOURCE: r, REGEX_NON_SPECIAL_CHARS: a, REGEX_SPECIAL_CHARS_BACKREF: i, REPLACEMENTS: c } = n;
            const expandRange = (t, e)=>{
                if (typeof e.expandRange === "function") {
                    return e.expandRange(...t, e);
                }
                t.sort();
                const u = `[${t.join("-")}]`;
                try {
                    new RegExp(u);
                } catch (e) {
                    return t.map((t)=>o.escapeRegex(t)).join("..");
                }
                return u;
            };
            const syntaxError = (t, e)=>`Missing ${t}: "${e}" - use "\\\\${e}" to match literal characters`;
            const parse = (t, e)=>{
                if (typeof t !== "string") {
                    throw new TypeError("Expected a string");
                }
                t = c[t] || t;
                const u = {
                    ...e
                };
                const p = typeof u.maxLength === "number" ? Math.min(s, u.maxLength) : s;
                let l = t.length;
                if (l > p) {
                    throw new SyntaxError(`Input length: ${l}, exceeds maximum allowed length: ${p}`);
                }
                const f = {
                    type: "bos",
                    value: "",
                    output: u.prepend || ""
                };
                const A = [
                    f
                ];
                const _ = u.capture ? "" : "?:";
                const R = n.globChars(u.windows);
                const E = n.extglobChars(R);
                const { DOT_LITERAL: h, PLUS_LITERAL: g, SLASH_LITERAL: b, ONE_CHAR: C, DOTS_SLASH: y, NO_DOT: $, NO_DOT_SLASH: x, NO_DOTS_SLASH: S, QMARK: H, QMARK_NO_DOT: v, STAR: d, START_ANCHOR: L } = R;
                const globstar = (t)=>`(${_}(?:(?!${L}${t.dot ? y : h}).)*?)`;
                const T = u.dot ? "" : $;
                const O = u.dot ? H : v;
                let k = u.bash === true ? globstar(u) : d;
                if (u.capture) {
                    k = `(${k})`;
                }
                if (typeof u.noext === "boolean") {
                    u.noextglob = u.noext;
                }
                const m = {
                    input: t,
                    index: -1,
                    start: 0,
                    dot: u.dot === true,
                    consumed: "",
                    output: "",
                    prefix: "",
                    backtrack: false,
                    negated: false,
                    brackets: 0,
                    braces: 0,
                    parens: 0,
                    quotes: 0,
                    globstar: false,
                    tokens: A
                };
                t = o.removePrefix(t, m);
                l = t.length;
                const w = [];
                const N = [];
                const I = [];
                let B = f;
                let G;
                const eos = ()=>m.index === l - 1;
                const D = m.peek = (e = 1)=>t[m.index + e];
                const M = m.advance = ()=>t[++m.index] || "";
                const remaining = ()=>t.slice(m.index + 1);
                const consume = (t = "", e = 0)=>{
                    m.consumed += t;
                    m.index += e;
                };
                const append = (t)=>{
                    m.output += t.output != null ? t.output : t.value;
                    consume(t.value);
                };
                const negate = ()=>{
                    let t = 1;
                    while(D() === "!" && (D(2) !== "(" || D(3) === "?")){
                        M();
                        m.start++;
                        t++;
                    }
                    if (t % 2 === 0) {
                        return false;
                    }
                    m.negated = true;
                    m.start++;
                    return true;
                };
                const increment = (t)=>{
                    m[t]++;
                    I.push(t);
                };
                const decrement = (t)=>{
                    m[t]--;
                    I.pop();
                };
                const push = (t)=>{
                    if (B.type === "globstar") {
                        const e = m.braces > 0 && (t.type === "comma" || t.type === "brace");
                        const u = t.extglob === true || w.length && (t.type === "pipe" || t.type === "paren");
                        if (t.type !== "slash" && t.type !== "paren" && !e && !u) {
                            m.output = m.output.slice(0, -B.output.length);
                            B.type = "star";
                            B.value = "*";
                            B.output = k;
                            m.output += B.output;
                        }
                    }
                    if (w.length && t.type !== "paren") {
                        w[w.length - 1].inner += t.value;
                    }
                    if (t.value || t.output) append(t);
                    if (B && B.type === "text" && t.type === "text") {
                        B.output = (B.output || B.value) + t.value;
                        B.value += t.value;
                        return;
                    }
                    t.prev = B;
                    A.push(t);
                    B = t;
                };
                const extglobOpen = (t, e)=>{
                    const n = {
                        ...E[e],
                        conditions: 1,
                        inner: ""
                    };
                    n.prev = B;
                    n.parens = m.parens;
                    n.output = m.output;
                    const o = (u.capture ? "(" : "") + n.open;
                    increment("parens");
                    push({
                        type: t,
                        value: e,
                        output: m.output ? "" : C
                    });
                    push({
                        type: "paren",
                        extglob: true,
                        value: M(),
                        output: o
                    });
                    w.push(n);
                };
                const extglobClose = (t)=>{
                    let n = t.close + (u.capture ? ")" : "");
                    let o;
                    if (t.type === "negate") {
                        let s = k;
                        if (t.inner && t.inner.length > 1 && t.inner.includes("/")) {
                            s = globstar(u);
                        }
                        if (s !== k || eos() || /^\)+$/.test(remaining())) {
                            n = t.close = `)$))${s}`;
                        }
                        if (t.inner.includes("*") && (o = remaining()) && /^\.[^\\/.]+$/.test(o)) {
                            const u = parse(o, {
                                ...e,
                                fastpaths: false
                            }).output;
                            n = t.close = `)${u})${s})`;
                        }
                        if (t.prev.type === "bos") {
                            m.negatedExtglob = true;
                        }
                    }
                    push({
                        type: "paren",
                        extglob: true,
                        value: G,
                        output: n
                    });
                    decrement("parens");
                };
                if (u.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(t)) {
                    let n = false;
                    let s = t.replace(i, (t, e, u, o, s, r)=>{
                        if (o === "\\") {
                            n = true;
                            return t;
                        }
                        if (o === "?") {
                            if (e) {
                                return e + o + (s ? H.repeat(s.length) : "");
                            }
                            if (r === 0) {
                                return O + (s ? H.repeat(s.length) : "");
                            }
                            return H.repeat(u.length);
                        }
                        if (o === ".") {
                            return h.repeat(u.length);
                        }
                        if (o === "*") {
                            if (e) {
                                return e + o + (s ? k : "");
                            }
                            return k;
                        }
                        return e ? t : `\\${t}`;
                    });
                    if (n === true) {
                        if (u.unescape === true) {
                            s = s.replace(/\\/g, "");
                        } else {
                            s = s.replace(/\\+/g, (t)=>t.length % 2 === 0 ? "\\\\" : t ? "\\" : "");
                        }
                    }
                    if (s === t && u.contains === true) {
                        m.output = t;
                        return m;
                    }
                    m.output = o.wrapOutput(s, m, e);
                    return m;
                }
                while(!eos()){
                    G = M();
                    if (G === "\0") {
                        continue;
                    }
                    if (G === "\\") {
                        const t = D();
                        if (t === "/" && u.bash !== true) {
                            continue;
                        }
                        if (t === "." || t === ";") {
                            continue;
                        }
                        if (!t) {
                            G += "\\";
                            push({
                                type: "text",
                                value: G
                            });
                            continue;
                        }
                        const e = /^\\+/.exec(remaining());
                        let n = 0;
                        if (e && e[0].length > 2) {
                            n = e[0].length;
                            m.index += n;
                            if (n % 2 !== 0) {
                                G += "\\";
                            }
                        }
                        if (u.unescape === true) {
                            G = M();
                        } else {
                            G += M();
                        }
                        if (m.brackets === 0) {
                            push({
                                type: "text",
                                value: G
                            });
                            continue;
                        }
                    }
                    if (m.brackets > 0 && (G !== "]" || B.value === "[" || B.value === "[^")) {
                        if (u.posix !== false && G === ":") {
                            const t = B.value.slice(1);
                            if (t.includes("[")) {
                                B.posix = true;
                                if (t.includes(":")) {
                                    const t = B.value.lastIndexOf("[");
                                    const e = B.value.slice(0, t);
                                    const u = B.value.slice(t + 2);
                                    const n = r[u];
                                    if (n) {
                                        B.value = e + n;
                                        m.backtrack = true;
                                        M();
                                        if (!f.output && A.indexOf(B) === 1) {
                                            f.output = C;
                                        }
                                        continue;
                                    }
                                }
                            }
                        }
                        if (G === "[" && D() !== ":" || G === "-" && D() === "]") {
                            G = `\\${G}`;
                        }
                        if (G === "]" && (B.value === "[" || B.value === "[^")) {
                            G = `\\${G}`;
                        }
                        if (u.posix === true && G === "!" && B.value === "[") {
                            G = "^";
                        }
                        B.value += G;
                        append({
                            value: G
                        });
                        continue;
                    }
                    if (m.quotes === 1 && G !== '"') {
                        G = o.escapeRegex(G);
                        B.value += G;
                        append({
                            value: G
                        });
                        continue;
                    }
                    if (G === '"') {
                        m.quotes = m.quotes === 1 ? 0 : 1;
                        if (u.keepQuotes === true) {
                            push({
                                type: "text",
                                value: G
                            });
                        }
                        continue;
                    }
                    if (G === "(") {
                        increment("parens");
                        push({
                            type: "paren",
                            value: G
                        });
                        continue;
                    }
                    if (G === ")") {
                        if (m.parens === 0 && u.strictBrackets === true) {
                            throw new SyntaxError(syntaxError("opening", "("));
                        }
                        const t = w[w.length - 1];
                        if (t && m.parens === t.parens + 1) {
                            extglobClose(w.pop());
                            continue;
                        }
                        push({
                            type: "paren",
                            value: G,
                            output: m.parens ? ")" : "\\)"
                        });
                        decrement("parens");
                        continue;
                    }
                    if (G === "[") {
                        if (u.nobracket === true || !remaining().includes("]")) {
                            if (u.nobracket !== true && u.strictBrackets === true) {
                                throw new SyntaxError(syntaxError("closing", "]"));
                            }
                            G = `\\${G}`;
                        } else {
                            increment("brackets");
                        }
                        push({
                            type: "bracket",
                            value: G
                        });
                        continue;
                    }
                    if (G === "]") {
                        if (u.nobracket === true || B && B.type === "bracket" && B.value.length === 1) {
                            push({
                                type: "text",
                                value: G,
                                output: `\\${G}`
                            });
                            continue;
                        }
                        if (m.brackets === 0) {
                            if (u.strictBrackets === true) {
                                throw new SyntaxError(syntaxError("opening", "["));
                            }
                            push({
                                type: "text",
                                value: G,
                                output: `\\${G}`
                            });
                            continue;
                        }
                        decrement("brackets");
                        const t = B.value.slice(1);
                        if (B.posix !== true && t[0] === "^" && !t.includes("/")) {
                            G = `/${G}`;
                        }
                        B.value += G;
                        append({
                            value: G
                        });
                        if (u.literalBrackets === false || o.hasRegexChars(t)) {
                            continue;
                        }
                        const e = o.escapeRegex(B.value);
                        m.output = m.output.slice(0, -B.value.length);
                        if (u.literalBrackets === true) {
                            m.output += e;
                            B.value = e;
                            continue;
                        }
                        B.value = `(${_}${e}|${B.value})`;
                        m.output += B.value;
                        continue;
                    }
                    if (G === "{" && u.nobrace !== true) {
                        increment("braces");
                        const t = {
                            type: "brace",
                            value: G,
                            output: "(",
                            outputIndex: m.output.length,
                            tokensIndex: m.tokens.length
                        };
                        N.push(t);
                        push(t);
                        continue;
                    }
                    if (G === "}") {
                        const t = N[N.length - 1];
                        if (u.nobrace === true || !t) {
                            push({
                                type: "text",
                                value: G,
                                output: G
                            });
                            continue;
                        }
                        let e = ")";
                        if (t.dots === true) {
                            const t = A.slice();
                            const n = [];
                            for(let e = t.length - 1; e >= 0; e--){
                                A.pop();
                                if (t[e].type === "brace") {
                                    break;
                                }
                                if (t[e].type !== "dots") {
                                    n.unshift(t[e].value);
                                }
                            }
                            e = expandRange(n, u);
                            m.backtrack = true;
                        }
                        if (t.comma !== true && t.dots !== true) {
                            const u = m.output.slice(0, t.outputIndex);
                            const n = m.tokens.slice(t.tokensIndex);
                            t.value = t.output = "\\{";
                            G = e = "\\}";
                            m.output = u;
                            for (const t of n){
                                m.output += t.output || t.value;
                            }
                        }
                        push({
                            type: "brace",
                            value: G,
                            output: e
                        });
                        decrement("braces");
                        N.pop();
                        continue;
                    }
                    if (G === "|") {
                        if (w.length > 0) {
                            w[w.length - 1].conditions++;
                        }
                        push({
                            type: "text",
                            value: G
                        });
                        continue;
                    }
                    if (G === ",") {
                        let t = G;
                        const e = N[N.length - 1];
                        if (e && I[I.length - 1] === "braces") {
                            e.comma = true;
                            t = "|";
                        }
                        push({
                            type: "comma",
                            value: G,
                            output: t
                        });
                        continue;
                    }
                    if (G === "/") {
                        if (B.type === "dot" && m.index === m.start + 1) {
                            m.start = m.index + 1;
                            m.consumed = "";
                            m.output = "";
                            A.pop();
                            B = f;
                            continue;
                        }
                        push({
                            type: "slash",
                            value: G,
                            output: b
                        });
                        continue;
                    }
                    if (G === ".") {
                        if (m.braces > 0 && B.type === "dot") {
                            if (B.value === ".") B.output = h;
                            const t = N[N.length - 1];
                            B.type = "dots";
                            B.output += G;
                            B.value += G;
                            t.dots = true;
                            continue;
                        }
                        if (m.braces + m.parens === 0 && B.type !== "bos" && B.type !== "slash") {
                            push({
                                type: "text",
                                value: G,
                                output: h
                            });
                            continue;
                        }
                        push({
                            type: "dot",
                            value: G,
                            output: h
                        });
                        continue;
                    }
                    if (G === "?") {
                        const t = B && B.value === "(";
                        if (!t && u.noextglob !== true && D() === "(" && D(2) !== "?") {
                            extglobOpen("qmark", G);
                            continue;
                        }
                        if (B && B.type === "paren") {
                            const t = D();
                            let e = G;
                            if (B.value === "(" && !/[!=<:]/.test(t) || t === "<" && !/<([!=]|\w+>)/.test(remaining())) {
                                e = `\\${G}`;
                            }
                            push({
                                type: "text",
                                value: G,
                                output: e
                            });
                            continue;
                        }
                        if (u.dot !== true && (B.type === "slash" || B.type === "bos")) {
                            push({
                                type: "qmark",
                                value: G,
                                output: v
                            });
                            continue;
                        }
                        push({
                            type: "qmark",
                            value: G,
                            output: H
                        });
                        continue;
                    }
                    if (G === "!") {
                        if (u.noextglob !== true && D() === "(") {
                            if (D(2) !== "?" || !/[!=<:]/.test(D(3))) {
                                extglobOpen("negate", G);
                                continue;
                            }
                        }
                        if (u.nonegate !== true && m.index === 0) {
                            negate();
                            continue;
                        }
                    }
                    if (G === "+") {
                        if (u.noextglob !== true && D() === "(" && D(2) !== "?") {
                            extglobOpen("plus", G);
                            continue;
                        }
                        if (B && B.value === "(" || u.regex === false) {
                            push({
                                type: "plus",
                                value: G,
                                output: g
                            });
                            continue;
                        }
                        if (B && (B.type === "bracket" || B.type === "paren" || B.type === "brace") || m.parens > 0) {
                            push({
                                type: "plus",
                                value: G
                            });
                            continue;
                        }
                        push({
                            type: "plus",
                            value: g
                        });
                        continue;
                    }
                    if (G === "@") {
                        if (u.noextglob !== true && D() === "(" && D(2) !== "?") {
                            push({
                                type: "at",
                                extglob: true,
                                value: G,
                                output: ""
                            });
                            continue;
                        }
                        push({
                            type: "text",
                            value: G
                        });
                        continue;
                    }
                    if (G !== "*") {
                        if (G === "$" || G === "^") {
                            G = `\\${G}`;
                        }
                        const t = a.exec(remaining());
                        if (t) {
                            G += t[0];
                            m.index += t[0].length;
                        }
                        push({
                            type: "text",
                            value: G
                        });
                        continue;
                    }
                    if (B && (B.type === "globstar" || B.star === true)) {
                        B.type = "star";
                        B.star = true;
                        B.value += G;
                        B.output = k;
                        m.backtrack = true;
                        m.globstar = true;
                        consume(G);
                        continue;
                    }
                    let e = remaining();
                    if (u.noextglob !== true && /^\([^?]/.test(e)) {
                        extglobOpen("star", G);
                        continue;
                    }
                    if (B.type === "star") {
                        if (u.noglobstar === true) {
                            consume(G);
                            continue;
                        }
                        const n = B.prev;
                        const o = n.prev;
                        const s = n.type === "slash" || n.type === "bos";
                        const r = o && (o.type === "star" || o.type === "globstar");
                        if (u.bash === true && (!s || e[0] && e[0] !== "/")) {
                            push({
                                type: "star",
                                value: G,
                                output: ""
                            });
                            continue;
                        }
                        const a = m.braces > 0 && (n.type === "comma" || n.type === "brace");
                        const i = w.length && (n.type === "pipe" || n.type === "paren");
                        if (!s && n.type !== "paren" && !a && !i) {
                            push({
                                type: "star",
                                value: G,
                                output: ""
                            });
                            continue;
                        }
                        while(e.slice(0, 3) === "/**"){
                            const u = t[m.index + 4];
                            if (u && u !== "/") {
                                break;
                            }
                            e = e.slice(3);
                            consume("/**", 3);
                        }
                        if (n.type === "bos" && eos()) {
                            B.type = "globstar";
                            B.value += G;
                            B.output = globstar(u);
                            m.output = B.output;
                            m.globstar = true;
                            consume(G);
                            continue;
                        }
                        if (n.type === "slash" && n.prev.type !== "bos" && !r && eos()) {
                            m.output = m.output.slice(0, -(n.output + B.output).length);
                            n.output = `(?:${n.output}`;
                            B.type = "globstar";
                            B.output = globstar(u) + (u.strictSlashes ? ")" : "|$)");
                            B.value += G;
                            m.globstar = true;
                            m.output += n.output + B.output;
                            consume(G);
                            continue;
                        }
                        if (n.type === "slash" && n.prev.type !== "bos" && e[0] === "/") {
                            const t = e[1] !== void 0 ? "|$" : "";
                            m.output = m.output.slice(0, -(n.output + B.output).length);
                            n.output = `(?:${n.output}`;
                            B.type = "globstar";
                            B.output = `${globstar(u)}${b}|${b}${t})`;
                            B.value += G;
                            m.output += n.output + B.output;
                            m.globstar = true;
                            consume(G + M());
                            push({
                                type: "slash",
                                value: "/",
                                output: ""
                            });
                            continue;
                        }
                        if (n.type === "bos" && e[0] === "/") {
                            B.type = "globstar";
                            B.value += G;
                            B.output = `(?:^|${b}|${globstar(u)}${b})`;
                            m.output = B.output;
                            m.globstar = true;
                            consume(G + M());
                            push({
                                type: "slash",
                                value: "/",
                                output: ""
                            });
                            continue;
                        }
                        m.output = m.output.slice(0, -B.output.length);
                        B.type = "globstar";
                        B.output = globstar(u);
                        B.value += G;
                        m.output += B.output;
                        m.globstar = true;
                        consume(G);
                        continue;
                    }
                    const n = {
                        type: "star",
                        value: G,
                        output: k
                    };
                    if (u.bash === true) {
                        n.output = ".*?";
                        if (B.type === "bos" || B.type === "slash") {
                            n.output = T + n.output;
                        }
                        push(n);
                        continue;
                    }
                    if (B && (B.type === "bracket" || B.type === "paren") && u.regex === true) {
                        n.output = G;
                        push(n);
                        continue;
                    }
                    if (m.index === m.start || B.type === "slash" || B.type === "dot") {
                        if (B.type === "dot") {
                            m.output += x;
                            B.output += x;
                        } else if (u.dot === true) {
                            m.output += S;
                            B.output += S;
                        } else {
                            m.output += T;
                            B.output += T;
                        }
                        if (D() !== "*") {
                            m.output += C;
                            B.output += C;
                        }
                    }
                    push(n);
                }
                while(m.brackets > 0){
                    if (u.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
                    m.output = o.escapeLast(m.output, "[");
                    decrement("brackets");
                }
                while(m.parens > 0){
                    if (u.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")"));
                    m.output = o.escapeLast(m.output, "(");
                    decrement("parens");
                }
                while(m.braces > 0){
                    if (u.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}"));
                    m.output = o.escapeLast(m.output, "{");
                    decrement("braces");
                }
                if (u.strictSlashes !== true && (B.type === "star" || B.type === "bracket")) {
                    push({
                        type: "maybe_slash",
                        value: "",
                        output: `${b}?`
                    });
                }
                if (m.backtrack === true) {
                    m.output = "";
                    for (const t of m.tokens){
                        m.output += t.output != null ? t.output : t.value;
                        if (t.suffix) {
                            m.output += t.suffix;
                        }
                    }
                }
                return m;
            };
            parse.fastpaths = (t, e)=>{
                const u = {
                    ...e
                };
                const r = typeof u.maxLength === "number" ? Math.min(s, u.maxLength) : s;
                const a = t.length;
                if (a > r) {
                    throw new SyntaxError(`Input length: ${a}, exceeds maximum allowed length: ${r}`);
                }
                t = c[t] || t;
                const { DOT_LITERAL: i, SLASH_LITERAL: p, ONE_CHAR: l, DOTS_SLASH: f, NO_DOT: A, NO_DOTS: _, NO_DOTS_SLASH: R, STAR: E, START_ANCHOR: h } = n.globChars(u.windows);
                const g = u.dot ? _ : A;
                const b = u.dot ? R : A;
                const C = u.capture ? "" : "?:";
                const y = {
                    negated: false,
                    prefix: ""
                };
                let $ = u.bash === true ? ".*?" : E;
                if (u.capture) {
                    $ = `(${$})`;
                }
                const globstar = (t)=>{
                    if (t.noglobstar === true) return $;
                    return `(${C}(?:(?!${h}${t.dot ? f : i}).)*?)`;
                };
                const create = (t)=>{
                    switch(t){
                        case "*":
                            return `${g}${l}${$}`;
                        case ".*":
                            return `${i}${l}${$}`;
                        case "*.*":
                            return `${g}${$}${i}${l}${$}`;
                        case "*/*":
                            return `${g}${$}${p}${l}${b}${$}`;
                        case "**":
                            return g + globstar(u);
                        case "**/*":
                            return `(?:${g}${globstar(u)}${p})?${b}${l}${$}`;
                        case "**/*.*":
                            return `(?:${g}${globstar(u)}${p})?${b}${$}${i}${l}${$}`;
                        case "**/.*":
                            return `(?:${g}${globstar(u)}${p})?${i}${l}${$}`;
                        default:
                            {
                                const e = /^(.*?)\.(\w+)$/.exec(t);
                                if (!e) return;
                                const u = create(e[1]);
                                if (!u) return;
                                return u + i + e[2];
                            }
                    }
                };
                const x = o.removePrefix(t, y);
                let S = create(x);
                if (S && u.strictSlashes !== true) {
                    S += `${p}?`;
                }
                return S;
            };
            t.exports = parse;
        },
        510: (t, e, u)=>{
            const n = u(716);
            const o = u(697);
            const s = u(96);
            const r = u(154);
            const isObject = (t)=>t && typeof t === "object" && !Array.isArray(t);
            const picomatch = (t, e, u = false)=>{
                if (Array.isArray(t)) {
                    const n = t.map((t)=>picomatch(t, e, u));
                    const arrayMatcher = (t)=>{
                        for (const e of n){
                            const u = e(t);
                            if (u) return u;
                        }
                        return false;
                    };
                    return arrayMatcher;
                }
                const n = isObject(t) && t.tokens && t.input;
                if (t === "" || typeof t !== "string" && !n) {
                    throw new TypeError("Expected pattern to be a non-empty string");
                }
                const o = e || {};
                const s = o.windows;
                const r = n ? picomatch.compileRe(t, e) : picomatch.makeRe(t, e, false, true);
                const a = r.state;
                delete r.state;
                let isIgnored = ()=>false;
                if (o.ignore) {
                    const t = {
                        ...e,
                        ignore: null,
                        onMatch: null,
                        onResult: null
                    };
                    isIgnored = picomatch(o.ignore, t, u);
                }
                const matcher = (u, n = false)=>{
                    const { isMatch: i, match: c, output: p } = picomatch.test(u, r, e, {
                        glob: t,
                        posix: s
                    });
                    const l = {
                        glob: t,
                        state: a,
                        regex: r,
                        posix: s,
                        input: u,
                        output: p,
                        match: c,
                        isMatch: i
                    };
                    if (typeof o.onResult === "function") {
                        o.onResult(l);
                    }
                    if (i === false) {
                        l.isMatch = false;
                        return n ? l : false;
                    }
                    if (isIgnored(u)) {
                        if (typeof o.onIgnore === "function") {
                            o.onIgnore(l);
                        }
                        l.isMatch = false;
                        return n ? l : false;
                    }
                    if (typeof o.onMatch === "function") {
                        o.onMatch(l);
                    }
                    return n ? l : true;
                };
                if (u) {
                    matcher.state = a;
                }
                return matcher;
            };
            picomatch.test = (t, e, u, { glob: n, posix: o } = {})=>{
                if (typeof t !== "string") {
                    throw new TypeError("Expected input to be a string");
                }
                if (t === "") {
                    return {
                        isMatch: false,
                        output: ""
                    };
                }
                const r = u || {};
                const a = r.format || (o ? s.toPosixSlashes : null);
                let i = t === n;
                let c = i && a ? a(t) : t;
                if (i === false) {
                    c = a ? a(t) : t;
                    i = c === n;
                }
                if (i === false || r.capture === true) {
                    if (r.matchBase === true || r.basename === true) {
                        i = picomatch.matchBase(t, e, u, o);
                    } else {
                        i = e.exec(c);
                    }
                }
                return {
                    isMatch: Boolean(i),
                    match: i,
                    output: c
                };
            };
            picomatch.matchBase = (t, e, u)=>{
                const n = e instanceof RegExp ? e : picomatch.makeRe(e, u);
                return n.test(s.basename(t));
            };
            picomatch.isMatch = (t, e, u)=>picomatch(e, u)(t);
            picomatch.parse = (t, e)=>{
                if (Array.isArray(t)) return t.map((t)=>picomatch.parse(t, e));
                return o(t, {
                    ...e,
                    fastpaths: false
                });
            };
            picomatch.scan = (t, e)=>n(t, e);
            picomatch.compileRe = (t, e, u = false, n = false)=>{
                if (u === true) {
                    return t.output;
                }
                const o = e || {};
                const s = o.contains ? "" : "^";
                const r = o.contains ? "" : "$";
                let a = `${s}(?:${t.output})${r}`;
                if (t && t.negated === true) {
                    a = `^(?!${a}).*$`;
                }
                const i = picomatch.toRegex(a, e);
                if (n === true) {
                    i.state = t;
                }
                return i;
            };
            picomatch.makeRe = (t, e = {}, u = false, n = false)=>{
                if (!t || typeof t !== "string") {
                    throw new TypeError("Expected a non-empty string");
                }
                let s = {
                    negated: false,
                    fastpaths: true
                };
                if (e.fastpaths !== false && (t[0] === "." || t[0] === "*")) {
                    s.output = o.fastpaths(t, e);
                }
                if (!s.output) {
                    s = o(t, e);
                }
                return picomatch.compileRe(s, e, u, n);
            };
            picomatch.toRegex = (t, e)=>{
                try {
                    const u = e || {};
                    return new RegExp(t, u.flags || (u.nocase ? "i" : ""));
                } catch (t) {
                    if (e && e.debug === true) throw t;
                    return /$^/;
                }
            };
            picomatch.constants = r;
            t.exports = picomatch;
        },
        716: (t, e, u)=>{
            const n = u(96);
            const { CHAR_ASTERISK: o, CHAR_AT: s, CHAR_BACKWARD_SLASH: r, CHAR_COMMA: a, CHAR_DOT: i, CHAR_EXCLAMATION_MARK: c, CHAR_FORWARD_SLASH: p, CHAR_LEFT_CURLY_BRACE: l, CHAR_LEFT_PARENTHESES: f, CHAR_LEFT_SQUARE_BRACKET: A, CHAR_PLUS: _, CHAR_QUESTION_MARK: R, CHAR_RIGHT_CURLY_BRACE: E, CHAR_RIGHT_PARENTHESES: h, CHAR_RIGHT_SQUARE_BRACKET: g } = u(154);
            const isPathSeparator = (t)=>t === p || t === r;
            const depth = (t)=>{
                if (t.isPrefix !== true) {
                    t.depth = t.isGlobstar ? Infinity : 1;
                }
            };
            const scan = (t, e)=>{
                const u = e || {};
                const b = t.length - 1;
                const C = u.parts === true || u.scanToEnd === true;
                const y = [];
                const $ = [];
                const x = [];
                let S = t;
                let H = -1;
                let v = 0;
                let d = 0;
                let L = false;
                let T = false;
                let O = false;
                let k = false;
                let m = false;
                let w = false;
                let N = false;
                let I = false;
                let B = false;
                let G = false;
                let D = 0;
                let M;
                let P;
                let K = {
                    value: "",
                    depth: 0,
                    isGlob: false
                };
                const eos = ()=>H >= b;
                const peek = ()=>S.charCodeAt(H + 1);
                const advance = ()=>{
                    M = P;
                    return S.charCodeAt(++H);
                };
                while(H < b){
                    P = advance();
                    let t;
                    if (P === r) {
                        N = K.backslashes = true;
                        P = advance();
                        if (P === l) {
                            w = true;
                        }
                        continue;
                    }
                    if (w === true || P === l) {
                        D++;
                        while(eos() !== true && (P = advance())){
                            if (P === r) {
                                N = K.backslashes = true;
                                advance();
                                continue;
                            }
                            if (P === l) {
                                D++;
                                continue;
                            }
                            if (w !== true && P === i && (P = advance()) === i) {
                                L = K.isBrace = true;
                                O = K.isGlob = true;
                                G = true;
                                if (C === true) {
                                    continue;
                                }
                                break;
                            }
                            if (w !== true && P === a) {
                                L = K.isBrace = true;
                                O = K.isGlob = true;
                                G = true;
                                if (C === true) {
                                    continue;
                                }
                                break;
                            }
                            if (P === E) {
                                D--;
                                if (D === 0) {
                                    w = false;
                                    L = K.isBrace = true;
                                    G = true;
                                    break;
                                }
                            }
                        }
                        if (C === true) {
                            continue;
                        }
                        break;
                    }
                    if (P === p) {
                        y.push(H);
                        $.push(K);
                        K = {
                            value: "",
                            depth: 0,
                            isGlob: false
                        };
                        if (G === true) continue;
                        if (M === i && H === v + 1) {
                            v += 2;
                            continue;
                        }
                        d = H + 1;
                        continue;
                    }
                    if (u.noext !== true) {
                        const t = P === _ || P === s || P === o || P === R || P === c;
                        if (t === true && peek() === f) {
                            O = K.isGlob = true;
                            k = K.isExtglob = true;
                            G = true;
                            if (P === c && H === v) {
                                B = true;
                            }
                            if (C === true) {
                                while(eos() !== true && (P = advance())){
                                    if (P === r) {
                                        N = K.backslashes = true;
                                        P = advance();
                                        continue;
                                    }
                                    if (P === h) {
                                        O = K.isGlob = true;
                                        G = true;
                                        break;
                                    }
                                }
                                continue;
                            }
                            break;
                        }
                    }
                    if (P === o) {
                        if (M === o) m = K.isGlobstar = true;
                        O = K.isGlob = true;
                        G = true;
                        if (C === true) {
                            continue;
                        }
                        break;
                    }
                    if (P === R) {
                        O = K.isGlob = true;
                        G = true;
                        if (C === true) {
                            continue;
                        }
                        break;
                    }
                    if (P === A) {
                        while(eos() !== true && (t = advance())){
                            if (t === r) {
                                N = K.backslashes = true;
                                advance();
                                continue;
                            }
                            if (t === g) {
                                T = K.isBracket = true;
                                O = K.isGlob = true;
                                G = true;
                                break;
                            }
                        }
                        if (C === true) {
                            continue;
                        }
                        break;
                    }
                    if (u.nonegate !== true && P === c && H === v) {
                        I = K.negated = true;
                        v++;
                        continue;
                    }
                    if (u.noparen !== true && P === f) {
                        O = K.isGlob = true;
                        if (C === true) {
                            while(eos() !== true && (P = advance())){
                                if (P === f) {
                                    N = K.backslashes = true;
                                    P = advance();
                                    continue;
                                }
                                if (P === h) {
                                    G = true;
                                    break;
                                }
                            }
                            continue;
                        }
                        break;
                    }
                    if (O === true) {
                        G = true;
                        if (C === true) {
                            continue;
                        }
                        break;
                    }
                }
                if (u.noext === true) {
                    k = false;
                    O = false;
                }
                let U = S;
                let X = "";
                let F = "";
                if (v > 0) {
                    X = S.slice(0, v);
                    S = S.slice(v);
                    d -= v;
                }
                if (U && O === true && d > 0) {
                    U = S.slice(0, d);
                    F = S.slice(d);
                } else if (O === true) {
                    U = "";
                    F = S;
                } else {
                    U = S;
                }
                if (U && U !== "" && U !== "/" && U !== S) {
                    if (isPathSeparator(U.charCodeAt(U.length - 1))) {
                        U = U.slice(0, -1);
                    }
                }
                if (u.unescape === true) {
                    if (F) F = n.removeBackslashes(F);
                    if (U && N === true) {
                        U = n.removeBackslashes(U);
                    }
                }
                const Q = {
                    prefix: X,
                    input: t,
                    start: v,
                    base: U,
                    glob: F,
                    isBrace: L,
                    isBracket: T,
                    isGlob: O,
                    isExtglob: k,
                    isGlobstar: m,
                    negated: I,
                    negatedExtglob: B
                };
                if (u.tokens === true) {
                    Q.maxDepth = 0;
                    if (!isPathSeparator(P)) {
                        $.push(K);
                    }
                    Q.tokens = $;
                }
                if (u.parts === true || u.tokens === true) {
                    let e;
                    for(let n = 0; n < y.length; n++){
                        const o = e ? e + 1 : v;
                        const s = y[n];
                        const r = t.slice(o, s);
                        if (u.tokens) {
                            if (n === 0 && v !== 0) {
                                $[n].isPrefix = true;
                                $[n].value = X;
                            } else {
                                $[n].value = r;
                            }
                            depth($[n]);
                            Q.maxDepth += $[n].depth;
                        }
                        if (n !== 0 || r !== "") {
                            x.push(r);
                        }
                        e = s;
                    }
                    if (e && e + 1 < t.length) {
                        const n = t.slice(e + 1);
                        x.push(n);
                        if (u.tokens) {
                            $[$.length - 1].value = n;
                            depth($[$.length - 1]);
                            Q.maxDepth += $[$.length - 1].depth;
                        }
                    }
                    Q.slashes = y;
                    Q.parts = x;
                }
                return Q;
            };
            t.exports = scan;
        },
        96: (t, e, u)=>{
            const { REGEX_BACKSLASH: n, REGEX_REMOVE_BACKSLASH: o, REGEX_SPECIAL_CHARS: s, REGEX_SPECIAL_CHARS_GLOBAL: r } = u(154);
            e.isObject = (t)=>t !== null && typeof t === "object" && !Array.isArray(t);
            e.hasRegexChars = (t)=>s.test(t);
            e.isRegexChar = (t)=>t.length === 1 && e.hasRegexChars(t);
            e.escapeRegex = (t)=>t.replace(r, "\\$1");
            e.toPosixSlashes = (t)=>t.replace(n, "/");
            e.removeBackslashes = (t)=>t.replace(o, (t)=>t === "\\" ? "" : t);
            e.escapeLast = (t, u, n)=>{
                const o = t.lastIndexOf(u, n);
                if (o === -1) return t;
                if (t[o - 1] === "\\") return e.escapeLast(t, u, o - 1);
                return `${t.slice(0, o)}\\${t.slice(o)}`;
            };
            e.removePrefix = (t, e = {})=>{
                let u = t;
                if (u.startsWith("./")) {
                    u = u.slice(2);
                    e.prefix = "./";
                }
                return u;
            };
            e.wrapOutput = (t, e = {}, u = {})=>{
                const n = u.contains ? "" : "^";
                const o = u.contains ? "" : "$";
                let s = `${n}(?:${t})${o}`;
                if (e.negated === true) {
                    s = `(?:^(?!${s}).*$)`;
                }
                return s;
            };
            e.basename = (t, { windows: e } = {})=>{
                const u = t.split(e ? /[\\/]/ : "/");
                const n = u[u.length - 1];
                if (n === "") {
                    return u[u.length - 2];
                }
                return n;
            };
        }
    };
    var e = {};
    function __nccwpck_require__(u) {
        var n = e[u];
        if (n !== undefined) {
            return n.exports;
        }
        var o = e[u] = {
            exports: {}
        };
        var s = true;
        try {
            t[u](o, o.exports, __nccwpck_require__);
            s = false;
        } finally{
            if (s) delete e[u];
        }
        return o.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = __dirname + "/";
    var u = __nccwpck_require__(170);
    module.exports = u;
})();
}}),
"[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/match-local-pattern.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    hasLocalMatch: null,
    matchLocalPattern: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    hasLocalMatch: function() {
        return hasLocalMatch;
    },
    matchLocalPattern: function() {
        return matchLocalPattern;
    }
});
const _picomatch = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/compiled/picomatch/index.js [app-client] (ecmascript)");
function matchLocalPattern(pattern, url) {
    if (pattern.search !== undefined) {
        if (pattern.search !== url.search) {
            return false;
        }
    }
    var _pattern_pathname;
    if (!(0, _picomatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : '**', {
        dot: true
    }).test(url.pathname)) {
        return false;
    }
    return true;
}
function hasLocalMatch(localPatterns, urlPathAndQuery) {
    if (!localPatterns) {
        // if the user didn't define "localPatterns", we allow all local images
        return true;
    }
    const url = new URL(urlPathAndQuery, 'http://n');
    return localPatterns.some((p)=>matchLocalPattern(p, url));
} //# sourceMappingURL=match-local-pattern.js.map
}}),
"[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/match-remote-pattern.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    hasRemoteMatch: null,
    matchRemotePattern: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    hasRemoteMatch: function() {
        return hasRemoteMatch;
    },
    matchRemotePattern: function() {
        return matchRemotePattern;
    }
});
const _picomatch = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/compiled/picomatch/index.js [app-client] (ecmascript)");
function matchRemotePattern(pattern, url) {
    if (pattern.protocol !== undefined) {
        const actualProto = url.protocol.slice(0, -1);
        if (pattern.protocol !== actualProto) {
            return false;
        }
    }
    if (pattern.port !== undefined) {
        if (pattern.port !== url.port) {
            return false;
        }
    }
    if (pattern.hostname === undefined) {
        throw new Error("Pattern should define hostname but found\n" + JSON.stringify(pattern));
    } else {
        if (!(0, _picomatch.makeRe)(pattern.hostname).test(url.hostname)) {
            return false;
        }
    }
    if (pattern.search !== undefined) {
        if (pattern.search !== url.search) {
            return false;
        }
    }
    var _pattern_pathname;
    // Should be the same as writeImagesManifest()
    if (!(0, _picomatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : '**', {
        dot: true
    }).test(url.pathname)) {
        return false;
    }
    return true;
}
function hasRemoteMatch(domains, remotePatterns, url) {
    return domains.some((domain)=>url.hostname === domain) || remotePatterns.some((p)=>matchRemotePattern(p, url));
} //# sourceMappingURL=match-remote-pattern.js.map
}}),
"[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/image-loader.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const DEFAULT_Q = 75;
function defaultLoader(param) {
    let { config, src, width, quality } = param;
    var _config_qualities;
    if ("TURBOPACK compile-time truthy", 1) {
        const missingValues = [];
        // these should always be provided but make sure they are
        if (!src) missingValues.push('src');
        if (!width) missingValues.push('width');
        if (missingValues.length > 0) {
            throw new Error("Next Image Optimization requires " + missingValues.join(', ') + " to be provided. Make sure you pass them as props to the `next/image` component. Received: " + JSON.stringify({
                src,
                width,
                quality
            }));
        }
        if (src.startsWith('//')) {
            throw new Error('Failed to parse src "' + src + '" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)');
        }
        if (src.startsWith('/') && config.localPatterns) {
            if ("TURBOPACK compile-time truthy", 1) {
                // We use dynamic require because this should only error in development
                const { hasLocalMatch } = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/match-local-pattern.js [app-client] (ecmascript)");
                if (!hasLocalMatch(config.localPatterns, src)) {
                    throw new Error("Invalid src prop (" + src + ") on `next/image` does not match `images.localPatterns` configured in your `next.config.js`\n" + "See more info: https://nextjs.org/docs/messages/next-image-unconfigured-localpatterns");
                }
            }
        }
        if (!src.startsWith('/') && (config.domains || config.remotePatterns)) {
            let parsedSrc;
            try {
                parsedSrc = new URL(src);
            } catch (err) {
                console.error(err);
                throw new Error('Failed to parse src "' + src + '" on `next/image`, if using relative image it must start with a leading slash "/" or be an absolute URL (http:// or https://)');
            }
            if ("TURBOPACK compile-time truthy", 1) {
                // We use dynamic require because this should only error in development
                const { hasRemoteMatch } = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/match-remote-pattern.js [app-client] (ecmascript)");
                if (!hasRemoteMatch(config.domains, config.remotePatterns, parsedSrc)) {
                    throw new Error("Invalid src prop (" + src + ') on `next/image`, hostname "' + parsedSrc.hostname + '" is not configured under images in your `next.config.js`\n' + "See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host");
                }
            }
        }
        if (quality && config.qualities && !config.qualities.includes(quality)) {
            throw new Error("Invalid quality prop (" + quality + ") on `next/image` does not match `images.qualities` configured in your `next.config.js`\n" + "See more info: https://nextjs.org/docs/messages/next-image-unconfigured-qualities");
        }
    }
    const q = quality || ((_config_qualities = config.qualities) == null ? void 0 : _config_qualities.reduce((prev, cur)=>Math.abs(cur - DEFAULT_Q) < Math.abs(prev - DEFAULT_Q) ? cur : prev)) || DEFAULT_Q;
    return config.path + "?url=" + encodeURIComponent(src) + "&w=" + width + "&q=" + q + (src.startsWith('/_next/static/media/') && ("TURBOPACK compile-time value", false) ? ("TURBOPACK unreachable", undefined) : '');
}
// We use this to determine if the import is the default loader
// or a custom loader defined by the user in next.config.js
defaultLoader.__next_img_default = true;
const _default = defaultLoader; //# sourceMappingURL=image-loader.js.map
}}),
"[project]/Documents/instant-demo/node_modules/next/dist/client/use-merged-ref.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useMergedRef", {
    enumerable: true,
    get: function() {
        return useMergedRef;
    }
});
const _react = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
function useMergedRef(refA, refB) {
    const cleanupA = (0, _react.useRef)(()=>{});
    const cleanupB = (0, _react.useRef)(()=>{});
    return (0, _react.useMemo)(()=>{
        if (!refA || !refB) {
            return refA || refB;
        }
        return (current)=>{
            if (current === null) {
                cleanupA.current();
                cleanupB.current();
            } else {
                cleanupA.current = applyRef(refA, current);
                cleanupB.current = applyRef(refB, current);
            }
        };
    }, [
        refA,
        refB
    ]);
}
function applyRef(refA, current) {
    if (typeof refA === 'function') {
        const cleanup = refA(current);
        if (typeof cleanup === 'function') {
            return cleanup;
        } else {
            return ()=>refA(null);
        }
    } else {
        refA.current = current;
        return ()=>{
            refA.current = null;
        };
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-merged-ref.js.map
}}),
"[project]/Documents/instant-demo/node_modules/next/dist/client/image-component.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "Image", {
    enumerable: true,
    get: function() {
        return Image;
    }
});
const _interop_require_default = __turbopack_require__("[project]/Documents/instant-demo/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _interop_require_wildcard = __turbopack_require__("[project]/Documents/instant-demo/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)");
const _jsxruntime = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const _reactdom = /*#__PURE__*/ _interop_require_default._(__turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)"));
const _head = /*#__PURE__*/ _interop_require_default._(__turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/head.js [app-client] (ecmascript)"));
const _getimgprops = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/get-img-props.js [app-client] (ecmascript)");
const _imageconfig = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/image-config.js [app-client] (ecmascript)");
const _imageconfigcontextsharedruntime = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js [app-client] (ecmascript)");
const _warnonce = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/utils/warn-once.js [app-client] (ecmascript)");
const _routercontextsharedruntime = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/router-context.shared-runtime.js [app-client] (ecmascript)");
const _imageloader = /*#__PURE__*/ _interop_require_default._(__turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/image-loader.js [app-client] (ecmascript)"));
const _usemergedref = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/client/use-merged-ref.js [app-client] (ecmascript)");
// This is replaced by webpack define plugin
const configEnv = ("TURBOPACK compile-time value", JSON.parse('{"deviceSizes":[640,750,828,1080,1200,1920,2048,3840],"imageSizes":[16,32,48,64,96,128,256,384],"path":"/_next/image","loader":"default","dangerouslyAllowSVG":false,"unoptimized":false,"domains":[],"remotePatterns":[]}'));
if (typeof window === 'undefined') {
    ;
    globalThis.__NEXT_IMAGE_IMPORTED = true;
}
// See https://stackoverflow.com/q/39777833/266535 for why we use this ref
// handler instead of the img's onLoad attribute.
function handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput) {
    const src = img == null ? void 0 : img.src;
    if (!img || img['data-loaded-src'] === src) {
        return;
    }
    img['data-loaded-src'] = src;
    const p = 'decode' in img ? img.decode() : Promise.resolve();
    p.catch(()=>{}).then(()=>{
        if (!img.parentElement || !img.isConnected) {
            // Exit early in case of race condition:
            // - onload() is called
            // - decode() is called but incomplete
            // - unmount is called
            // - decode() completes
            return;
        }
        if (placeholder !== 'empty') {
            setBlurComplete(true);
        }
        if (onLoadRef == null ? void 0 : onLoadRef.current) {
            // Since we don't have the SyntheticEvent here,
            // we must create one with the same shape.
            // See https://reactjs.org/docs/events.html
            const event = new Event('load');
            Object.defineProperty(event, 'target', {
                writable: false,
                value: img
            });
            let prevented = false;
            let stopped = false;
            onLoadRef.current({
                ...event,
                nativeEvent: event,
                currentTarget: img,
                target: img,
                isDefaultPrevented: ()=>prevented,
                isPropagationStopped: ()=>stopped,
                persist: ()=>{},
                preventDefault: ()=>{
                    prevented = true;
                    event.preventDefault();
                },
                stopPropagation: ()=>{
                    stopped = true;
                    event.stopPropagation();
                }
            });
        }
        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {
            onLoadingCompleteRef.current(img);
        }
        if ("TURBOPACK compile-time truthy", 1) {
            const origSrc = new URL(src, 'http://n').searchParams.get('url') || src;
            if (img.getAttribute('data-nimg') === 'fill') {
                if (!unoptimized && (!sizesInput || sizesInput === '100vw')) {
                    let widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;
                    if (widthViewportRatio < 0.6) {
                        if (sizesInput === '100vw') {
                            (0, _warnonce.warnOnce)('Image with src "' + origSrc + '" has "fill" prop and "sizes" prop of "100vw", but image is not rendered at full viewport width. Please adjust "sizes" to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');
                        } else {
                            (0, _warnonce.warnOnce)('Image with src "' + origSrc + '" has "fill" but is missing "sizes" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');
                        }
                    }
                }
                if (img.parentElement) {
                    const { position } = window.getComputedStyle(img.parentElement);
                    const valid = [
                        'absolute',
                        'fixed',
                        'relative'
                    ];
                    if (!valid.includes(position)) {
                        (0, _warnonce.warnOnce)('Image with src "' + origSrc + '" has "fill" and parent element with invalid "position". Provided "' + position + '" should be one of ' + valid.map(String).join(',') + ".");
                    }
                }
                if (img.height === 0) {
                    (0, _warnonce.warnOnce)('Image with src "' + origSrc + '" has "fill" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.');
                }
            }
            const heightModified = img.height.toString() !== img.getAttribute('height');
            const widthModified = img.width.toString() !== img.getAttribute('width');
            if (heightModified && !widthModified || !heightModified && widthModified) {
                (0, _warnonce.warnOnce)('Image with src "' + origSrc + '" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles \'width: "auto"\' or \'height: "auto"\' to maintain the aspect ratio.');
            }
        }
    });
}
function getDynamicProps(fetchPriority) {
    if (Boolean(_react.use)) {
        // In React 19.0.0 or newer, we must use camelCase
        // prop to avoid "Warning: Invalid DOM property".
        // See https://github.com/facebook/react/pull/25927
        return {
            fetchPriority
        };
    }
    // In React 18.2.0 or older, we must use lowercase prop
    // to avoid "Warning: Invalid DOM property".
    return {
        fetchpriority: fetchPriority
    };
}
const ImageElement = /*#__PURE__*/ (0, _react.forwardRef)((param, forwardedRef)=>{
    let { src, srcSet, sizes, height, width, decoding, className, style, fetchPriority, placeholder, loading, unoptimized, fill, onLoadRef, onLoadingCompleteRef, setBlurComplete, setShowAltText, sizesInput, onLoad, onError, ...rest } = param;
    const ownRef = (0, _react.useCallback)((img)=>{
        if (!img) {
            return;
        }
        if (onError) {
            // If the image has an error before react hydrates, then the error is lost.
            // The workaround is to wait until the image is mounted which is after hydration,
            // then we set the src again to trigger the error handler (if there was an error).
            // eslint-disable-next-line no-self-assign
            img.src = img.src;
        }
        if ("TURBOPACK compile-time truthy", 1) {
            if (!src) {
                console.error('Image is missing required "src" property:', img);
            }
            if (img.getAttribute('alt') === null) {
                console.error('Image is missing required "alt" property. Please add Alternative Text to describe the image for screen readers and search engines.');
            }
        }
        if (img.complete) {
            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);
        }
    }, [
        src,
        placeholder,
        onLoadRef,
        onLoadingCompleteRef,
        setBlurComplete,
        onError,
        unoptimized,
        sizesInput
    ]);
    const ref = (0, _usemergedref.useMergedRef)(forwardedRef, ownRef);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)("img", {
        ...rest,
        ...getDynamicProps(fetchPriority),
        // It's intended to keep `loading` before `src` because React updates
        // props in order which causes Safari/Firefox to not lazy load properly.
        // See https://github.com/facebook/react/issues/25883
        loading: loading,
        width: width,
        height: height,
        decoding: decoding,
        "data-nimg": fill ? 'fill' : '1',
        className: className,
        style: style,
        // It's intended to keep `src` the last attribute because React updates
        // attributes in order. If we keep `src` the first one, Safari will
        // immediately start to fetch `src`, before `sizes` and `srcSet` are even
        // updated by React. That causes multiple unnecessary requests if `srcSet`
        // and `sizes` are defined.
        // This bug cannot be reproduced in Chrome or Firefox.
        sizes: sizes,
        srcSet: srcSet,
        src: src,
        ref: ref,
        onLoad: (event)=>{
            const img = event.currentTarget;
            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);
        },
        onError: (event)=>{
            // if the real image fails to load, this will ensure "alt" is visible
            setShowAltText(true);
            if (placeholder !== 'empty') {
                // If the real image fails to load, this will still remove the placeholder.
                setBlurComplete(true);
            }
            if (onError) {
                onError(event);
            }
        }
    });
});
function ImagePreload(param) {
    let { isAppRouter, imgAttributes } = param;
    const opts = {
        as: 'image',
        imageSrcSet: imgAttributes.srcSet,
        imageSizes: imgAttributes.sizes,
        crossOrigin: imgAttributes.crossOrigin,
        referrerPolicy: imgAttributes.referrerPolicy,
        ...getDynamicProps(imgAttributes.fetchPriority)
    };
    if (isAppRouter && _reactdom.default.preload) {
        // See https://github.com/facebook/react/pull/26940
        _reactdom.default.preload(imgAttributes.src, opts);
        return null;
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_head.default, {
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)("link", {
            rel: "preload",
            // Note how we omit the `href` attribute, as it would only be relevant
            // for browsers that do not support `imagesrcset`, and in those cases
            // it would cause the incorrect image to be preloaded.
            //
            // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset
            href: imgAttributes.srcSet ? undefined : imgAttributes.src,
            ...opts
        }, '__nimg-' + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes)
    });
}
const Image = /*#__PURE__*/ (0, _react.forwardRef)((props, forwardedRef)=>{
    const pagesRouter = (0, _react.useContext)(_routercontextsharedruntime.RouterContext);
    // We're in the app directory if there is no pages router.
    const isAppRouter = !pagesRouter;
    const configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);
    const config = (0, _react.useMemo)(()=>{
        var _c_qualities;
        const c = configEnv || configContext || _imageconfig.imageConfigDefault;
        const allSizes = [
            ...c.deviceSizes,
            ...c.imageSizes
        ].sort((a, b)=>a - b);
        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);
        const qualities = (_c_qualities = c.qualities) == null ? void 0 : _c_qualities.sort((a, b)=>a - b);
        return {
            ...c,
            allSizes,
            deviceSizes,
            qualities
        };
    }, [
        configContext
    ]);
    const { onLoad, onLoadingComplete } = props;
    const onLoadRef = (0, _react.useRef)(onLoad);
    (0, _react.useEffect)(()=>{
        onLoadRef.current = onLoad;
    }, [
        onLoad
    ]);
    const onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);
    (0, _react.useEffect)(()=>{
        onLoadingCompleteRef.current = onLoadingComplete;
    }, [
        onLoadingComplete
    ]);
    const [blurComplete, setBlurComplete] = (0, _react.useState)(false);
    const [showAltText, setShowAltText] = (0, _react.useState)(false);
    const { props: imgAttributes, meta: imgMeta } = (0, _getimgprops.getImgProps)(props, {
        defaultLoader: _imageloader.default,
        imgConf: config,
        blurComplete,
        showAltText
    });
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            /*#__PURE__*/ (0, _jsxruntime.jsx)(ImageElement, {
                ...imgAttributes,
                unoptimized: imgMeta.unoptimized,
                placeholder: imgMeta.placeholder,
                fill: imgMeta.fill,
                onLoadRef: onLoadRef,
                onLoadingCompleteRef: onLoadingCompleteRef,
                setBlurComplete: setBlurComplete,
                setShowAltText: setShowAltText,
                sizesInput: props.sizes,
                ref: forwardedRef
            }),
            imgMeta.priority ? /*#__PURE__*/ (0, _jsxruntime.jsx)(ImagePreload, {
                isAppRouter: isAppRouter,
                imgAttributes: imgAttributes
            }) : null
        ]
    });
});
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=image-component.js.map
}}),
"[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/image-external.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    getImageProps: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    getImageProps: function() {
        return getImageProps;
    }
});
const _interop_require_default = __turbopack_require__("[project]/Documents/instant-demo/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _getimgprops = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/get-img-props.js [app-client] (ecmascript)");
const _imagecomponent = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/client/image-component.js [app-client] (ecmascript)");
const _imageloader = /*#__PURE__*/ _interop_require_default._(__turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/image-loader.js [app-client] (ecmascript)"));
function getImageProps(imgProps) {
    const { props } = (0, _getimgprops.getImgProps)(imgProps, {
        defaultLoader: _imageloader.default,
        // This is replaced by webpack define plugin
        imgConf: ("TURBOPACK compile-time value", JSON.parse('{"deviceSizes":[640,750,828,1080,1200,1920,2048,3840],"imageSizes":[16,32,48,64,96,128,256,384],"path":"/_next/image","loader":"default","dangerouslyAllowSVG":false,"unoptimized":false,"domains":[],"remotePatterns":[]}'))
    });
    // Normally we don't care about undefined props because we pass to JSX,
    // but this exported function could be used by the end user for anything
    // so we delete undefined props to clean it up a little.
    for (const [key, value] of Object.entries(props)){
        if (value === undefined) {
            delete props[key];
        }
    }
    return {
        props
    };
}
const _default = _imagecomponent.Image; //# sourceMappingURL=image-external.js.map
}}),
"[project]/Documents/instant-demo/node_modules/next/image.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
module.exports = __turbopack_require__("[project]/Documents/instant-demo/node_modules/next/dist/shared/lib/image-external.js [app-client] (ecmascript)");
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/flags.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "devBackend": (()=>devBackend),
    "devtoolLocalDashboard": (()=>devtoolLocalDashboard),
    "instantLogs": (()=>instantLogs)
});
let devBackend = false;
let instantLogs = false;
let devtoolLocalDashboard = false;
if (typeof window !== 'undefined' && typeof window.localStorage !== 'undefined') {
    devBackend = !!window.localStorage.getItem('devBackend');
    instantLogs = !!window.localStorage.getItem('__instantLogging');
    devtoolLocalDashboard = !!window.localStorage.getItem('__devtoolLocalDash');
}
;
 //# sourceMappingURL=flags.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/log.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$flags$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/flags.js [app-client] (ecmascript)");
;
const isEnabled = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$flags$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.devBackend || __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$flags$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.instantLogs;
const log = {
    info: isEnabled ? console.info.bind(console) : ()=>{},
    debug: isEnabled ? console.debug.bind(console) : ()=>{},
    error: isEnabled ? console.error.bind(console) : ()=>{}
};
const __TURBOPACK__default__export__ = log;
 //# sourceMappingURL=log.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/weakHash.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 *
 * Unique Hashing implementation inspired by djb2/fnv1a algorithms,
 * where we are not concerned with the hash being decoded.
 * Focuses on speed while maintaining good hash distribution
 *
 * Note: We could also use something like Murmurhash instead
 * https://github.com/jensyt/imurmurhash-js/blob/master/imurmurhash.js
 *
 * @param {any} input - Value to hash
 * @returns {string} - Hash in hex format
 */ __turbopack_esm__({
    "default": (()=>weakHash)
});
function weakHash(input) {
    // Handle primitives without JSON stringify for better performance
    if (typeof input === 'number') {
        // Use a larger number space for numeric values
        return (Math.abs(input * 2654435761) >>> 0).toString(16);
    }
    if (typeof input === 'boolean') return input ? '1' : '0';
    if (input === null) return 'null';
    if (input === undefined) return 'undefined';
    // For strings, use FNV-1a algorithm
    if (typeof input === 'string') {
        let hash = 0x811c9dc5; // FNV offset basis (32 bit)
        for(let i = 0; i < input.length; i++){
            hash ^= input.charCodeAt(i);
            hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
            hash = hash >>> 0; // Convert to unsigned 32-bit after each iteration
        }
        return hash.toString(16);
    }
    // For arrays, hash elements directly
    if (Array.isArray(input)) {
        let hash = 0x811c9dc5;
        for(let i = 0; i < input.length; i++){
            // Add array position to hash calculation
            hash ^= (i + 1) * 2654435761;
            // Recursively hash array elements
            const elementHash = weakHash(input[i]);
            // Mix the element hash into the running hash
            for(let j = 0; j < elementHash.length; j++){
                hash ^= elementHash.charCodeAt(j);
                hash *= 16777619; // FNV prime (32 bit)
                hash = hash >>> 0;
            }
        }
        return hash.toString(16);
    }
    // For objects, hash keys and values
    if (typeof input === 'object') {
        let hash = 0x811c9dc5;
        const keys = Object.keys(input).sort(); // Sort for consistency
        for(let i = 0; i < keys.length; i++){
            const key = keys[i];
            // Hash the key using string hash
            const keyHash = weakHash(key);
            hash ^= parseInt(keyHash, 16);
            hash *= 16777619;
            hash = hash >>> 0;
            // Hash the value recursively
            const valueHash = weakHash(input[key]);
            hash ^= parseInt(valueHash, 16);
            hash *= 16777619;
            hash = hash >>> 0;
        }
        return hash.toString(16);
    }
    // Fallback for other types
    return weakHash(String(input));
} //# sourceMappingURL=weakHash.js.map
}}),
"[project]/Documents/instant-demo/node_modules/mutative/dist/mutative.esm.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "apply": (()=>apply),
    "castDraft": (()=>castDraft),
    "castImmutable": (()=>castImmutable),
    "castMutable": (()=>castMutable),
    "create": (()=>create),
    "current": (()=>current),
    "isDraft": (()=>isDraft),
    "isDraftable": (()=>isDraftable),
    "makeCreator": (()=>makeCreator),
    "markSimpleObject": (()=>markSimpleObject),
    "original": (()=>original),
    "rawReturn": (()=>rawReturn),
    "unsafe": (()=>unsafe)
});
const Operation = {
    Remove: 'remove',
    Replace: 'replace',
    Add: 'add'
};
// Don't use `Symbol()` just for 3rd party access the draft
const PROXY_DRAFT = Symbol.for('__MUTATIVE_PROXY_DRAFT__');
const RAW_RETURN_SYMBOL = Symbol('__MUTATIVE_RAW_RETURN_SYMBOL__');
const iteratorSymbol = Symbol.iterator;
const dataTypes = {
    mutable: 'mutable',
    immutable: 'immutable'
};
const internal = {};
function has(target, key) {
    return target instanceof Map ? target.has(key) : Object.prototype.hasOwnProperty.call(target, key);
}
function getDescriptor(target, key) {
    if (key in target) {
        let prototype = Reflect.getPrototypeOf(target);
        while(prototype){
            const descriptor = Reflect.getOwnPropertyDescriptor(prototype, key);
            if (descriptor) return descriptor;
            prototype = Reflect.getPrototypeOf(prototype);
        }
    }
    return;
}
function isBaseSetInstance(obj) {
    return Object.getPrototypeOf(obj) === Set.prototype;
}
function isBaseMapInstance(obj) {
    return Object.getPrototypeOf(obj) === Map.prototype;
}
function latest(proxyDraft) {
    var _a;
    return (_a = proxyDraft.copy) !== null && _a !== void 0 ? _a : proxyDraft.original;
}
/**
 * Check if the value is a draft
 */ function isDraft(target) {
    return !!getProxyDraft(target);
}
function getProxyDraft(value) {
    if (typeof value !== 'object') return null;
    return value === null || value === void 0 ? void 0 : value[PROXY_DRAFT];
}
function getValue(value) {
    var _a;
    const proxyDraft = getProxyDraft(value);
    return proxyDraft ? (_a = proxyDraft.copy) !== null && _a !== void 0 ? _a : proxyDraft.original : value;
}
/**
 * Check if a value is draftable
 */ function isDraftable(value, options) {
    if (!value || typeof value !== 'object') return false;
    let markResult;
    return Object.getPrototypeOf(value) === Object.prototype || Array.isArray(value) || value instanceof Map || value instanceof Set || !!(options === null || options === void 0 ? void 0 : options.mark) && ((markResult = options.mark(value, dataTypes)) === dataTypes.immutable || typeof markResult === 'function');
}
function getPath(target, path = []) {
    if (Object.hasOwnProperty.call(target, 'key')) {
        // check if the parent is a draft and the original value is not equal to the current value
        const parentCopy = target.parent.copy;
        const proxyDraft = getProxyDraft(get(parentCopy, target.key));
        if (proxyDraft !== null && (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== target.original) {
            return null;
        }
        const isSet = target.parent.type === 3 /* DraftType.Set */ ;
        const key = isSet ? Array.from(target.parent.setMap.keys()).indexOf(target.key) : target.key;
        // check if the key is still in the next state parent
        if (!(isSet && parentCopy.size > key || has(parentCopy, key))) return null;
        path.push(key);
    }
    if (target.parent) {
        return getPath(target.parent, path);
    }
    // `target` is root draft.
    path.reverse();
    try {
        // check if the path is valid
        resolvePath(target.copy, path);
    } catch (e) {
        return null;
    }
    return path;
}
function getType(target) {
    if (Array.isArray(target)) return 1 /* DraftType.Array */ ;
    if (target instanceof Map) return 2 /* DraftType.Map */ ;
    if (target instanceof Set) return 3 /* DraftType.Set */ ;
    return 0 /* DraftType.Object */ ;
}
function get(target, key) {
    return getType(target) === 2 /* DraftType.Map */  ? target.get(key) : target[key];
}
function set(target, key, value) {
    const type = getType(target);
    if (type === 2 /* DraftType.Map */ ) {
        target.set(key, value);
    } else {
        target[key] = value;
    }
}
function peek(target, key) {
    const state = getProxyDraft(target);
    const source = state ? latest(state) : target;
    return source[key];
}
function isEqual(x, y) {
    if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
    } else {
        return x !== x && y !== y;
    }
}
function revokeProxy(proxyDraft) {
    if (!proxyDraft) return;
    while(proxyDraft.finalities.revoke.length > 0){
        const revoke = proxyDraft.finalities.revoke.pop();
        revoke();
    }
}
// handle JSON Pointer path with spec https://www.rfc-editor.org/rfc/rfc6901
function escapePath(path, pathAsArray) {
    return pathAsArray ? path : [
        ''
    ].concat(path).map((_item)=>{
        const item = `${_item}`;
        if (item.indexOf('/') === -1 && item.indexOf('~') === -1) return item;
        return item.replace(/~/g, '~0').replace(/\//g, '~1');
    }).join('/');
}
function unescapePath(path) {
    if (Array.isArray(path)) return path;
    return path.split('/').map((_item)=>_item.replace(/~1/g, '/').replace(/~0/g, '~')).slice(1);
}
function resolvePath(base, path) {
    for(let index = 0; index < path.length - 1; index += 1){
        const key = path[index];
        // use `index` in Set draft
        base = get(getType(base) === 3 /* DraftType.Set */  ? Array.from(base) : base, key);
        if (typeof base !== 'object') {
            throw new Error(`Cannot resolve patch at '${path.join('/')}'.`);
        }
    }
    return base;
}
function strictCopy(target) {
    const copy = Object.create(Object.getPrototypeOf(target));
    Reflect.ownKeys(target).forEach((key)=>{
        let desc = Reflect.getOwnPropertyDescriptor(target, key);
        if (desc.enumerable && desc.configurable && desc.writable) {
            copy[key] = target[key];
            return;
        }
        // for freeze
        if (!desc.writable) {
            desc.writable = true;
            desc.configurable = true;
        }
        if (desc.get || desc.set) desc = {
            configurable: true,
            writable: true,
            enumerable: desc.enumerable,
            value: target[key]
        };
        Reflect.defineProperty(copy, key, desc);
    });
    return copy;
}
const propIsEnum = Object.prototype.propertyIsEnumerable;
function shallowCopy(original, options) {
    let markResult;
    if (Array.isArray(original)) {
        return Array.prototype.concat.call(original);
    } else if (original instanceof Set) {
        if (!isBaseSetInstance(original)) {
            const SubClass = Object.getPrototypeOf(original).constructor;
            return new SubClass(original.values());
        }
        return Set.prototype.difference ? Set.prototype.difference.call(original, new Set()) : new Set(original.values());
    } else if (original instanceof Map) {
        if (!isBaseMapInstance(original)) {
            const SubClass = Object.getPrototypeOf(original).constructor;
            return new SubClass(original);
        }
        return new Map(original);
    } else if ((options === null || options === void 0 ? void 0 : options.mark) && (markResult = options.mark(original, dataTypes), markResult !== undefined) && markResult !== dataTypes.mutable) {
        if (markResult === dataTypes.immutable) {
            return strictCopy(original);
        } else if (typeof markResult === 'function') {
            if (options.enablePatches || options.enableAutoFreeze) {
                throw new Error(`You can't use mark and patches or auto freeze together.`);
            }
            return markResult();
        }
        throw new Error(`Unsupported mark result: ${markResult}`);
    } else if (typeof original === 'object' && Object.getPrototypeOf(original) === Object.prototype) {
        // For best performance with shallow copies,
        // don't use `Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));` by default.
        const copy = {};
        Object.keys(original).forEach((key)=>{
            copy[key] = original[key];
        });
        Object.getOwnPropertySymbols(original).forEach((key)=>{
            if (propIsEnum.call(original, key)) {
                copy[key] = original[key];
            }
        });
        return copy;
    } else {
        throw new Error(`Please check mark() to ensure that it is a stable marker draftable function.`);
    }
}
function ensureShallowCopy(target) {
    if (target.copy) return;
    target.copy = shallowCopy(target.original, target.options);
}
function deepClone(target) {
    if (!isDraftable(target)) return getValue(target);
    if (Array.isArray(target)) return target.map(deepClone);
    if (target instanceof Map) {
        const iterable = Array.from(target.entries()).map(([k, v])=>[
                k,
                deepClone(v)
            ]);
        if (!isBaseMapInstance(target)) {
            const SubClass = Object.getPrototypeOf(target).constructor;
            return new SubClass(iterable);
        }
        return new Map(iterable);
    }
    if (target instanceof Set) {
        const iterable = Array.from(target).map(deepClone);
        if (!isBaseSetInstance(target)) {
            const SubClass = Object.getPrototypeOf(target).constructor;
            return new SubClass(iterable);
        }
        return new Set(iterable);
    }
    const copy = Object.create(Object.getPrototypeOf(target));
    for(const key in target)copy[key] = deepClone(target[key]);
    return copy;
}
function cloneIfNeeded(target) {
    return isDraft(target) ? deepClone(target) : target;
}
function markChanged(proxyDraft) {
    var _a;
    proxyDraft.assignedMap = (_a = proxyDraft.assignedMap) !== null && _a !== void 0 ? _a : new Map();
    if (!proxyDraft.operated) {
        proxyDraft.operated = true;
        if (proxyDraft.parent) {
            markChanged(proxyDraft.parent);
        }
    }
}
function throwFrozenError() {
    throw new Error('Cannot modify frozen object');
}
function deepFreeze(target, subKey, updatedValues, stack, keys) {
    {
        updatedValues = updatedValues !== null && updatedValues !== void 0 ? updatedValues : new WeakMap();
        stack = stack !== null && stack !== void 0 ? stack : [];
        keys = keys !== null && keys !== void 0 ? keys : [];
        const value = updatedValues.has(target) ? updatedValues.get(target) : target;
        if (stack.length > 0) {
            const index = stack.indexOf(value);
            if (value && typeof value === 'object' && index !== -1) {
                if (stack[0] === value) {
                    throw new Error(`Forbids circular reference`);
                }
                throw new Error(`Forbids circular reference: ~/${keys.slice(0, index).map((key, index)=>{
                    if (typeof key === 'symbol') return `[${key.toString()}]`;
                    const parent = stack[index];
                    if (typeof key === 'object' && (parent instanceof Map || parent instanceof Set)) return Array.from(parent.keys()).indexOf(key);
                    return key;
                }).join('/')}`);
            }
            stack.push(value);
            keys.push(subKey);
        } else {
            stack.push(value);
        }
    }
    if (Object.isFrozen(target) || isDraft(target)) {
        {
            stack.pop();
            keys.pop();
        }
        return;
    }
    const type = getType(target);
    switch(type){
        case 2 /* DraftType.Map */ :
            for (const [key, value] of target){
                deepFreeze(key, key, updatedValues, stack, keys);
                deepFreeze(value, key, updatedValues, stack, keys);
            }
            target.set = target.clear = target.delete = throwFrozenError;
            break;
        case 3 /* DraftType.Set */ :
            for (const value of target){
                deepFreeze(value, value, updatedValues, stack, keys);
            }
            target.add = target.clear = target.delete = throwFrozenError;
            break;
        case 1 /* DraftType.Array */ :
            Object.freeze(target);
            let index = 0;
            for (const value of target){
                deepFreeze(value, index, updatedValues, stack, keys);
                index += 1;
            }
            break;
        default:
            Object.freeze(target);
            // ignore non-enumerable or symbol properties
            Object.keys(target).forEach((name)=>{
                const value = target[name];
                deepFreeze(value, name, updatedValues, stack, keys);
            });
    }
    {
        stack.pop();
        keys.pop();
    }
}
function forEach(target, iter) {
    const type = getType(target);
    if (type === 0 /* DraftType.Object */ ) {
        Reflect.ownKeys(target).forEach((key)=>{
            iter(key, target[key], target);
        });
    } else if (type === 1 /* DraftType.Array */ ) {
        let index = 0;
        for (const entry of target){
            iter(index, entry, target);
            index += 1;
        }
    } else {
        target.forEach((entry, index)=>iter(index, entry, target));
    }
}
function handleValue(target, handledSet, options) {
    if (isDraft(target) || !isDraftable(target, options) || handledSet.has(target) || Object.isFrozen(target)) return;
    const isSet = target instanceof Set;
    const setMap = isSet ? new Map() : undefined;
    handledSet.add(target);
    forEach(target, (key, value)=>{
        var _a;
        if (isDraft(value)) {
            const proxyDraft = getProxyDraft(value);
            ensureShallowCopy(proxyDraft);
            // A draft where a child node has been changed, or assigned a value
            const updatedValue = ((_a = proxyDraft.assignedMap) === null || _a === void 0 ? void 0 : _a.size) || proxyDraft.operated ? proxyDraft.copy : proxyDraft.original;
            // final update value
            set(isSet ? setMap : target, key, updatedValue);
        } else {
            handleValue(value, handledSet, options);
        }
    });
    if (setMap) {
        const set = target;
        const values = Array.from(set);
        set.clear();
        values.forEach((value)=>{
            set.add(setMap.has(value) ? setMap.get(value) : value);
        });
    }
}
function finalizeAssigned(proxyDraft, key) {
    // handle the draftable assigned values and the value is not a draft
    const copy = proxyDraft.type === 3 /* DraftType.Set */  ? proxyDraft.setMap : proxyDraft.copy;
    if (proxyDraft.finalities.revoke.length > 1 && proxyDraft.assignedMap.get(key) && copy) {
        handleValue(get(copy, key), proxyDraft.finalities.handledSet, proxyDraft.options);
    }
}
function finalizeSetValue(target) {
    if (target.type === 3 /* DraftType.Set */  && target.copy) {
        target.copy.clear();
        target.setMap.forEach((value)=>{
            target.copy.add(getValue(value));
        });
    }
}
function finalizePatches(target, generatePatches, patches, inversePatches) {
    const shouldFinalize = target.operated && target.assignedMap && target.assignedMap.size > 0 && !target.finalized;
    if (shouldFinalize) {
        if (patches && inversePatches) {
            const basePath = getPath(target);
            if (basePath) {
                generatePatches(target, basePath, patches, inversePatches);
            }
        }
        target.finalized = true;
    }
}
function markFinalization(target, key, value, generatePatches) {
    const proxyDraft = getProxyDraft(value);
    if (proxyDraft) {
        // !case: assign the draft value
        if (!proxyDraft.callbacks) {
            proxyDraft.callbacks = [];
        }
        proxyDraft.callbacks.push((patches, inversePatches)=>{
            var _a;
            const copy = target.type === 3 /* DraftType.Set */  ? target.setMap : target.copy;
            if (isEqual(get(copy, key), value)) {
                let updatedValue = proxyDraft.original;
                if (proxyDraft.copy) {
                    updatedValue = proxyDraft.copy;
                }
                finalizeSetValue(target);
                finalizePatches(target, generatePatches, patches, inversePatches);
                if (target.options.enableAutoFreeze) {
                    target.options.updatedValues = (_a = target.options.updatedValues) !== null && _a !== void 0 ? _a : new WeakMap();
                    target.options.updatedValues.set(updatedValue, proxyDraft.original);
                }
                // final update value
                set(copy, key, updatedValue);
            }
        });
        if (target.options.enableAutoFreeze) {
            // !case: assign the draft value in cross draft tree
            if (proxyDraft.finalities !== target.finalities) {
                target.options.enableAutoFreeze = false;
            }
        }
    }
    if (isDraftable(value, target.options)) {
        // !case: assign the non-draft value
        target.finalities.draft.push(()=>{
            const copy = target.type === 3 /* DraftType.Set */  ? target.setMap : target.copy;
            if (isEqual(get(copy, key), value)) {
                finalizeAssigned(target, key);
            }
        });
    }
}
function generateArrayPatches(proxyState, basePath, patches, inversePatches, pathAsArray) {
    let { original, assignedMap, options } = proxyState;
    let copy = proxyState.copy;
    if (copy.length < original.length) {
        [original, copy] = [
            copy,
            original
        ];
        [patches, inversePatches] = [
            inversePatches,
            patches
        ];
    }
    for(let index = 0; index < original.length; index += 1){
        if (assignedMap.get(index.toString()) && copy[index] !== original[index]) {
            const _path = basePath.concat([
                index
            ]);
            const path = escapePath(_path, pathAsArray);
            patches.push({
                op: Operation.Replace,
                path,
                // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
                value: cloneIfNeeded(copy[index])
            });
            inversePatches.push({
                op: Operation.Replace,
                path,
                // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
                value: cloneIfNeeded(original[index])
            });
        }
    }
    for(let index = original.length; index < copy.length; index += 1){
        const _path = basePath.concat([
            index
        ]);
        const path = escapePath(_path, pathAsArray);
        patches.push({
            op: Operation.Add,
            path,
            // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
            value: cloneIfNeeded(copy[index])
        });
    }
    if (original.length < copy.length) {
        // https://www.rfc-editor.org/rfc/rfc6902#appendix-A.4
        // For performance, here we only generate an operation that replaces the length of the array,
        // which is inconsistent with JSON Patch specification
        const { arrayLengthAssignment = true } = options.enablePatches;
        if (arrayLengthAssignment) {
            const _path = basePath.concat([
                'length'
            ]);
            const path = escapePath(_path, pathAsArray);
            inversePatches.push({
                op: Operation.Replace,
                path,
                value: original.length
            });
        } else {
            for(let index = copy.length; original.length < index; index -= 1){
                const _path = basePath.concat([
                    index - 1
                ]);
                const path = escapePath(_path, pathAsArray);
                inversePatches.push({
                    op: Operation.Remove,
                    path
                });
            }
        }
    }
}
function generatePatchesFromAssigned({ original, copy, assignedMap }, basePath, patches, inversePatches, pathAsArray) {
    assignedMap.forEach((assignedValue, key)=>{
        const originalValue = get(original, key);
        const value = cloneIfNeeded(get(copy, key));
        const op = !assignedValue ? Operation.Remove : has(original, key) ? Operation.Replace : Operation.Add;
        if (isEqual(originalValue, value) && op === Operation.Replace) return;
        const _path = basePath.concat(key);
        const path = escapePath(_path, pathAsArray);
        patches.push(op === Operation.Remove ? {
            op,
            path
        } : {
            op,
            path,
            value
        });
        inversePatches.push(op === Operation.Add ? {
            op: Operation.Remove,
            path
        } : op === Operation.Remove ? {
            op: Operation.Add,
            path,
            value: originalValue
        } : {
            op: Operation.Replace,
            path,
            value: originalValue
        });
    });
}
function generateSetPatches({ original, copy }, basePath, patches, inversePatches, pathAsArray) {
    let index = 0;
    original.forEach((value)=>{
        if (!copy.has(value)) {
            const _path = basePath.concat([
                index
            ]);
            const path = escapePath(_path, pathAsArray);
            patches.push({
                op: Operation.Remove,
                path,
                value
            });
            inversePatches.unshift({
                op: Operation.Add,
                path,
                value
            });
        }
        index += 1;
    });
    index = 0;
    copy.forEach((value)=>{
        if (!original.has(value)) {
            const _path = basePath.concat([
                index
            ]);
            const path = escapePath(_path, pathAsArray);
            patches.push({
                op: Operation.Add,
                path,
                value
            });
            inversePatches.unshift({
                op: Operation.Remove,
                path,
                value
            });
        }
        index += 1;
    });
}
function generatePatches(proxyState, basePath, patches, inversePatches) {
    const { pathAsArray = true } = proxyState.options.enablePatches;
    switch(proxyState.type){
        case 0 /* DraftType.Object */ :
        case 2 /* DraftType.Map */ :
            return generatePatchesFromAssigned(proxyState, basePath, patches, inversePatches, pathAsArray);
        case 1 /* DraftType.Array */ :
            return generateArrayPatches(proxyState, basePath, patches, inversePatches, pathAsArray);
        case 3 /* DraftType.Set */ :
            return generateSetPatches(proxyState, basePath, patches, inversePatches, pathAsArray);
    }
}
let readable = false;
const checkReadable = (value, options, ignoreCheckDraftable = false)=>{
    if (typeof value === 'object' && value !== null && (!isDraftable(value, options) || ignoreCheckDraftable) && !readable) {
        throw new Error(`Strict mode: Mutable data cannot be accessed directly, please use 'unsafe(callback)' wrap.`);
    }
};
/**
 * `unsafe(callback)` to access mutable data directly in strict mode.
 *
 * ## Example
 *
 * ```ts
 * import { create, unsafe } from '../index';
 *
 * class Foobar {
 *   bar = 1;
 * }
 *
 * const baseState = { foobar: new Foobar() };
 * const state = create(
 *   baseState,
 *   (draft) => {
 *    unsafe(() => {
 *      draft.foobar.bar = 2;
 *    });
 *   },
 *   {
 *     strict: true,
 *   }
 * );
 *
 * expect(state).toBe(baseState);
 * expect(state.foobar).toBe(baseState.foobar);
 * expect(state.foobar.bar).toBe(2);
 * ```
 */ function unsafe(callback) {
    readable = true;
    let result;
    try {
        result = callback();
    } finally{
        readable = false;
    }
    return result;
}
const mapHandler = {
    get size () {
        const current = latest(getProxyDraft(this));
        return current.size;
    },
    has (key) {
        return latest(getProxyDraft(this)).has(key);
    },
    set (key, value) {
        const target = getProxyDraft(this);
        const source = latest(target);
        if (!source.has(key) || !isEqual(source.get(key), value)) {
            ensureShallowCopy(target);
            markChanged(target);
            target.assignedMap.set(key, true);
            target.copy.set(key, value);
            markFinalization(target, key, value, generatePatches);
        }
        return this;
    },
    delete (key) {
        if (!this.has(key)) {
            return false;
        }
        const target = getProxyDraft(this);
        ensureShallowCopy(target);
        markChanged(target);
        if (target.original.has(key)) {
            target.assignedMap.set(key, false);
        } else {
            target.assignedMap.delete(key);
        }
        target.copy.delete(key);
        return true;
    },
    clear () {
        const target = getProxyDraft(this);
        if (!this.size) return;
        ensureShallowCopy(target);
        markChanged(target);
        target.assignedMap = new Map();
        for (const [key] of target.original){
            target.assignedMap.set(key, false);
        }
        target.copy.clear();
    },
    forEach (callback, thisArg) {
        const target = getProxyDraft(this);
        latest(target).forEach((_value, _key)=>{
            callback.call(thisArg, this.get(_key), _key, this);
        });
    },
    get (key) {
        var _a, _b;
        const target = getProxyDraft(this);
        const value = latest(target).get(key);
        const mutable = ((_b = (_a = target.options).mark) === null || _b === void 0 ? void 0 : _b.call(_a, value, dataTypes)) === dataTypes.mutable;
        if (target.options.strict) {
            checkReadable(value, target.options, mutable);
        }
        if (mutable) {
            return value;
        }
        if (target.finalized || !isDraftable(value, target.options)) {
            return value;
        }
        // drafted or reassigned
        if (value !== target.original.get(key)) {
            return value;
        }
        const draft = internal.createDraft({
            original: value,
            parentDraft: target,
            key,
            finalities: target.finalities,
            options: target.options
        });
        ensureShallowCopy(target);
        target.copy.set(key, draft);
        return draft;
    },
    keys () {
        return latest(getProxyDraft(this)).keys();
    },
    values () {
        const iterator = this.keys();
        return {
            [iteratorSymbol]: ()=>this.values(),
            next: ()=>{
                const result = iterator.next();
                if (result.done) return result;
                const value = this.get(result.value);
                return {
                    done: false,
                    value
                };
            }
        };
    },
    entries () {
        const iterator = this.keys();
        return {
            [iteratorSymbol]: ()=>this.entries(),
            next: ()=>{
                const result = iterator.next();
                if (result.done) return result;
                const value = this.get(result.value);
                return {
                    done: false,
                    value: [
                        result.value,
                        value
                    ]
                };
            }
        };
    },
    [iteratorSymbol] () {
        return this.entries();
    }
};
const mapHandlerKeys = Reflect.ownKeys(mapHandler);
const getNextIterator = (target, iterator, { isValuesIterator })=>()=>{
        var _a, _b;
        const result = iterator.next();
        if (result.done) return result;
        const key = result.value;
        let value = target.setMap.get(key);
        const currentDraft = getProxyDraft(value);
        const mutable = ((_b = (_a = target.options).mark) === null || _b === void 0 ? void 0 : _b.call(_a, value, dataTypes)) === dataTypes.mutable;
        if (target.options.strict) {
            checkReadable(key, target.options, mutable);
        }
        if (!mutable && !currentDraft && isDraftable(key, target.options) && !target.finalized && target.original.has(key)) {
            // draft a draftable original set item
            const proxy = internal.createDraft({
                original: key,
                parentDraft: target,
                key,
                finalities: target.finalities,
                options: target.options
            });
            target.setMap.set(key, proxy);
            value = proxy;
        } else if (currentDraft) {
            // drafted
            value = currentDraft.proxy;
        }
        return {
            done: false,
            value: isValuesIterator ? value : [
                value,
                value
            ]
        };
    };
const setHandler = {
    get size () {
        const target = getProxyDraft(this);
        return target.setMap.size;
    },
    has (value) {
        const target = getProxyDraft(this);
        // reassigned or non-draftable values
        if (target.setMap.has(value)) return true;
        ensureShallowCopy(target);
        const valueProxyDraft = getProxyDraft(value);
        // drafted
        if (valueProxyDraft && target.setMap.has(valueProxyDraft.original)) return true;
        return false;
    },
    add (value) {
        const target = getProxyDraft(this);
        if (!this.has(value)) {
            ensureShallowCopy(target);
            markChanged(target);
            target.assignedMap.set(value, true);
            target.setMap.set(value, value);
            markFinalization(target, value, value, generatePatches);
        }
        return this;
    },
    delete (value) {
        if (!this.has(value)) {
            return false;
        }
        const target = getProxyDraft(this);
        ensureShallowCopy(target);
        markChanged(target);
        const valueProxyDraft = getProxyDraft(value);
        if (valueProxyDraft && target.setMap.has(valueProxyDraft.original)) {
            // delete drafted
            target.assignedMap.set(valueProxyDraft.original, false);
            return target.setMap.delete(valueProxyDraft.original);
        }
        if (!valueProxyDraft && target.setMap.has(value)) {
            // non-draftable values
            target.assignedMap.set(value, false);
        } else {
            // reassigned
            target.assignedMap.delete(value);
        }
        // delete reassigned or non-draftable values
        return target.setMap.delete(value);
    },
    clear () {
        if (!this.size) return;
        const target = getProxyDraft(this);
        ensureShallowCopy(target);
        markChanged(target);
        for (const value of target.original){
            target.assignedMap.set(value, false);
        }
        target.setMap.clear();
    },
    values () {
        const target = getProxyDraft(this);
        ensureShallowCopy(target);
        const iterator = target.setMap.keys();
        return {
            [Symbol.iterator]: ()=>this.values(),
            next: getNextIterator(target, iterator, {
                isValuesIterator: true
            })
        };
    },
    entries () {
        const target = getProxyDraft(this);
        ensureShallowCopy(target);
        const iterator = target.setMap.keys();
        return {
            [Symbol.iterator]: ()=>this.entries(),
            next: getNextIterator(target, iterator, {
                isValuesIterator: false
            })
        };
    },
    keys () {
        return this.values();
    },
    [iteratorSymbol] () {
        return this.values();
    },
    forEach (callback, thisArg) {
        const iterator = this.values();
        let result = iterator.next();
        while(!result.done){
            callback.call(thisArg, result.value, result.value, this);
            result = iterator.next();
        }
    }
};
if (Set.prototype.difference) {
    // for compatibility with new Set methods
    // https://github.com/tc39/proposal-set-methods
    // And `https://github.com/tc39/proposal-set-methods/blob/main/details.md#symbolspecies` has some details about the `@@species` symbol.
    // So we can't use SubSet instance constructor to get the constructor of the SubSet instance.
    Object.assign(setHandler, {
        intersection (other) {
            return Set.prototype.intersection.call(new Set(this.values()), other);
        },
        union (other) {
            return Set.prototype.union.call(new Set(this.values()), other);
        },
        difference (other) {
            return Set.prototype.difference.call(new Set(this.values()), other);
        },
        symmetricDifference (other) {
            return Set.prototype.symmetricDifference.call(new Set(this.values()), other);
        },
        isSubsetOf (other) {
            return Set.prototype.isSubsetOf.call(new Set(this.values()), other);
        },
        isSupersetOf (other) {
            return Set.prototype.isSupersetOf.call(new Set(this.values()), other);
        },
        isDisjointFrom (other) {
            return Set.prototype.isDisjointFrom.call(new Set(this.values()), other);
        }
    });
}
const setHandlerKeys = Reflect.ownKeys(setHandler);
const draftsCache = new WeakSet();
const proxyHandler = {
    get (target, key, receiver) {
        var _a, _b;
        const copy = (_a = target.copy) === null || _a === void 0 ? void 0 : _a[key];
        // Improve draft reading performance by caching the draft copy.
        if (copy && draftsCache.has(copy)) {
            return copy;
        }
        if (key === PROXY_DRAFT) return target;
        let markResult;
        if (target.options.mark) {
            // handle `Uncaught TypeError: Method get Map.prototype.size called on incompatible receiver #<Map>`
            // or `Uncaught TypeError: Method get Set.prototype.size called on incompatible receiver #<Set>`
            const value = key === 'size' && (target.original instanceof Map || target.original instanceof Set) ? Reflect.get(target.original, key) : Reflect.get(target.original, key, receiver);
            markResult = target.options.mark(value, dataTypes);
            if (markResult === dataTypes.mutable) {
                if (target.options.strict) {
                    checkReadable(value, target.options, true);
                }
                return value;
            }
        }
        const source = latest(target);
        if (source instanceof Map && mapHandlerKeys.includes(key)) {
            if (key === 'size') {
                return Object.getOwnPropertyDescriptor(mapHandler, 'size').get.call(target.proxy);
            }
            const handle = mapHandler[key];
            if (handle) {
                return handle.bind(target.proxy);
            }
        }
        if (source instanceof Set && setHandlerKeys.includes(key)) {
            if (key === 'size') {
                return Object.getOwnPropertyDescriptor(setHandler, 'size').get.call(target.proxy);
            }
            const handle = setHandler[key];
            if (handle) {
                return handle.bind(target.proxy);
            }
        }
        if (!has(source, key)) {
            const desc = getDescriptor(source, key);
            return desc ? `value` in desc ? desc.value : (_b = desc.get) === null || _b === void 0 ? void 0 : _b.call(target.proxy) : undefined;
        }
        const value = source[key];
        if (target.options.strict) {
            checkReadable(value, target.options);
        }
        if (target.finalized || !isDraftable(value, target.options)) {
            return value;
        }
        // Ensure that the assigned values are not drafted
        if (value === peek(target.original, key)) {
            ensureShallowCopy(target);
            target.copy[key] = createDraft({
                original: target.original[key],
                parentDraft: target,
                key: target.type === 1 /* DraftType.Array */  ? Number(key) : key,
                finalities: target.finalities,
                options: target.options
            });
            // !case: support for custom shallow copy function
            if (typeof markResult === 'function') {
                const subProxyDraft = getProxyDraft(target.copy[key]);
                ensureShallowCopy(subProxyDraft);
                // Trigger a custom shallow copy to update to a new copy
                markChanged(subProxyDraft);
                return subProxyDraft.copy;
            }
            return target.copy[key];
        }
        return value;
    },
    set (target, key, value) {
        var _a;
        if (target.type === 3 /* DraftType.Set */  || target.type === 2 /* DraftType.Map */ ) {
            throw new Error(`Map/Set draft does not support any property assignment.`);
        }
        let _key;
        if (target.type === 1 /* DraftType.Array */  && key !== 'length' && !(Number.isInteger(_key = Number(key)) && _key >= 0 && (key === 0 || _key === 0 || String(_key) === String(key)))) {
            throw new Error(`Only supports setting array indices and the 'length' property.`);
        }
        const desc = getDescriptor(latest(target), key);
        if (desc === null || desc === void 0 ? void 0 : desc.set) {
            // !case: cover the case of setter
            desc.set.call(target.proxy, value);
            return true;
        }
        const current = peek(latest(target), key);
        const currentProxyDraft = getProxyDraft(current);
        if (currentProxyDraft && isEqual(currentProxyDraft.original, value)) {
            // !case: ignore the case of assigning the original draftable value to a draft
            target.copy[key] = value;
            target.assignedMap = (_a = target.assignedMap) !== null && _a !== void 0 ? _a : new Map();
            target.assignedMap.set(key, false);
            return true;
        }
        // !case: handle new props with value 'undefined'
        if (isEqual(value, current) && (value !== undefined || has(target.original, key))) return true;
        ensureShallowCopy(target);
        markChanged(target);
        if (has(target.original, key) && isEqual(value, target.original[key])) {
            // !case: handle the case of assigning the original non-draftable value to a draft
            target.assignedMap.delete(key);
        } else {
            target.assignedMap.set(key, true);
        }
        target.copy[key] = value;
        markFinalization(target, key, value, generatePatches);
        return true;
    },
    has (target, key) {
        return key in latest(target);
    },
    ownKeys (target) {
        return Reflect.ownKeys(latest(target));
    },
    getOwnPropertyDescriptor (target, key) {
        const source = latest(target);
        const descriptor = Reflect.getOwnPropertyDescriptor(source, key);
        if (!descriptor) return descriptor;
        return {
            writable: true,
            configurable: target.type !== 1 /* DraftType.Array */  || key !== 'length',
            enumerable: descriptor.enumerable,
            value: source[key]
        };
    },
    getPrototypeOf (target) {
        return Reflect.getPrototypeOf(target.original);
    },
    setPrototypeOf () {
        throw new Error(`Cannot call 'setPrototypeOf()' on drafts`);
    },
    defineProperty () {
        throw new Error(`Cannot call 'defineProperty()' on drafts`);
    },
    deleteProperty (target, key) {
        var _a;
        if (target.type === 1 /* DraftType.Array */ ) {
            return proxyHandler.set.call(this, target, key, undefined, target.proxy);
        }
        if (peek(target.original, key) !== undefined || key in target.original) {
            // !case: delete an existing key
            ensureShallowCopy(target);
            markChanged(target);
            target.assignedMap.set(key, false);
        } else {
            target.assignedMap = (_a = target.assignedMap) !== null && _a !== void 0 ? _a : new Map();
            // The original non-existent key has been deleted
            target.assignedMap.delete(key);
        }
        if (target.copy) delete target.copy[key];
        return true;
    }
};
function createDraft(createDraftOptions) {
    const { original, parentDraft, key, finalities, options } = createDraftOptions;
    const type = getType(original);
    const proxyDraft = {
        type,
        finalized: false,
        parent: parentDraft,
        original,
        copy: null,
        proxy: null,
        finalities,
        options,
        // Mapping of draft Set items to their corresponding draft values.
        setMap: type === 3 /* DraftType.Set */  ? new Map(original.entries()) : undefined
    };
    // !case: undefined as a draft map key
    if (key || 'key' in createDraftOptions) {
        proxyDraft.key = key;
    }
    const { proxy, revoke } = Proxy.revocable(type === 1 /* DraftType.Array */  ? Object.assign([], proxyDraft) : proxyDraft, proxyHandler);
    finalities.revoke.push(revoke);
    draftsCache.add(proxy);
    proxyDraft.proxy = proxy;
    if (parentDraft) {
        const target = parentDraft;
        target.finalities.draft.push((patches, inversePatches)=>{
            var _a, _b;
            const oldProxyDraft = getProxyDraft(proxy);
            // if target is a Set draft, `setMap` is the real Set copies proxy mapping.
            let copy = target.type === 3 /* DraftType.Set */  ? target.setMap : target.copy;
            const draft = get(copy, key);
            const proxyDraft = getProxyDraft(draft);
            if (proxyDraft) {
                // assign the updated value to the copy object
                let updatedValue = proxyDraft.original;
                if (proxyDraft.operated) {
                    updatedValue = getValue(draft);
                }
                finalizeSetValue(proxyDraft);
                finalizePatches(proxyDraft, generatePatches, patches, inversePatches);
                if (target.options.enableAutoFreeze) {
                    target.options.updatedValues = (_a = target.options.updatedValues) !== null && _a !== void 0 ? _a : new WeakMap();
                    target.options.updatedValues.set(updatedValue, proxyDraft.original);
                }
                // final update value
                set(copy, key, updatedValue);
            }
            // !case: handle the deleted key
            (_b = oldProxyDraft.callbacks) === null || _b === void 0 ? void 0 : _b.forEach((callback)=>{
                callback(patches, inversePatches);
            });
        });
    } else {
        // !case: handle the root draft
        const target = getProxyDraft(proxy);
        target.finalities.draft.push((patches, inversePatches)=>{
            finalizeSetValue(target);
            finalizePatches(target, generatePatches, patches, inversePatches);
        });
    }
    return proxy;
}
internal.createDraft = createDraft;
function finalizeDraft(result, returnedValue, patches, inversePatches, enableAutoFreeze) {
    var _a;
    const proxyDraft = getProxyDraft(result);
    const original = (_a = proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== null && _a !== void 0 ? _a : result;
    const hasReturnedValue = !!returnedValue.length;
    if (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.operated) {
        while(proxyDraft.finalities.draft.length > 0){
            const finalize = proxyDraft.finalities.draft.pop();
            finalize(patches, inversePatches);
        }
    }
    const state = hasReturnedValue ? returnedValue[0] : proxyDraft ? proxyDraft.operated ? proxyDraft.copy : proxyDraft.original : result;
    if (proxyDraft) revokeProxy(proxyDraft);
    if (enableAutoFreeze) {
        deepFreeze(state, state, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options.updatedValues);
    }
    return [
        state,
        patches && hasReturnedValue ? [
            {
                op: Operation.Replace,
                path: [],
                value: returnedValue[0]
            }
        ] : patches,
        inversePatches && hasReturnedValue ? [
            {
                op: Operation.Replace,
                path: [],
                value: original
            }
        ] : inversePatches
    ];
}
function draftify(baseState, options) {
    var _a;
    const finalities = {
        draft: [],
        revoke: [],
        handledSet: new WeakSet()
    };
    let patches;
    let inversePatches;
    if (options.enablePatches) {
        patches = [];
        inversePatches = [];
    }
    const isMutable = ((_a = options.mark) === null || _a === void 0 ? void 0 : _a.call(options, baseState, dataTypes)) === dataTypes.mutable || !isDraftable(baseState, options);
    const draft = isMutable ? baseState : createDraft({
        original: baseState,
        parentDraft: null,
        finalities,
        options
    });
    return [
        draft,
        (returnedValue = [])=>{
            const [finalizedState, finalizedPatches, finalizedInversePatches] = finalizeDraft(draft, returnedValue, patches, inversePatches, options.enableAutoFreeze);
            return options.enablePatches ? [
                finalizedState,
                finalizedPatches,
                finalizedInversePatches
            ] : finalizedState;
        }
    ];
}
function handleReturnValue(options) {
    const { rootDraft, value, useRawReturn = false, isRoot = true } = options;
    forEach(value, (key, item, source)=>{
        const proxyDraft = getProxyDraft(item);
        // just handle the draft which is created by the same rootDraft
        if (proxyDraft && rootDraft && proxyDraft.finalities === rootDraft.finalities) {
            options.isContainDraft = true;
            const currentValue = proxyDraft.original;
            // final update value, but just handle return value
            if (source instanceof Set) {
                const arr = Array.from(source);
                source.clear();
                arr.forEach((_item)=>source.add(key === _item ? currentValue : _item));
            } else {
                set(source, key, currentValue);
            }
        } else if (typeof item === 'object' && item !== null) {
            options.value = item;
            options.isRoot = false;
            handleReturnValue(options);
        }
    });
    if (isRoot) {
        if (!options.isContainDraft) console.warn(`The return value does not contain any draft, please use 'rawReturn()' to wrap the return value to improve performance.`);
        if (useRawReturn) {
            console.warn(`The return value contains drafts, please don't use 'rawReturn()' to wrap the return value.`);
        }
    }
}
function getCurrent(target) {
    var _a;
    const proxyDraft = getProxyDraft(target);
    if (!isDraftable(target, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options)) return target;
    const type = getType(target);
    if (proxyDraft && !proxyDraft.operated) return proxyDraft.original;
    let currentValue;
    function ensureShallowCopy() {
        currentValue = type === 2 /* DraftType.Map */  ? !isBaseMapInstance(target) ? new (Object.getPrototypeOf(target)).constructor(target) : new Map(target) : type === 3 /* DraftType.Set */  ? Array.from(proxyDraft.setMap.values()) : shallowCopy(target, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options);
    }
    if (proxyDraft) {
        // It's a proxy draft, let's create a shallow copy eagerly
        proxyDraft.finalized = true;
        try {
            ensureShallowCopy();
        } finally{
            proxyDraft.finalized = false;
        }
    } else {
        // It's not a proxy draft, let's use the target directly and let's see
        // lazily if we need to create a shallow copy
        currentValue = target;
    }
    forEach(currentValue, (key, value)=>{
        if (proxyDraft && isEqual(get(proxyDraft.original, key), value)) return;
        const newValue = getCurrent(value);
        if (newValue !== value) {
            if (currentValue === target) ensureShallowCopy();
            set(currentValue, key, newValue);
        }
    });
    if (type === 3 /* DraftType.Set */ ) {
        const value = (_a = proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== null && _a !== void 0 ? _a : currentValue;
        return !isBaseSetInstance(value) ? new (Object.getPrototypeOf(value)).constructor(currentValue) : new Set(currentValue);
    }
    return currentValue;
}
function current(target) {
    if (!isDraft(target)) {
        throw new Error(`current() is only used for Draft, parameter: ${target}`);
    }
    return getCurrent(target);
}
/**
 * `makeCreator(options)` to make a creator function.
 *
 * ## Example
 *
 * ```ts
 * import { makeCreator } from '../index';
 *
 * const baseState = { foo: { bar: 'str' }, arr: [] };
 * const create = makeCreator({ enableAutoFreeze: true });
 * const state = create(
 *   baseState,
 *   (draft) => {
 *     draft.foo.bar = 'str2';
 *   },
 * );
 *
 * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });
 * expect(state).not.toBe(baseState);
 * expect(state.foo).not.toBe(baseState.foo);
 * expect(state.arr).toBe(baseState.arr);
 * expect(Object.isFrozen(state)).toBeTruthy();
 * ```
 */ const makeCreator = (arg)=>{
    if (arg !== undefined && Object.prototype.toString.call(arg) !== '[object Object]') {
        throw new Error(`Invalid options: ${String(arg)}, 'options' should be an object.`);
    }
    return function create(arg0, arg1, arg2) {
        var _a, _b, _c;
        if (typeof arg0 === 'function' && typeof arg1 !== 'function') {
            return function(base, ...args) {
                return create(base, (draft)=>arg0.call(this, draft, ...args), arg1);
            };
        }
        const base = arg0;
        const mutate = arg1;
        let options = arg2;
        if (typeof arg1 !== 'function') {
            options = arg1;
        }
        if (options !== undefined && Object.prototype.toString.call(options) !== '[object Object]') {
            throw new Error(`Invalid options: ${options}, 'options' should be an object.`);
        }
        options = Object.assign(Object.assign({}, arg), options);
        const state = isDraft(base) ? current(base) : base;
        const mark = Array.isArray(options.mark) ? (value, types)=>{
            for (const mark of options.mark){
                if (typeof mark !== 'function') {
                    throw new Error(`Invalid mark: ${mark}, 'mark' should be a function.`);
                }
                const result = mark(value, types);
                if (result) {
                    return result;
                }
            }
            return;
        } : options.mark;
        const enablePatches = (_a = options.enablePatches) !== null && _a !== void 0 ? _a : false;
        const strict = (_b = options.strict) !== null && _b !== void 0 ? _b : false;
        const enableAutoFreeze = (_c = options.enableAutoFreeze) !== null && _c !== void 0 ? _c : false;
        const _options = {
            enableAutoFreeze,
            mark,
            strict,
            enablePatches
        };
        if (!isDraftable(state, _options) && typeof state === 'object' && state !== null) {
            throw new Error(`Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`);
        }
        const [draft, finalize] = draftify(state, _options);
        if (typeof arg1 !== 'function') {
            if (!isDraftable(state, _options)) {
                throw new Error(`Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`);
            }
            return [
                draft,
                finalize
            ];
        }
        let result;
        try {
            result = mutate(draft);
        } catch (error) {
            revokeProxy(getProxyDraft(draft));
            throw error;
        }
        const returnValue = (value)=>{
            const proxyDraft = getProxyDraft(draft);
            if (!isDraft(value)) {
                if (value !== undefined && !isEqual(value, draft) && (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.operated)) {
                    throw new Error(`Either the value is returned as a new non-draft value, or only the draft is modified without returning any value.`);
                }
                const rawReturnValue = value === null || value === void 0 ? void 0 : value[RAW_RETURN_SYMBOL];
                if (rawReturnValue) {
                    const _value = rawReturnValue[0];
                    if (_options.strict && typeof value === 'object' && value !== null) {
                        handleReturnValue({
                            rootDraft: proxyDraft,
                            value,
                            useRawReturn: true
                        });
                    }
                    return finalize([
                        _value
                    ]);
                }
                if (value !== undefined) {
                    if (typeof value === 'object' && value !== null) {
                        handleReturnValue({
                            rootDraft: proxyDraft,
                            value
                        });
                    }
                    return finalize([
                        value
                    ]);
                }
            }
            if (value === draft || value === undefined) {
                return finalize([]);
            }
            const returnedProxyDraft = getProxyDraft(value);
            if (_options === returnedProxyDraft.options) {
                if (returnedProxyDraft.operated) {
                    throw new Error(`Cannot return a modified child draft.`);
                }
                return finalize([
                    current(value)
                ]);
            }
            return finalize([
                value
            ]);
        };
        if (result instanceof Promise) {
            return result.then(returnValue, (error)=>{
                revokeProxy(getProxyDraft(draft));
                throw error;
            });
        }
        return returnValue(result);
    };
};
/**
 * `create(baseState, callback, options)` to create the next state
 *
 * ## Example
 *
 * ```ts
 * import { create } from '../index';
 *
 * const baseState = { foo: { bar: 'str' }, arr: [] };
 * const state = create(
 *   baseState,
 *   (draft) => {
 *     draft.foo.bar = 'str2';
 *   },
 * );
 *
 * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });
 * expect(state).not.toBe(baseState);
 * expect(state.foo).not.toBe(baseState.foo);
 * expect(state.arr).toBe(baseState.arr);
 * ```
 */ const create = makeCreator();
/**
 * `apply(state, patches)` to apply patches to state
 *
 * ## Example
 *
 * ```ts
 * import { create, apply } from '../index';
 *
 * const baseState = { foo: { bar: 'str' }, arr: [] };
 * const [state, patches] = create(
 *   baseState,
 *   (draft) => {
 *     draft.foo.bar = 'str2';
 *   },
 *   { enablePatches: true }
 * );
 * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });
 * expect(patches).toEqual([{ op: 'replace', path: ['foo', 'bar'], value: 'str2' }]);
 * expect(state).toEqual(apply(baseState, patches));
 * ```
 */ function apply(state, patches, applyOptions) {
    let i;
    for(i = patches.length - 1; i >= 0; i -= 1){
        const { value, op, path } = patches[i];
        if (!path.length && op === Operation.Replace || path === '' && op === Operation.Add) {
            state = value;
            break;
        }
    }
    if (i > -1) {
        patches = patches.slice(i + 1);
    }
    const mutate = (draft)=>{
        patches.forEach((patch)=>{
            const { path: _path, op } = patch;
            const path = unescapePath(_path);
            let base = draft;
            for(let index = 0; index < path.length - 1; index += 1){
                const parentType = getType(base);
                let key = path[index];
                if (typeof key !== 'string' && typeof key !== 'number') {
                    key = String(key);
                }
                if ((parentType === 0 /* DraftType.Object */  || parentType === 1 /* DraftType.Array */ ) && (key === '__proto__' || key === 'constructor') || typeof base === 'function' && key === 'prototype') {
                    throw new Error(`Patching reserved attributes like __proto__ and constructor is not allowed.`);
                }
                // use `index` in Set draft
                base = get(parentType === 3 /* DraftType.Set */  ? Array.from(base) : base, key);
                if (typeof base !== 'object') {
                    throw new Error(`Cannot apply patch at '${path.join('/')}'.`);
                }
            }
            const type = getType(base);
            // ensure the original patch is not modified.
            const value = deepClone(patch.value);
            const key = path[path.length - 1];
            switch(op){
                case Operation.Replace:
                    switch(type){
                        case 2 /* DraftType.Map */ :
                            return base.set(key, value);
                        case 3 /* DraftType.Set */ :
                            throw new Error(`Cannot apply replace patch to set.`);
                        default:
                            return base[key] = value;
                    }
                case Operation.Add:
                    switch(type){
                        case 1 /* DraftType.Array */ :
                            // If the "-" character is used to
                            // index the end of the array (see [RFC6901](https://datatracker.ietf.org/doc/html/rfc6902)),
                            // this has the effect of appending the value to the array.
                            return key === '-' ? base.push(value) : base.splice(key, 0, value);
                        case 2 /* DraftType.Map */ :
                            return base.set(key, value);
                        case 3 /* DraftType.Set */ :
                            return base.add(value);
                        default:
                            return base[key] = value;
                    }
                case Operation.Remove:
                    switch(type){
                        case 1 /* DraftType.Array */ :
                            return base.splice(key, 1);
                        case 2 /* DraftType.Map */ :
                            return base.delete(key);
                        case 3 /* DraftType.Set */ :
                            return base.delete(patch.value);
                        default:
                            return delete base[key];
                    }
                default:
                    throw new Error(`Unsupported patch operation: ${op}.`);
            }
        });
    };
    if (isDraft(state)) {
        if (applyOptions !== undefined) {
            throw new Error(`Cannot apply patches with options to a draft.`);
        }
        mutate(state);
        return state;
    }
    return create(state, mutate, Object.assign(Object.assign({}, applyOptions), {
        enablePatches: false
    }));
}
/**
 * `original(draft)` to get original state in the draft mutation function.
 *
 * ## Example
 *
 * ```ts
 * import { create, original } from '../index';
 *
 * const baseState = { foo: { bar: 'str' }, arr: [] };
 * const state = create(
 *   baseState,
 *   (draft) => {
 *     draft.foo.bar = 'str2';
 *     expect(original(draft.foo)).toEqual({ bar: 'str' });
 *   }
 * );
 * ```
 */ function original(target) {
    const proxyDraft = getProxyDraft(target);
    if (!proxyDraft) {
        throw new Error(`original() is only used for a draft, parameter: ${target}`);
    }
    return proxyDraft.original;
}
/**
 * Use rawReturn() to wrap the return value to skip the draft check and thus improve performance.
 *
 * ## Example
 *
 * ```ts
 * import { create, rawReturn } from '../index';
 *
 * const baseState = { foo: { bar: 'str' }, arr: [] };
 * const state = create(
 *   baseState,
 *   (draft) => {
 *     return rawReturn(baseState);
 *   },
 * );
 * expect(state).toBe(baseState);
 * ```
 */ function rawReturn(value) {
    if (arguments.length === 0) {
        throw new Error('rawReturn() must be called with a value.');
    }
    if (arguments.length > 1) {
        throw new Error('rawReturn() must be called with one argument.');
    }
    if (value !== undefined && (typeof value !== 'object' || value === null)) {
        console.warn('rawReturn() must be called with an object(including plain object, arrays, Set, Map, etc.) or `undefined`, other types do not need to be returned via rawReturn().');
    }
    return {
        [RAW_RETURN_SYMBOL]: [
            value
        ]
    };
}
const constructorString = Object.prototype.constructor.toString();
/**
 * Check if the value is a simple object(No prototype chain object or iframe same-origin object),
 * support case: https://github.com/unadlib/mutative/issues/17
 */ const isSimpleObject = (value)=>{
    if (!value || typeof value !== 'object') return false;
    const prototype = Object.getPrototypeOf(value);
    if (prototype === null) {
        return true;
    }
    const constructor = Object.hasOwnProperty.call(prototype, 'constructor') && prototype.constructor;
    if (constructor === Object) return true;
    return typeof constructor === 'function' && Function.toString.call(constructor) === constructorString;
};
const markSimpleObject = (value)=>{
    if (isSimpleObject(value)) {
        return dataTypes.immutable;
    }
    return;
};
/**
 * Cast a value to an Draft type value.
 */ function castDraft(value) {
    return value;
}
/**
 * Cast a value to an Immutable type value.
 */ function castImmutable(value) {
    return value;
}
/**
 * Cast a value to an Mutable type value.
 */ function castMutable(draft) {
    return draft;
}
;
 //# sourceMappingURL=mutative.esm.mjs.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/object.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "areObjectKeysEqual": (()=>areObjectKeysEqual),
    "areObjectsDeepEqual": (()=>areObjectsDeepEqual),
    "areObjectsShallowEqual": (()=>areObjectsShallowEqual),
    "assocIn": (()=>assocIn),
    "dissocIn": (()=>dissocIn),
    "immutableDeepMerge": (()=>immutableDeepMerge),
    "immutableDeepReplace": (()=>immutableDeepReplace),
    "isObject": (()=>isObject)
});
function areObjectKeysEqual(a, b) {
    const ak = Object.keys(a);
    const bk = Object.keys(b);
    return ak.length === bk.length && Object.keys(a).every((k)=>b.hasOwnProperty(k));
}
function areObjectsShallowEqual(obj1, obj2) {
    return Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every((key)=>obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);
}
function areObjectsDeepEqual(obj1, obj2) {
    if (typeof obj1 !== 'object' || typeof obj2 !== 'object' || obj1 === null || obj2 === null) {
        return obj1 === obj2;
    }
    if (!areObjectKeysEqual(obj1, obj2)) {
        return false;
    }
    return Object.keys(obj1).every((key)=>areObjectsDeepEqual(obj1[key], obj2[key]));
}
function immutableDeepMerge(target, source) {
    if (!isObject(target) || !isObject(source)) {
        return source;
    }
    const result = {};
    for (const key of Object.keys(target)){
        if (source[key] === null) continue;
        result[key] = target[key];
    }
    for (const key of Object.keys(source)){
        if (source[key] === null) continue;
        const areBothObjects = isObject(target[key]) && isObject(source[key]);
        result[key] = areBothObjects ? immutableDeepMerge(target[key], source[key]) : source[key];
    }
    return result;
}
function immutableDeepReplace(target, replaceValue, replacementValue) {
    if (!isObject(target)) {
        return target;
    }
    const result = {};
    for (const [key, value] of Object.entries(target)){
        result[key] = isObject(value) ? immutableDeepReplace(value, replaceValue, replacementValue) : value === replaceValue ? replacementValue : value;
    }
    return result;
}
function isObject(val) {
    return typeof val === 'object' && val !== null && !Array.isArray(val);
}
function assocIn(obj, path, value) {
    if (path.length === 0) {
        return value;
    }
    let current = obj || {};
    for(let i = 0; i < path.length - 1; i++){
        const key = path[i];
        if (!(key in current) || typeof current[key] !== 'object') {
            current[key] = typeof path[i + 1] === 'number' ? [] : {};
        }
        current = current[key];
    }
    current[path[path.length - 1]] = value;
    return obj;
}
function dissocIn(obj, path) {
    if (path.length === 0) {
        return undefined;
    }
    const [key, ...restPath] = path;
    if (!(key in obj)) {
        return obj;
    }
    if (restPath.length === 0) {
        delete obj[key];
        return isEmpty(obj) ? undefined : obj;
    }
    const child = dissocIn(obj[key], restPath);
    if (child === undefined) {
        delete obj[key];
        return isEmpty(obj) ? undefined : obj;
    }
    return obj;
}
function isEmpty(obj) {
    return obj && Object.keys(obj).length === 0;
} //# sourceMappingURL=object.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/store.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "allMapValues": (()=>allMapValues),
    "createStore": (()=>createStore),
    "fromJSON": (()=>fromJSON),
    "getAsObject": (()=>getAsObject),
    "getAttrByFwdIdentName": (()=>getAttrByFwdIdentName),
    "getAttrByReverseIdentName": (()=>getAttrByReverseIdentName),
    "getPrimaryKeyAttr": (()=>getPrimaryKeyAttr),
    "getTriples": (()=>getTriples),
    "toJSON": (()=>toJSON),
    "transact": (()=>transact)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$mutative$2f$dist$2f$mutative$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/mutative/dist/mutative.esm.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/object.js [app-client] (ecmascript)");
;
;
function hasEA(attr) {
    return attr['cardinality'] === 'one';
}
function isRef(attr) {
    return attr['value-type'] === 'ref';
}
function isBlob(attr) {
    return attr['value-type'] === 'blob';
}
function getAttr(attrs, attrId) {
    return attrs[attrId];
}
function getInMap(obj, path) {
    return path.reduce((acc, key)=>acc && acc.get(key), obj);
}
function deleteInMap(m, path) {
    if (path.length === 0) throw new Error('path must have at least one element');
    if (path.length === 1) {
        m.delete(path[0]);
        return;
    }
    const [head, ...tail] = path;
    if (!m.has(head)) return;
    deleteInMap(m.get(head), tail);
}
function setInMap(m, path, value) {
    if (path.length === 0) throw new Error('path must have at least one element');
    if (path.length === 1) {
        m.set(path[0], value);
        return;
    }
    const [head, ...tail] = path;
    let nextM = m.get(head);
    if (!nextM) {
        nextM = new Map();
        m.set(head, nextM);
    }
    setInMap(nextM, tail, value);
}
function createTripleIndexes(attrs, triples) {
    const eav = new Map();
    const aev = new Map();
    const vae = new Map();
    for (const triple of triples){
        const [eid, aid, v, t] = triple;
        const attr = getAttr(attrs, aid);
        if (!attr) {
            console.warn('no such attr', eid, attrs);
            continue;
        }
        if (isRef(attr)) {
            setInMap(vae, [
                v,
                aid,
                eid
            ], triple);
        }
        setInMap(eav, [
            eid,
            aid,
            v
        ], triple);
        setInMap(aev, [
            aid,
            eid,
            v
        ], triple);
    }
    return {
        eav,
        aev,
        vae
    };
}
function createAttrIndexes(attrs) {
    const blobAttrs = new Map();
    const primaryKeys = new Map();
    const forwardIdents = new Map();
    const revIdents = new Map();
    for (const attr of Object.values(attrs)){
        const fwdIdent = attr['forward-identity'];
        const [_, fwdEtype, fwdLabel] = fwdIdent;
        const revIdent = attr['reverse-identity'];
        setInMap(forwardIdents, [
            fwdEtype,
            fwdLabel
        ], attr);
        if (isBlob(attr)) {
            setInMap(blobAttrs, [
                fwdEtype,
                fwdLabel
            ], attr);
        }
        if (attr['primary?']) {
            setInMap(primaryKeys, [
                fwdEtype
            ], attr);
        }
        if (revIdent) {
            const [_, revEtype, revLabel] = revIdent;
            setInMap(revIdents, [
                revEtype,
                revLabel
            ], attr);
        }
    }
    return {
        blobAttrs,
        primaryKeys,
        forwardIdents,
        revIdents
    };
}
function toJSON(store) {
    return {
        __type: store.__type,
        attrs: store.attrs,
        triples: allMapValues(store.eav, 3),
        cardinalityInference: store.cardinalityInference,
        linkIndex: store.linkIndex
    };
}
function fromJSON(storeJSON) {
    return createStore(storeJSON.attrs, storeJSON.triples, storeJSON.cardinalityInference, storeJSON.linkIndex);
}
function resetAttrIndexes(store) {
    store.attrIndexes = createAttrIndexes(store.attrs);
}
function createStore(attrs, triples, enableCardinalityInference, linkIndex) {
    const store = createTripleIndexes(attrs, triples);
    store.attrs = attrs;
    store.attrIndexes = createAttrIndexes(attrs);
    store.cardinalityInference = enableCardinalityInference;
    store.linkIndex = linkIndex;
    store.__type = 'store';
    return store;
}
// We may have local triples with lookup refs in them,
// we need to convert those lookup refs to eids to insert them
// into the store. If we can't find the lookup ref locally,
// then we drop the triple and have to wait for the server response
// to see the optimistic updates.
function resolveLookupRefs(store, triple) {
    var _a, _b;
    let eid;
    // Check if `e` is a lookup ref
    if (Array.isArray(triple[0])) {
        const [a, v] = triple[0];
        const eMaps = store.aev.get(a);
        if (!eMaps) {
            // We don't have the attr, so don't try to add the
            // triple to the store
            return null;
        }
        // This would be a lot more efficient with a ave index
        const triples = allMapValues(eMaps, 2);
        eid = (_a = triples.find((x)=>x[2] === v)) === null || _a === void 0 ? void 0 : _a[0];
    } else {
        eid = triple[0];
    }
    if (!eid) {
        // We don't know the eid that the ref refers to, so
        // we can't add the triple to the store.
        return null;
    }
    // Check if v is a lookup ref
    const lookupV = triple[2];
    if (Array.isArray(lookupV) && lookupV.length === 2 && store.aev.get(lookupV[0])) {
        const [a, v] = lookupV;
        const eMaps = store.aev.get(a);
        if (!eMaps) {
            // We don't have the attr, so don't try to add the
            // triple to the store
            return null;
        }
        const triples = allMapValues(eMaps, 2);
        const value = (_b = triples.find((x)=>x[2] === v)) === null || _b === void 0 ? void 0 : _b[0];
        if (!value) {
            return null;
        }
        const [_e, aid, _v, ...rest] = triple;
        return [
            eid,
            aid,
            value,
            ...rest
        ];
    } else {
        const [_, ...rest] = triple;
        return [
            eid,
            ...rest
        ];
    }
}
function retractTriple(store, rawTriple) {
    const triple = resolveLookupRefs(store, rawTriple);
    if (!triple) {
        return;
    }
    const [eid, aid, v] = triple;
    const attr = getAttr(store.attrs, aid);
    if (!attr) {
        return;
    }
    deleteInMap(store.eav, [
        eid,
        aid,
        v
    ]);
    deleteInMap(store.aev, [
        aid,
        eid,
        v
    ]);
    if (isRef(attr)) {
        deleteInMap(store.vae, [
            v,
            aid,
            eid
        ]);
    }
}
let _seed = 0;
function getCreatedAt(store, attr, triple) {
    const [eid, aid, v] = triple;
    let createdAt;
    const t = getInMap(store.ea, [
        eid,
        aid,
        v
    ]);
    if (t) {
        createdAt = t[3];
    }
    /**
     * (XXX)
     * Two hacks here, for generating a `createdAt`
     *
     * 1. We multiply Date.now() by 10, to make sure that
     *  `createdAt` is always greater than anything the server
     *   could return
     *
     *   We do this because right now we know we _only_ insert
     *   triples as optimistic updates.
     *
     * 2. We increment by `_seed`, to make sure there are no
     *    two triples with the same `createdAt`. This is
     *    done to make tests more predictable.
     *
     * We may need to rethink this. Because we * 10, we can't
     * use this value as an _actual_ `createdAt` timestamp.
     * Eventually we may want too though; For example, we could
     * use `createdAt` for each triple, to infer a `createdAt` and
     * `updatedAt` value for each object.
     */ return createdAt || Date.now() * 10 + _seed++;
}
function addTriple(store, rawTriple) {
    var _a;
    const triple = resolveLookupRefs(store, rawTriple);
    if (!triple) {
        return;
    }
    const [eid, aid, v] = triple;
    const attr = getAttr(store.attrs, aid);
    if (!attr) {
        // (XXX): Due to the way we're handling attrs, it's
        // possible to enter a state where we receive a triple without an attr.
        // See: https://github.com/jsventures/instant-local/pull/132 for details.
        // For now, if we receive a command without an attr, we no-op.
        return;
    }
    const existingTriple = getInMap(store.eav, [
        eid,
        aid,
        v
    ]);
    // Reuse the created_at for a triple if it's already in the store.
    // Prevents updates from temporarily pushing an entity to the top
    // while waiting for the server response.
    const t = (_a = existingTriple === null || existingTriple === void 0 ? void 0 : existingTriple[3]) !== null && _a !== void 0 ? _a : getCreatedAt(store, attr, triple);
    const enhancedTriple = [
        eid,
        aid,
        v,
        t
    ];
    if (hasEA(attr)) {
        setInMap(store.eav, [
            eid,
            aid
        ], new Map([
            [
                v,
                enhancedTriple
            ]
        ]));
        setInMap(store.aev, [
            aid,
            eid
        ], new Map([
            [
                v,
                enhancedTriple
            ]
        ]));
    } else {
        setInMap(store.eav, [
            eid,
            aid,
            v
        ], enhancedTriple);
        setInMap(store.aev, [
            aid,
            eid,
            v
        ], enhancedTriple);
    }
    if (isRef(attr)) {
        setInMap(store.vae, [
            v,
            aid,
            eid
        ], enhancedTriple);
    }
}
function mergeTriple(store, rawTriple) {
    var _a;
    const triple = resolveLookupRefs(store, rawTriple);
    if (!triple) {
        return;
    }
    const [eid, aid, update] = triple;
    const attr = getAttr(store.attrs, aid);
    if (!attr) return;
    if (!isBlob(attr)) throw new Error('merge operation is not supported for links');
    const eavValuesMap = getInMap(store.eav, [
        eid,
        aid
    ]);
    if (!eavValuesMap) return;
    const currentTriple = (_a = eavValuesMap.values().next()) === null || _a === void 0 ? void 0 : _a.value;
    if (!currentTriple) return;
    const currentValue = currentTriple[2];
    const updatedValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["immutableDeepMerge"])(currentValue, update);
    const enhancedTriple = [
        eid,
        aid,
        updatedValue,
        getCreatedAt(store, attr, currentTriple)
    ];
    setInMap(store.eav, [
        eid,
        aid
    ], new Map([
        [
            updatedValue,
            enhancedTriple
        ]
    ]));
}
function deleteEntity(store, args) {
    var _a, _b;
    const [lookup, etype] = args;
    const triple = resolveLookupRefs(store, [
        lookup
    ]);
    if (!triple) {
        return;
    }
    const [id] = triple;
    // delete forward links and attributes + cardinality one links
    const eMap = store.eav.get(id);
    if (eMap) {
        for (const a of eMap.keys()){
            const attr = store.attrs[a];
            // delete cascade refs
            if (attr && attr['on-delete-reverse'] === 'cascade') {
                allMapValues(eMap.get(a), 1).forEach(([e, a, v])=>{
                    var _a;
                    return deleteEntity(store, [
                        v,
                        (_a = attr['reverse-identity']) === null || _a === void 0 ? void 0 : _a[1]
                    ]);
                });
            }
            if (// Fall back to deleting everything if we've rehydrated tx-steps from
            // the store that didn't set `etype` in deleteEntity
            !etype || // If we don't know about the attr, let's just get rid of it
            !attr || // Make sure it matches the etype
            ((_a = attr['forward-identity']) === null || _a === void 0 ? void 0 : _a[1]) === etype) {
                deleteInMap(store.aev, [
                    a,
                    id
                ]);
                deleteInMap(store.eav, [
                    id,
                    a
                ]);
            }
        }
        // Clear out the eav index for `id` if we deleted all of the attributes
        if (eMap.size === 0) {
            deleteInMap(store.eav, [
                id
            ]);
        }
    }
    // delete reverse links
    const vaeTriples = store.vae.get(id) && allMapValues(store.vae.get(id), 2);
    if (vaeTriples) {
        vaeTriples.forEach((triple)=>{
            var _a, _b;
            const [e, a, v] = triple;
            const attr = store.attrs[a];
            if (!etype || !attr || ((_a = attr['reverse-identity']) === null || _a === void 0 ? void 0 : _a[1]) === etype) {
                deleteInMap(store.eav, [
                    e,
                    a,
                    v
                ]);
                deleteInMap(store.aev, [
                    a,
                    e,
                    v
                ]);
                deleteInMap(store.vae, [
                    v,
                    a,
                    e
                ]);
            }
            if (attr && attr['on-delete'] === 'cascade') {
                deleteEntity(store, [
                    e,
                    (_b = attr['forward-identity']) === null || _b === void 0 ? void 0 : _b[1]
                ]);
            }
        });
    }
    // Clear out vae index for `id` if we deleted all the reverse attributes
    if (((_b = store.vae.get(id)) === null || _b === void 0 ? void 0 : _b.size) === 0) {
        deleteInMap(store.vae, [
            id
        ]);
    }
}
// (XXX): Whenever we change/delete attrs,
// We indiscriminately reset the index map.
// There are lots of opportunities for optimization:
// * We _only_ need to run this indexes change. We could detect that
// * We could batch this reset at the end
// * We could add an ave index for all triples, so removing the
//   right triples is easy and fast.
function resetIndexMap(store, newTriples) {
    const newIndexMap = createTripleIndexes(store.attrs, newTriples);
    Object.keys(newIndexMap).forEach((key)=>{
        store[key] = newIndexMap[key];
    });
}
function addAttr(store, [attr]) {
    store.attrs[attr.id] = attr;
    resetAttrIndexes(store);
}
function getAllTriples(store) {
    return allMapValues(store.eav, 3);
}
function deleteAttr(store, [id]) {
    if (!store.attrs[id]) return;
    const newTriples = getAllTriples(store).filter(([_, aid])=>aid !== id);
    delete store.attrs[id];
    resetAttrIndexes(store);
    resetIndexMap(store, newTriples);
}
function updateAttr(store, [partialAttr]) {
    const attr = store.attrs[partialAttr.id];
    if (!attr) return;
    store.attrs[partialAttr.id] = Object.assign(Object.assign({}, attr), partialAttr);
    resetAttrIndexes(store);
    resetIndexMap(store, getAllTriples(store));
}
function applyTxStep(store, txStep) {
    const [action, ...args] = txStep;
    switch(action){
        case 'add-triple':
            addTriple(store, args);
            break;
        case 'deep-merge-triple':
            mergeTriple(store, args);
            break;
        case 'retract-triple':
            retractTriple(store, args);
            break;
        case 'delete-entity':
            deleteEntity(store, args);
            break;
        case 'add-attr':
            addAttr(store, args);
            break;
        case 'delete-attr':
            deleteAttr(store, args);
            break;
        case 'update-attr':
            updateAttr(store, args);
            break;
        default:
            throw new Error(`unhandled transaction action: ${action}`);
    }
}
function allMapValues(m, level, res = []) {
    if (!m) {
        return res;
    }
    if (level === 0) {
        return res;
    }
    if (level === 1) {
        for (const v of m.values()){
            res.push(v);
        }
        return res;
    }
    for (const v of m.values()){
        allMapValues(v, level - 1, res);
    }
    return res;
}
function triplesByValue(store, m, v) {
    var _a, _b;
    const res = [];
    if (v === null || v === void 0 ? void 0 : v.hasOwnProperty('$not')) {
        for (const candidate of m.keys()){
            if (v.$not !== candidate) {
                res.push(m.get(candidate));
            }
        }
        return res;
    }
    if (v === null || v === void 0 ? void 0 : v.hasOwnProperty('$isNull')) {
        const { attrId, isNull, reverse } = v.$isNull;
        if (reverse) {
            for (const candidate of m.keys()){
                const vMap = store.vae.get(candidate);
                const isValNull = !vMap || ((_a = vMap.get(attrId)) === null || _a === void 0 ? void 0 : _a.get(null)) || !vMap.get(attrId);
                if (isNull ? isValNull : !isValNull) {
                    res.push(m.get(candidate));
                }
            }
        } else {
            const aMap = store.aev.get(attrId);
            for (const candidate of m.keys()){
                const isValNull = !aMap || ((_b = aMap.get(candidate)) === null || _b === void 0 ? void 0 : _b.get(null)) || !aMap.get(candidate);
                if (isNull ? isValNull : !isValNull) {
                    res.push(m.get(candidate));
                }
            }
        }
        return res;
    }
    if (v === null || v === void 0 ? void 0 : v.$comparator) {
        // TODO: A sorted index would be nice here
        return allMapValues(m, 1).filter(v.$op);
    }
    const values = v.in || v.$in || [
        v
    ];
    for (const value of values){
        const triple = m.get(value);
        if (triple) {
            res.push(triple);
        }
    }
    return res;
}
// A poor man's pattern matching
// Returns either eav, ea, ev, av, v, or ''
function whichIdx(e, a, v) {
    let res = '';
    if (e !== undefined) {
        res += 'e';
    }
    if (a !== undefined) {
        res += 'a';
    }
    if (v !== undefined) {
        res += 'v';
    }
    return res;
}
function getTriples(store, [e, a, v]) {
    var _a, _b;
    const idx = whichIdx(e, a, v);
    switch(idx){
        case 'e':
            {
                const eMap = store.eav.get(e);
                return allMapValues(eMap, 2);
            }
        case 'ea':
            {
                const aMap = (_a = store.eav.get(e)) === null || _a === void 0 ? void 0 : _a.get(a);
                return allMapValues(aMap, 1);
            }
        case 'eav':
            {
                const aMap = (_b = store.eav.get(e)) === null || _b === void 0 ? void 0 : _b.get(a);
                if (!aMap) {
                    return [];
                }
                return triplesByValue(store, aMap, v);
            }
        case 'ev':
            {
                const eMap = store.eav.get(e);
                if (!eMap) {
                    return [];
                }
                const res = [];
                for (const aMap of eMap.values()){
                    res.push(...triplesByValue(store, aMap, v));
                }
                return res;
            }
        case 'a':
            {
                const aMap = store.aev.get(a);
                return allMapValues(aMap, 2);
            }
        case 'av':
            {
                const aMap = store.aev.get(a);
                if (!aMap) {
                    return [];
                }
                const res = [];
                for (const eMap of aMap.values()){
                    res.push(...triplesByValue(store, eMap, v));
                }
                return res;
            }
        case 'v':
            {
                const res = [];
                for (const eMap of store.eav.values()){
                    for (const aMap of eMap.values()){
                        res.push(...triplesByValue(store, aMap, v));
                    }
                }
            }
        default:
            {
                return allMapValues(store.eav, 3);
            }
    }
}
function getAsObject(store, etype, e) {
    var _a;
    const blobAttrs = store.attrIndexes.blobAttrs.get(etype);
    const obj = {};
    for (const [label, attr] of blobAttrs.entries()){
        const aMap = (_a = store.eav.get(e)) === null || _a === void 0 ? void 0 : _a.get(attr.id);
        const triples = allMapValues(aMap, 1);
        for (const triple of triples){
            obj[label] = triple[2];
        }
    }
    return obj;
}
function getAttrByFwdIdentName(store, inputEtype, inputLabel) {
    var _a;
    return (_a = store.attrIndexes.forwardIdents.get(inputEtype)) === null || _a === void 0 ? void 0 : _a.get(inputLabel);
}
function getAttrByReverseIdentName(store, inputEtype, inputLabel) {
    var _a;
    return (_a = store.attrIndexes.revIdents.get(inputEtype)) === null || _a === void 0 ? void 0 : _a.get(inputLabel);
}
function getPrimaryKeyAttr(store, etype) {
    var _a;
    const fromPrimary = store.attrIndexes.primaryKeys.get(etype);
    if (fromPrimary) {
        return fromPrimary;
    }
    return (_a = store.attrIndexes.forwardIdents.get(etype)) === null || _a === void 0 ? void 0 : _a.get('id');
}
function transact(store, txSteps) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$mutative$2f$dist$2f$mutative$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])(store, (draft)=>{
        txSteps.forEach((txStep)=>{
            applyTxStep(draft, txStep);
        });
    });
} //# sourceMappingURL=store.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/datalog.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// 1. patternMatch
__turbopack_esm__({
    "matchPattern": (()=>matchPattern),
    "query": (()=>query),
    "querySingle": (()=>querySingle),
    "queryWhere": (()=>queryWhere)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/store.js [app-client] (ecmascript)");
;
function isVariable(x) {
    return typeof x === 'string' && x.startsWith('?');
}
function matchVariable(variable, triplePart, context) {
    if (context.hasOwnProperty(variable)) {
        const bound = context[variable];
        return matchPart(bound, triplePart, context);
    }
    return Object.assign(Object.assign({}, context), {
        [variable]: triplePart
    });
}
function matchExact(patternPart, triplePart, context) {
    return patternPart === triplePart ? context : null;
}
function matcherForPatternPart(patternPart) {
    switch(typeof patternPart){
        case 'string':
            return patternPart.startsWith('?') ? matchVariable : matchExact;
        default:
            return matchExact;
    }
}
const validArgMapProps = [
    'in',
    '$in',
    '$not',
    '$isNull',
    '$comparator'
];
// Checks if an object is an args map
function isArgsMap(patternPart) {
    for (const prop of validArgMapProps){
        if (patternPart.hasOwnProperty(prop)) {
            return true;
        }
    }
    return false;
}
function matchPart(patternPart, triplePart, context) {
    if (!context) return null;
    if (typeof patternPart === 'object') {
        // This is an args map, so we'll have already fitered the triples
        // in `getRelevantTriples`
        if (isArgsMap(patternPart)) {
            return context;
        }
        return null;
    }
    const matcher = matcherForPatternPart(patternPart);
    return matcher(patternPart, triplePart, context);
}
function matchPattern(pattern, triple, context) {
    return pattern.reduce((context, patternPart, idx)=>{
        const triplePart = triple[idx];
        return matchPart(patternPart, triplePart, context);
    }, context);
}
function querySingle(store, pattern, context) {
    return relevantTriples(store, pattern, context).map((triple)=>matchPattern(pattern, triple, context)).filter((x)=>x);
}
// 3. queryWhere
function queryPattern(store, pattern, contexts) {
    if (pattern.or) {
        return pattern.or.patterns.flatMap((patterns)=>{
            return queryWhere(store, patterns, contexts);
        });
    }
    if (pattern.and) {
        return pattern.and.patterns.reduce((contexts, patterns)=>{
            return queryWhere(store, patterns, contexts);
        }, contexts);
    }
    return contexts.flatMap((context)=>querySingle(store, pattern, context));
}
function queryWhere(store, patterns, contexts = [
    {}
]) {
    return patterns.reduce((contexts, pattern)=>{
        return queryPattern(store, pattern, contexts);
    }, contexts);
}
// 4. query
function actualize(context, find) {
    if (Array.isArray(find)) {
        return find.map((findPart)=>actualize(context, findPart));
    }
    return isVariable(find) ? context[find] : find;
}
function query(store, { find, where }) {
    const contexts = queryWhere(store, where);
    return contexts.map((context)=>actualize(context, find));
}
// 5. Index
function relevantTriples(store, pattern, context) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTriples"])(store, actualize(context, pattern));
} //# sourceMappingURL=datalog.js.map
}}),
"[project]/Documents/instant-demo/node_modules/uuid/dist/esm-browser/native.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const __TURBOPACK__default__export__ = {
    randomUUID
};
}}),
"[project]/Documents/instant-demo/node_modules/uuid/dist/esm-browser/rng.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
__turbopack_esm__({
    "default": (()=>rng)
});
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
    // lazy load so that environments that need to polyfill have a chance to do so
    if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
        getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
        if (!getRandomValues) {
            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
    }
    return getRandomValues(rnds8);
}
}}),
"[project]/Documents/instant-demo/node_modules/uuid/dist/esm-browser/regex.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
}}),
"[project]/Documents/instant-demo/node_modules/uuid/dist/esm-browser/validate.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$regex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/uuid/dist/esm-browser/regex.js [app-client] (ecmascript)");
;
function validate(uuid) {
    return typeof uuid === 'string' && __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$regex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].test(uuid);
}
const __TURBOPACK__default__export__ = validate;
}}),
"[project]/Documents/instant-demo/node_modules/uuid/dist/esm-browser/stringify.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__),
    "unsafeStringify": (()=>unsafeStringify)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$validate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/uuid/dist/esm-browser/validate.js [app-client] (ecmascript)");
;
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */ const byteToHex = [];
for(let i = 0; i < 256; ++i){
    byteToHex.push((i + 0x100).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
    // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$validate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(uuid)) {
        throw TypeError('Stringified UUID is invalid');
    }
    return uuid;
}
const __TURBOPACK__default__export__ = stringify;
}}),
"[project]/Documents/instant-demo/node_modules/uuid/dist/esm-browser/v4.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$native$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/uuid/dist/esm-browser/native.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$rng$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/uuid/dist/esm-browser/rng.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/uuid/dist/esm-browser/stringify.js [app-client] (ecmascript)");
;
;
;
function v4(options, buf, offset) {
    if (__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$native$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].randomUUID && !buf && !options) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$native$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$rng$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
    if (buf) {
        offset = offset || 0;
        for(let i = 0; i < 16; ++i){
            buf[offset + i] = rnds[i];
        }
        return buf;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unsafeStringify"])(rnds);
}
const __TURBOPACK__default__export__ = v4;
}}),
"[project]/Documents/instant-demo/node_modules/uuid/dist/esm-browser/v4.js [app-client] (ecmascript) <export default as v4>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "v4": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/uuid/dist/esm-browser/v4.js [app-client] (ecmascript)");
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/uuid.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__),
    "uuidCompare": (()=>uuidCompare)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/uuid/dist/esm-browser/v4.js [app-client] (ecmascript) <export default as v4>");
;
function uuidToByteArray(uuid) {
    const hex = uuid.replace(/-/g, '');
    const bytes = [];
    for(let i = 0; i < hex.length; i += 2){
        bytes.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return bytes;
}
function compareByteArrays(a, b) {
    for(let i = 0; i < a.length; i++){
        if (a[i] < b[i]) return -1;
        if (a[i] > b[i]) return 1;
    }
    return 0;
}
function uuidCompare(uuid_a, uuid_b) {
    return compareByteArrays(uuidToByteArray(uuid_a), uuidToByteArray(uuid_b));
}
function id() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__["v4"])();
}
const __TURBOPACK__default__export__ = id;
 //# sourceMappingURL=uuid.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/instaql.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>query)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$datalog$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/datalog.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$uuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/uuid.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/store.js [app-client] (ecmascript)");
;
;
;
// Pattern variables
// -----------------
let _seed = 0;
function wildcard(friendlyName) {
    return makeVarImpl(`_${friendlyName}`, _seed++);
}
function makeVarImpl(x, level) {
    return `?${x}-${level}`;
}
// Where
// -----------------
class AttrNotFoundError extends Error {
    constructor(message){
        super(message);
        this.name = 'AttrNotFoundError';
    }
}
function idAttr(store, ns) {
    const attr = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.getPrimaryKeyAttr(store, ns);
    if (!attr) {
        throw new AttrNotFoundError(`Could not find id attr for ${ns}`);
    }
    return attr;
}
function defaultWhere(makeVar, store, etype, level) {
    return [
        eidWhere(makeVar, store, etype, level)
    ];
}
function eidWhere(makeVar, store, etype, level) {
    return [
        makeVar(etype, level),
        idAttr(store, etype).id,
        makeVar(etype, level),
        makeVar('time', level)
    ];
}
function replaceInAttrPat(attrPat, needle, v) {
    return attrPat.map((x)=>x === needle ? v : x);
}
function refAttrPat(makeVar, store, etype, level, label) {
    const fwdAttr = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.getAttrByFwdIdentName(store, etype, label);
    const revAttr = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.getAttrByReverseIdentName(store, etype, label);
    const attr = fwdAttr || revAttr;
    if (!attr) {
        throw new AttrNotFoundError(`Could not find attr for ${[
            etype,
            label
        ]}`);
    }
    if (attr['value-type'] !== 'ref') {
        throw new Error(`Attr ${attr.id} is not a ref`);
    }
    const [_f, fwdEtype] = attr['forward-identity'];
    const [_r, revEtype] = attr['reverse-identity'];
    const nextLevel = level + 1;
    const attrPat = fwdAttr ? [
        makeVar(fwdEtype, level),
        attr.id,
        makeVar(revEtype, nextLevel),
        wildcard('time')
    ] : [
        makeVar(fwdEtype, nextLevel),
        attr.id,
        makeVar(revEtype, level),
        wildcard('time')
    ];
    const nextEtype = fwdAttr ? revEtype : fwdEtype;
    const isForward = Boolean(fwdAttr);
    return [
        nextEtype,
        nextLevel,
        attrPat,
        attr,
        isForward
    ];
}
function makeLikeMatcher(caseSensitive, pattern) {
    if (typeof pattern !== 'string') {
        return function likeMatcher(_value) {
            return false;
        };
    }
    const escapedPattern = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regexPattern = escapedPattern.replace(/%/g, '.*').replace(/_/g, '.');
    const regex = new RegExp(`^${regexPattern}$`, caseSensitive ? undefined : 'i');
    return function likeMatcher(value) {
        if (typeof value !== 'string') {
            return false;
        }
        return regex.test(value);
    };
}
function parseValue(attr, v) {
    if (typeof v !== 'object' || v.hasOwnProperty('$in') || v.hasOwnProperty('in')) {
        return v;
    }
    const isDate = attr['checked-data-type'] === 'date';
    if (v.hasOwnProperty('$gt')) {
        return {
            $comparator: true,
            $op: isDate ? function gtDate(triple) {
                return new Date(triple[2]) > new Date(v.$gt);
            } : function gt(triple) {
                return triple[2] > v.$gt;
            }
        };
    }
    if (v.hasOwnProperty('$gte')) {
        return {
            $comparator: true,
            $op: isDate ? function gteDate(triple) {
                return new Date(triple[2]) >= new Date(v.$gte);
            } : function gte(triple) {
                return triple[2] >= v.$gte;
            }
        };
    }
    if (v.hasOwnProperty('$lt')) {
        return {
            $comparator: true,
            $op: isDate ? function ltDate(triple) {
                return new Date(triple[2]) < new Date(v.$lt);
            } : function lt(triple) {
                return triple[2] < v.$lt;
            }
        };
    }
    if (v.hasOwnProperty('$lte')) {
        return {
            $comparator: true,
            $op: isDate ? function lteDate(triple) {
                return new Date(triple[2]) <= new Date(v.$lte);
            } : function lte(triple) {
                return triple[2] <= v.$lte;
            }
        };
    }
    if (v.hasOwnProperty('$like')) {
        const matcher = makeLikeMatcher(true, v.$like);
        return {
            $comparator: true,
            $op: function like(triple) {
                return matcher(triple[2]);
            }
        };
    }
    if (v.hasOwnProperty('$ilike')) {
        const matcher = makeLikeMatcher(false, v.$ilike);
        return {
            $comparator: true,
            $op: function ilike(triple) {
                return matcher(triple[2]);
            }
        };
    }
    return v;
}
function valueAttrPat(makeVar, store, valueEtype, valueLevel, valueLabel, v) {
    const fwdAttr = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.getAttrByFwdIdentName(store, valueEtype, valueLabel);
    const revAttr = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.getAttrByReverseIdentName(store, valueEtype, valueLabel);
    const attr = fwdAttr || revAttr;
    if (!attr) {
        throw new AttrNotFoundError(`No attr for etype = ${valueEtype} label = ${valueLabel}`);
    }
    if (v === null || v === void 0 ? void 0 : v.hasOwnProperty('$isNull')) {
        const idAttr = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.getAttrByFwdIdentName(store, valueEtype, 'id');
        if (!idAttr) {
            throw new AttrNotFoundError(`No attr for etype = ${valueEtype} label = id`);
        }
        return [
            makeVar(valueEtype, valueLevel),
            idAttr.id,
            {
                $isNull: {
                    attrId: attr.id,
                    isNull: v.$isNull,
                    reverse: !fwdAttr
                }
            },
            wildcard('time')
        ];
    }
    if (fwdAttr) {
        return [
            makeVar(valueEtype, valueLevel),
            attr.id,
            parseValue(attr, v),
            wildcard('time')
        ];
    }
    return [
        v,
        attr.id,
        makeVar(valueEtype, valueLevel),
        wildcard('time')
    ];
}
function refAttrPats(makeVar, store, etype, level, refsPath) {
    const [lastEtype, lastLevel, attrPats] = refsPath.reduce((acc, label)=>{
        const [etype, level, attrPats] = acc;
        const [nextEtype, nextLevel, attrPat] = refAttrPat(makeVar, store, etype, level, label);
        return [
            nextEtype,
            nextLevel,
            [
                ...attrPats,
                attrPat
            ]
        ];
    }, [
        etype,
        level,
        []
    ]);
    return [
        lastEtype,
        lastLevel,
        attrPats
    ];
}
function whereCondAttrPats(makeVar, store, etype, level, path, v) {
    const refsPath = path.slice(0, path.length - 1);
    const valueLabel = path[path.length - 1];
    const [lastEtype, lastLevel, refPats] = refAttrPats(makeVar, store, etype, level, refsPath);
    const valuePat = valueAttrPat(makeVar, store, lastEtype, lastLevel, valueLabel, v);
    return refPats.concat([
        valuePat
    ]);
}
function withJoin(where, join) {
    return join ? [
        join
    ].concat(where) : where;
}
function isOrClauses([k, v]) {
    return k === 'or' && Array.isArray(v);
}
function isAndClauses([k, v]) {
    return k === 'and' && Array.isArray(v);
}
// Creates a makeVar that will namespace symbols for or clauses
// to prevent conflicts, except for the base etype
function genMakeVar(baseMakeVar, joinSym, orIdx) {
    return (x, lvl)=>{
        const base = baseMakeVar(x, lvl);
        if (joinSym == base) {
            return base;
        }
        return `${base}-${orIdx}`;
    };
}
function parseWhereClauses(makeVar, clauseType /* 'or' | 'and' */ , store, etype, level, whereValue) {
    const joinSym = makeVar(etype, level);
    const patterns = whereValue.map((w, i)=>{
        const makeNamespacedVar = genMakeVar(makeVar, joinSym, i);
        return parseWhere(makeNamespacedVar, store, etype, level, w);
    });
    return {
        [clauseType]: {
            patterns,
            joinSym
        }
    };
}
// Given a path, returns a list of paths leading up to this path:
// growPath([1, 2, 3]) -> [[1], [1, 2], [1, 2, 3]]
function growPath(path) {
    const ret = [];
    for(let i = 1; i <= path.length; i++){
        ret.push(path.slice(0, i));
    }
    return ret;
}
// Returns array of pattern arrays that should be grouped in OR
// to capture any intermediate nulls
function whereCondAttrPatsForNullIsTrue(makeVar, store, etype, level, path) {
    return growPath(path).map((path)=>whereCondAttrPats(makeVar, store, etype, level, path, {
            $isNull: true
        }));
}
function parseWhere(makeVar, store, etype, level, where) {
    return Object.entries(where).flatMap(([k, v])=>{
        if (isOrClauses([
            k,
            v
        ])) {
            return parseWhereClauses(makeVar, 'or', store, etype, level, v);
        }
        if (isAndClauses([
            k,
            v
        ])) {
            return parseWhereClauses(makeVar, 'and', store, etype, level, v);
        }
        // Temporary hack until we have support for a uuid index on `id`
        if (k === '$entityIdStartsWith') {
            return [];
        }
        const path = k.split('.');
        if (v === null || v === void 0 ? void 0 : v.hasOwnProperty('$not')) {
            // `$not` won't pick up entities that are missing the attr, so we
            // add in a `$isNull` to catch those too.
            const notPats = whereCondAttrPats(makeVar, store, etype, level, path, v);
            const nilPats = whereCondAttrPatsForNullIsTrue(makeVar, store, etype, level, path);
            return [
                {
                    or: {
                        patterns: [
                            notPats,
                            ...nilPats
                        ],
                        joinSym: makeVar(etype, level)
                    }
                }
            ];
        }
        if ((v === null || v === void 0 ? void 0 : v.hasOwnProperty('$isNull')) && v.$isNull === true && path.length > 1) {
            // Make sure we're capturing all of the intermediate paths that might be null
            // by checking for null at each step along the path
            return [
                {
                    or: {
                        patterns: whereCondAttrPatsForNullIsTrue(makeVar, store, etype, level, path),
                        joinSym: makeVar(etype, level)
                    }
                }
            ];
        }
        return whereCondAttrPats(makeVar, store, etype, level, path, v);
    });
}
function makeWhere(store, etype, level, where) {
    const makeVar = makeVarImpl;
    if (!where) {
        return defaultWhere(makeVar, store, etype, level);
    }
    const parsedWhere = parseWhere(makeVar, store, etype, level, where);
    return parsedWhere.concat(defaultWhere(makeVar, store, etype, level));
}
// Find
// -----------------
function makeFind(makeVar, etype, level) {
    return [
        makeVar(etype, level),
        makeVar('time', level)
    ];
}
// extendObjects
// -----------------
function makeJoin(makeVar, store, etype, level, label, eid) {
    const [nextEtype, nextLevel, pat, attr, isForward] = refAttrPat(makeVar, store, etype, level, label);
    const actualized = replaceInAttrPat(pat, makeVar(etype, level), eid);
    return [
        nextEtype,
        nextLevel,
        actualized,
        attr,
        isForward
    ];
}
function extendObjects(makeVar, store, { etype, level, form }, objects) {
    const childQueries = Object.keys(form).filter((c)=>c !== '$');
    if (!childQueries.length) {
        return Object.values(objects);
    }
    return Object.entries(objects).map(function extendChildren([eid, parent]) {
        const childResults = childQueries.map(function getChildResult(label) {
            var _a, _b, _c;
            const isSingular = Boolean(store.cardinalityInference && ((_c = (_b = (_a = store.linkIndex) === null || _a === void 0 ? void 0 : _a[etype]) === null || _b === void 0 ? void 0 : _b[label]) === null || _c === void 0 ? void 0 : _c.isSingular));
            try {
                const [nextEtype, nextLevel, join] = makeJoin(makeVar, store, etype, level, label, eid);
                const childrenArray = queryOne(store, {
                    etype: nextEtype,
                    level: nextLevel,
                    form: form[label],
                    join
                });
                const childOrChildren = isSingular ? childrenArray[0] : childrenArray;
                return {
                    [label]: childOrChildren
                };
            } catch (e) {
                if (e instanceof AttrNotFoundError) {
                    return {
                        [label]: isSingular ? undefined : []
                    };
                }
                throw e;
            }
        });
        return childResults.reduce(function reduceChildren(parent, child) {
            return Object.assign(Object.assign({}, parent), child);
        }, parent);
    });
}
// resolveObjects
// -----------------
function shouldIgnoreAttr(attrs, id) {
    const attr = attrs[id];
    return attr['value-type'] === 'ref' && attr['forward-identity'][2] !== 'id';
}
function compareOrder([id_a, v_a], [id_b, v_b]) {
    if (v_a === v_b || v_a == null && v_b == null) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$uuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uuidCompare"])(id_a, id_b);
    }
    if (v_b == null) {
        return 1;
    }
    if (v_a == null) {
        return -1;
    }
    if (v_a > v_b) {
        return 1;
    }
    return -1;
}
function comparableDate(x) {
    if (x == null) {
        return x;
    }
    return new Date(x).getTime();
}
function isBefore(startCursor, orderAttr, direction, idVec) {
    var _a;
    const [c_e, _c_a, c_v, c_t] = startCursor;
    const compareVal = direction === 'desc' ? 1 : -1;
    if (((_a = orderAttr['forward-identity']) === null || _a === void 0 ? void 0 : _a[2]) === 'id') {
        return compareOrder(idVec, [
            c_e,
            c_t
        ]) === compareVal;
    }
    const [e, v] = idVec;
    const v_new = orderAttr['checked-data-type'] === 'date' ? comparableDate(v) : v;
    const c_v_new = orderAttr['checked-data-type'] === 'date' ? comparableDate(c_v) : c_v;
    return compareOrder([
        e,
        v_new
    ], [
        c_e,
        c_v_new
    ]) === compareVal;
}
function orderAttrFromCursor(store, cursor) {
    const cursorAttrId = cursor[1];
    return store.attrs[cursorAttrId];
}
function orderAttrFromOrder(store, etype, order) {
    const label = Object.keys(order)[0];
    return __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.getAttrByFwdIdentName(store, etype, label);
}
function getOrderAttr(store, etype, cursor, order) {
    if (cursor) {
        return orderAttrFromCursor(store, cursor);
    }
    if (order) {
        return orderAttrFromOrder(store, etype, order);
    }
}
function runDataloadAndReturnObjects(store, etype, direction, pageInfo, order, dq) {
    var _a;
    let idVecs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$datalog$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["query"])(store, dq);
    const startCursor = pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo['start-cursor'];
    const orderAttr = getOrderAttr(store, etype, startCursor, order);
    if (orderAttr && ((_a = orderAttr === null || orderAttr === void 0 ? void 0 : orderAttr['forward-identity']) === null || _a === void 0 ? void 0 : _a[2]) !== 'id') {
        const isDate = orderAttr['checked-data-type'] === 'date';
        const a = orderAttr.id;
        idVecs = idVecs.map(([id])=>{
            var _a, _b, _c, _d, _e;
            // order attr is required to be cardinality one, so there will
            // be at most one value here
            let v = (_e = (_d = (_c = (_b = (_a = store.eav.get(id)) === null || _a === void 0 ? void 0 : _a.get(a)) === null || _b === void 0 ? void 0 : _b.values()) === null || _c === void 0 ? void 0 : _c.next()) === null || _d === void 0 ? void 0 : _d.value) === null || _e === void 0 ? void 0 : _e[2];
            if (isDate) {
                v = comparableDate(v);
            }
            return [
                id,
                v
            ];
        });
    }
    idVecs.sort(direction === 'asc' ? function compareIdVecs(a, b) {
        return compareOrder(a, b);
    } : function compareIdVecs(a, b) {
        return compareOrder(b, a);
    });
    let objects = {};
    for (const idVec of idVecs){
        const [id] = idVec;
        if (objects[id]) {
            continue;
        }
        if (startCursor && orderAttr && isBefore(startCursor, orderAttr, direction, idVec)) {
            continue;
        }
        const obj = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.getAsObject(store, etype, id);
        if (obj) {
            objects[id] = obj;
        }
    }
    return objects;
}
function determineOrder(form) {
    var _a;
    const orderOpts = (_a = form.$) === null || _a === void 0 ? void 0 : _a.order;
    if (!orderOpts) {
        return 'asc';
    }
    return orderOpts[Object.keys(orderOpts)[0]] || 'asc';
}
/**
 * Given a query like:
 *
 * {
 *   users: {
 *     $: { where: { name: "Joe" } },
 *   },
 * };
 *
 * `resolveObjects`, turns where clause: `{ name: "Joe" }`
 * into a datalog query. We then run the datalog query,
 * and reduce all the triples into objects.
 */ function resolveObjects(store, { etype, level, form, join, pageInfo }) {
    var _a, _b, _c, _d, _e, _g, _h, _j;
    const limit = ((_a = form.$) === null || _a === void 0 ? void 0 : _a.limit) || ((_b = form.$) === null || _b === void 0 ? void 0 : _b.first) || ((_c = form.$) === null || _c === void 0 ? void 0 : _c.last);
    const offset = (_d = form.$) === null || _d === void 0 ? void 0 : _d.offset;
    const before = (_e = form.$) === null || _e === void 0 ? void 0 : _e.before;
    const after = (_g = form.$) === null || _g === void 0 ? void 0 : _g.after;
    const order = (_h = form.$) === null || _h === void 0 ? void 0 : _h.order;
    // Wait for server to tell us where we start if we don't start from the beginning
    if ((offset || before || after) && (!pageInfo || !pageInfo['start-cursor'])) {
        return [];
    }
    const where = withJoin(makeWhere(store, etype, level, (_j = form.$) === null || _j === void 0 ? void 0 : _j.where), join);
    const find = makeFind(makeVarImpl, etype, level);
    const objs = runDataloadAndReturnObjects(store, etype, determineOrder(form), pageInfo, order, {
        where,
        find
    });
    if (limit != null) {
        const entries = Object.entries(objs);
        if (entries.length <= limit) {
            return objs;
        }
        return Object.fromEntries(entries.slice(0, limit));
    }
    return objs;
}
/**
 * It's possible that we query
 * for an attribute that doesn't exist yet.
 *
 * { users: { $: { where: { nonExistentProperty: "foo" } } } }
 *
 * This swallows the missing attr error and returns
 * an empty result instead
 */ function guardedResolveObjects(store, opts) {
    try {
        return resolveObjects(store, opts);
    } catch (e) {
        if (e instanceof AttrNotFoundError) {
            return {};
        }
        throw e;
    }
}
/**
 * Given a query like:
 *
 * {
 *   users: {
 *     $: { where: { name: "Joe" } },
 *     posts: {},
 *   },
 * };
 *
 * `guardResolveObjects` will return the relevant `users` objects
 * `extendObjects` will then extend each `user` object with relevant `posts`.
 */ function queryOne(store, opts) {
    const objects = guardedResolveObjects(store, opts);
    return extendObjects(makeVarImpl, store, opts, objects);
}
function formatPageInfo(pageInfo) {
    const res = {};
    for (const [k, v] of Object.entries(pageInfo)){
        res[k] = {
            startCursor: v['start-cursor'],
            endCursor: v['end-cursor'],
            hasNextPage: v['has-next-page?'],
            hasPreviousPage: v['has-previous-page?']
        };
    }
    return res;
}
function query({ store, pageInfo, aggregate }, q) {
    const data = Object.keys(q).reduce(function reduceResult(res, k) {
        if (aggregate === null || aggregate === void 0 ? void 0 : aggregate[k]) {
            // Aggregate doesn't return any join rows and has no children,
            // so don't bother querying further
            return res;
        }
        res[k] = queryOne(store, {
            etype: k,
            form: q[k],
            level: 0,
            pageInfo: pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo[k]
        });
        return res;
    }, {});
    const result = {
        data
    };
    if (pageInfo) {
        result.pageInfo = formatPageInfo(pageInfo);
    }
    if (aggregate) {
        result.aggregate = aggregate;
    }
    return result;
} //# sourceMappingURL=instaql.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/instatx.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "getOps": (()=>getOps),
    "isLookup": (()=>isLookup),
    "lookup": (()=>lookup),
    "parseLookup": (()=>parseLookup),
    "tx": (()=>tx),
    "txInit": (()=>txInit)
});
function transactionChunk(etype, id, prevOps) {
    return new Proxy({}, {
        get: (_target, cmd)=>{
            if (cmd === '__ops') return prevOps;
            return (args)=>{
                return transactionChunk(etype, id, [
                    ...prevOps,
                    [
                        cmd,
                        etype,
                        id,
                        args
                    ]
                ]);
            };
        }
    });
}
function lookup(attribute, value) {
    return `lookup__${attribute}__${JSON.stringify(value)}`;
}
function isLookup(k) {
    return k.startsWith('lookup__');
}
function parseLookup(k) {
    const [_, attribute, ...vJSON] = k.split('__');
    return [
        attribute,
        JSON.parse(vJSON.join('__'))
    ];
}
function etypeChunk(etype) {
    return new Proxy({}, {
        get (_target, id) {
            if (isLookup(id)) {
                return transactionChunk(etype, parseLookup(id), []);
            }
            return transactionChunk(etype, id, []);
        }
    });
}
function txInit() {
    return new Proxy({}, {
        get (_target, ns) {
            return etypeChunk(ns);
        }
    });
}
const tx = txInit();
function getOps(x) {
    return x.__ops;
} //# sourceMappingURL=instatx.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/instaml.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "getAttrByFwdIdentName": (()=>getAttrByFwdIdentName),
    "getAttrByReverseIdentName": (()=>getAttrByReverseIdentName),
    "rewriteStep": (()=>rewriteStep),
    "transform": (()=>transform)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$instatx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/instatx.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/object.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$uuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/uuid.js [app-client] (ecmascript)");
;
;
;
function rewriteStep(attrMapping, txStep) {
    const { attrIdMap, refSwapAttrIds } = attrMapping;
    const rewritten = [];
    for (const part of txStep){
        const newValue = attrIdMap[part];
        if (newValue) {
            // Rewrites attr id
            rewritten.push(newValue);
        } else if (Array.isArray(part) && part.length == 2 && attrIdMap[part[0]]) {
            // Rewrites attr id in lookups
            const [aid, value] = part;
            rewritten.push([
                attrIdMap[aid],
                value
            ]);
        } else {
            rewritten.push(part);
        }
    }
    const [action] = txStep;
    if ((action === 'add-triple' || action === 'retract-triple') && refSwapAttrIds.has(txStep[2])) {
        // Reverse links if the optimistic link attr is backwards
        const tmp = rewritten[1];
        rewritten[1] = rewritten[3];
        rewritten[3] = tmp;
    }
    return rewritten;
}
function getAttrByFwdIdentName(attrs, inputEtype, inputIdentName) {
    return Object.values(attrs).find((attr)=>{
        const [_id, etype, label] = attr['forward-identity'];
        return etype === inputEtype && label === inputIdentName;
    });
}
function getAttrByReverseIdentName(attrs, inputEtype, inputIdentName) {
    return Object.values(attrs).find((attr)=>{
        const revIdent = attr['reverse-identity'];
        if (!revIdent) return false;
        const [_id, etype, label] = revIdent;
        return etype === inputEtype && label === inputIdentName;
    });
}
function explodeLookupRef(eid) {
    if (Array.isArray(eid)) {
        return eid;
    }
    const entries = Object.entries(eid);
    if (entries.length !== 1) {
        throw new Error('lookup must be an object with a single unique attr and value.');
    }
    return entries[0];
}
function isRefLookupIdent(attrs, etype, identName) {
    return identName.indexOf('.') !== -1 && // attr names can have `.` in them, so use the attr we find with a `.`
    // before assuming it's a ref lookup.
    !getAttrByFwdIdentName(attrs, etype, identName);
}
function extractRefLookupFwdName(identName) {
    const [fwdName, idIdent, ...rest] = identName.split('.');
    if (rest.length > 0 || idIdent !== 'id') {
        throw new Error(`${identName} is not a valid lookup attribute.`);
    }
    return fwdName;
}
function lookupIdentToAttr(attrs, etype, identName) {
    if (!isRefLookupIdent(attrs, etype, identName)) {
        return getAttrByFwdIdentName(attrs, etype, identName);
    }
    const fwdName = extractRefLookupFwdName(identName);
    const refAttr = getAttrByFwdIdentName(attrs, etype, fwdName) || getAttrByReverseIdentName(attrs, etype, fwdName);
    if (refAttr && refAttr['value-type'] !== 'ref') {
        throw new Error(`${identName} does not reference a valid link attribute.`);
    }
    return refAttr;
}
// Returns [attr, value] for the eid if the eid is a lookup.
// If it's a regular eid, returns null
function lookupPairOfEid(eid) {
    if (typeof eid === 'string' && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$instatx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isLookup"])(eid)) {
        return null;
    }
    return typeof eid === 'string' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$instatx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isLookup"])(eid) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$instatx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseLookup"])(eid) : explodeLookupRef(eid);
}
function extractLookup(attrs, etype, eid) {
    const lookupPair = lookupPairOfEid(eid);
    if (lookupPair === null) {
        return eid;
    }
    const [identName, value] = lookupPair;
    const attr = lookupIdentToAttr(attrs, etype, identName);
    if (!attr || !attr['unique?']) {
        throw new Error(`${identName} is not a unique attribute.`);
    }
    return [
        attr.id,
        value
    ];
}
function expandLink(attrs, [etype, eidA, obj]) {
    const addTriples = Object.entries(obj).flatMap(([label, eidOrEids])=>{
        const eids = Array.isArray(eidOrEids) ? eidOrEids : [
            eidOrEids
        ];
        const fwdAttr = getAttrByFwdIdentName(attrs, etype, label);
        const revAttr = getAttrByReverseIdentName(attrs, etype, label);
        return eids.map((eidB)=>{
            const txStep = fwdAttr ? [
                'add-triple',
                extractLookup(attrs, etype, eidA),
                fwdAttr.id,
                extractLookup(attrs, fwdAttr['reverse-identity'][1], eidB)
            ] : [
                'add-triple',
                extractLookup(attrs, revAttr['forward-identity'][1], eidB),
                revAttr.id,
                extractLookup(attrs, etype, eidA)
            ];
            return txStep;
        });
    });
    return addTriples;
}
function expandUnlink(attrs, [etype, eidA, obj]) {
    const retractTriples = Object.entries(obj).flatMap(([label, eidOrEids])=>{
        const eids = Array.isArray(eidOrEids) ? eidOrEids : [
            eidOrEids
        ];
        const fwdAttr = getAttrByFwdIdentName(attrs, etype, label);
        const revAttr = getAttrByReverseIdentName(attrs, etype, label);
        return eids.map((eidB)=>{
            const txStep = fwdAttr ? [
                'retract-triple',
                extractLookup(attrs, etype, eidA),
                fwdAttr.id,
                extractLookup(attrs, fwdAttr['reverse-identity'][1], eidB)
            ] : [
                'retract-triple',
                extractLookup(attrs, revAttr['forward-identity'][1], eidB),
                revAttr.id,
                extractLookup(attrs, etype, eidA)
            ];
            return txStep;
        });
    });
    return retractTriples;
}
function expandUpdate(attrs, [etype, eid, obj]) {
    const lookup = extractLookup(attrs, etype, eid);
    // id first so that we don't clobber updates on the lookup field
    const attrTuples = [
        [
            'id',
            extractLookup(attrs, etype, eid)
        ]
    ].concat(Object.entries(obj)).map(([identName, value])=>{
        const attr = getAttrByFwdIdentName(attrs, etype, identName);
        return [
            'add-triple',
            lookup,
            attr.id,
            value
        ];
    });
    return attrTuples;
}
function expandDelete(attrs, [etype, eid]) {
    const lookup = extractLookup(attrs, etype, eid);
    return [
        [
            'delete-entity',
            lookup,
            etype
        ]
    ];
}
function expandDeepMerge(attrs, [etype, eid, obj]) {
    const lookup = extractLookup(attrs, etype, eid);
    const attrTuples = Object.entries(obj).map(([identName, value])=>{
        const attr = getAttrByFwdIdentName(attrs, etype, identName);
        const coercedValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["immutableDeepReplace"])(value, undefined, null);
        return [
            'deep-merge-triple',
            lookup,
            attr.id,
            coercedValue
        ];
    });
    const idTuple = [
        'add-triple',
        lookup,
        getAttrByFwdIdentName(attrs, etype, 'id').id,
        lookup
    ];
    // id first so that we don't clobber updates on the lookup field
    return [
        idTuple
    ].concat(attrTuples);
}
function removeIdFromArgs(step) {
    const [op, etype, eid, obj] = step;
    if (!obj) {
        return step;
    }
    const newObj = Object.assign({}, obj);
    delete newObj.id;
    return [
        op,
        etype,
        eid,
        newObj
    ];
}
function toTxSteps(attrs, step) {
    const [action, ...args] = removeIdFromArgs(step);
    switch(action){
        case 'merge':
            return expandDeepMerge(attrs, args);
        case 'update':
            return expandUpdate(attrs, args);
        case 'link':
            return expandLink(attrs, args);
        case 'unlink':
            return expandUnlink(attrs, args);
        case 'delete':
            return expandDelete(attrs, args);
        default:
            throw new Error(`unsupported action ${action}`);
    }
}
// ---------
// transform
function checkedDataTypeOfValueType(valueType) {
    switch(valueType){
        case 'string':
        case 'date':
        case 'boolean':
        case 'number':
            return valueType;
        default:
            return undefined;
    }
}
function objectPropsFromSchema(schema, etype, label) {
    var _a, _b;
    const attr = (_b = (_a = schema.entities[etype]) === null || _a === void 0 ? void 0 : _a.attrs) === null || _b === void 0 ? void 0 : _b[label];
    if (label === 'id') return null;
    if (!attr) {
        throw new Error(`${etype}.${label} does not exist in your schema`);
    }
    const { unique, indexed } = attr === null || attr === void 0 ? void 0 : attr.config;
    const checkedDataType = checkedDataTypeOfValueType(attr === null || attr === void 0 ? void 0 : attr.valueType);
    return {
        'index?': indexed,
        'unique?': unique,
        'checked-data-type': checkedDataType
    };
}
function createObjectAttr(schema, etype, label, props) {
    const schemaObjectProps = schema ? objectPropsFromSchema(schema, etype, label) : null;
    const attrId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$uuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
    const fwdIdentId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$uuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
    const fwdIdent = [
        fwdIdentId,
        etype,
        label
    ];
    return Object.assign(Object.assign({
        id: attrId,
        'forward-identity': fwdIdent,
        'value-type': 'blob',
        cardinality: 'one',
        'unique?': false,
        'index?': false,
        isUnsynced: true
    }, schemaObjectProps || {}), props || {});
}
function findSchemaLink(schema, etype, label) {
    const found = Object.values(schema.links).find((x)=>{
        return x.forward.on === etype && x.forward.label === label || x.reverse.on === etype && x.reverse.label === label;
    });
    return found;
}
function refPropsFromSchema(schema, etype, label) {
    const found = findSchemaLink(schema, etype, label);
    if (!found) {
        throw new Error(`Couldn't find the link ${etype}.${label} in your schema`);
    }
    const { forward, reverse } = found;
    return {
        'forward-identity': [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$uuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(),
            forward.on,
            forward.label
        ],
        'reverse-identity': [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$uuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(),
            reverse.on,
            reverse.label
        ],
        cardinality: forward.has === 'one' ? 'one' : 'many',
        'unique?': reverse.has === 'one'
    };
}
function createRefAttr(schema, etype, label, props) {
    const schemaRefProps = schema ? refPropsFromSchema(schema, etype, label) : null;
    const attrId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$uuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
    const fwdIdent = [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$uuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(),
        etype,
        label
    ];
    const revIdent = [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$uuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(),
        label,
        etype
    ];
    return Object.assign(Object.assign({
        id: attrId,
        'forward-identity': fwdIdent,
        'reverse-identity': revIdent,
        'value-type': 'ref',
        cardinality: 'many',
        'unique?': false,
        'index?': false,
        isUnsynced: true
    }, schemaRefProps || {}), props || {});
}
// Actions that have an object, e.g. not delete
const OBJ_ACTIONS = new Set([
    'update',
    'merge',
    'link',
    'unlink'
]);
const REF_ACTIONS = new Set([
    'link',
    'unlink'
]);
const UPDATE_ACTIONS = new Set([
    'update',
    'merge'
]);
const SUPPORTS_LOOKUP_ACTIONS = new Set([
    'link',
    'unlink',
    'update',
    'merge',
    'delete'
]);
const lookupProps = {
    'unique?': true,
    'index?': true
};
const refLookupProps = Object.assign(Object.assign({}, lookupProps), {
    cardinality: 'one'
});
function lookupPairsOfOp(op) {
    const res = [];
    const [action, etype, eid, obj] = op;
    if (!SUPPORTS_LOOKUP_ACTIONS.has(action)) {
        return res;
    }
    const eidLookupPair = lookupPairOfEid(eid);
    if (eidLookupPair) {
        res.push({
            etype: etype,
            lookupPair: eidLookupPair
        });
    }
    if (action === 'link') {
        for (const [label, eidOrEids] of Object.entries(obj)){
            const eids = Array.isArray(eidOrEids) ? eidOrEids : [
                eidOrEids
            ];
            for (const linkEid of eids){
                const linkEidLookupPair = lookupPairOfEid(linkEid);
                if (linkEidLookupPair) {
                    res.push({
                        etype: etype,
                        lookupPair: linkEidLookupPair,
                        linkLabel: label
                    });
                }
            }
        }
    }
    return res;
}
function createMissingAttrs({ attrs: existingAttrs, schema }, ops) {
    var _a, _b;
    const [addedIds, attrs, addOps] = [
        new Set(),
        Object.assign({}, existingAttrs),
        []
    ];
    function addAttr(attr) {
        attrs[attr.id] = attr;
        addOps.push([
            'add-attr',
            attr
        ]);
        addedIds.add(attr.id);
    }
    function addUnsynced(attr) {
        if ((attr === null || attr === void 0 ? void 0 : attr.isUnsynced) && !addedIds.has(attr.id)) {
            addOps.push([
                'add-attr',
                attr
            ]);
            addedIds.add(attr.id);
        }
    }
    // Adds attrs needed for a ref lookup
    function addForRef(etype, label) {
        const fwdAttr = getAttrByFwdIdentName(attrs, etype, label);
        const revAttr = getAttrByReverseIdentName(attrs, etype, label);
        addUnsynced(fwdAttr);
        addUnsynced(revAttr);
        if (!fwdAttr && !revAttr) {
            addAttr(createRefAttr(schema, etype, label, refLookupProps));
        }
    }
    // Create attrs for lookups if we need to
    // Do these first because otherwise we might add a non-unique attr
    // before we get to it
    for (const op of ops){
        for (const { etype, lookupPair, linkLabel } of lookupPairsOfOp(op)){
            const identName = lookupPair[0];
            // We got a link eid that's a lookup, linkLabel is the label of the ident,
            // e.g. `posts` in `link({posts: postIds})`
            if (linkLabel) {
                // Add our ref attr, e.g. users.posts
                addForRef(etype, linkLabel);
                // Figure out the link etype so we can make sure we have the attrs
                // for the link lookup
                const fwdAttr = getAttrByFwdIdentName(attrs, etype, linkLabel);
                const revAttr = getAttrByReverseIdentName(attrs, etype, linkLabel);
                addUnsynced(fwdAttr);
                addUnsynced(revAttr);
                const linkEtype = ((_a = fwdAttr === null || fwdAttr === void 0 ? void 0 : fwdAttr['reverse-identity']) === null || _a === void 0 ? void 0 : _a[1]) || ((_b = revAttr === null || revAttr === void 0 ? void 0 : revAttr['forward-identity']) === null || _b === void 0 ? void 0 : _b[1]) || linkLabel;
                if (isRefLookupIdent(attrs, linkEtype, identName)) {
                    addForRef(linkEtype, extractRefLookupFwdName(identName));
                } else {
                    const attr = getAttrByFwdIdentName(attrs, linkEtype, identName);
                    if (!attr) {
                        addAttr(createObjectAttr(schema, linkEtype, identName, lookupProps));
                    }
                    addUnsynced(attr);
                }
            } else if (isRefLookupIdent(attrs, etype, identName)) {
                addForRef(etype, extractRefLookupFwdName(identName));
            } else {
                const attr = getAttrByFwdIdentName(attrs, etype, identName);
                if (!attr) {
                    addAttr(createObjectAttr(schema, etype, identName, lookupProps));
                }
                addUnsynced(attr);
            }
        }
    }
    // Create object and ref attrs
    for (const op of ops){
        const [action, etype, eid, obj] = op;
        if (OBJ_ACTIONS.has(action)) {
            const labels = Object.keys(obj);
            labels.push('id');
            for (const label of labels){
                const fwdAttr = getAttrByFwdIdentName(attrs, etype, label);
                addUnsynced(fwdAttr);
                if (UPDATE_ACTIONS.has(action)) {
                    if (!fwdAttr) {
                        addAttr(createObjectAttr(schema, etype, label, label === 'id' ? {
                            'unique?': true
                        } : null));
                    }
                }
                if (REF_ACTIONS.has(action)) {
                    const revAttr = getAttrByReverseIdentName(attrs, etype, label);
                    if (!fwdAttr && !revAttr) {
                        addAttr(createRefAttr(schema, etype, label));
                    }
                    addUnsynced(revAttr);
                }
            }
        }
    }
    return [
        attrs,
        addOps
    ];
}
function transform(ctx, inputChunks) {
    const chunks = Array.isArray(inputChunks) ? inputChunks : [
        inputChunks
    ];
    const ops = chunks.flatMap((tx)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$instatx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getOps"])(tx));
    const [newAttrs, addAttrTxSteps] = createMissingAttrs(ctx, ops);
    const txSteps = ops.flatMap((op)=>toTxSteps(newAttrs, op));
    return [
        ...addAttrTxSteps,
        ...txSteps
    ];
} //# sourceMappingURL=instaml.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/IndexedDBStorage.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>IndexedDBStorage)
});
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class IndexedDBStorage {
    constructor(dbName){
        this.dbName = dbName;
        this._storeName = 'kv';
        this._dbPromise = this._init();
    }
    _init() {
        return new Promise((resolve, reject)=>{
            const request = indexedDB.open(this.dbName, 1);
            request.onerror = (event)=>{
                reject(event);
            };
            request.onsuccess = (event)=>{
                resolve(event.target.result);
            };
            request.onupgradeneeded = (event)=>{
                const db = event.target.result;
                db.createObjectStore(this._storeName);
            };
        });
    }
    getItem(k) {
        return __awaiter(this, void 0, void 0, function*() {
            const db = yield this._dbPromise;
            return new Promise((resolve, reject)=>{
                const transaction = db.transaction([
                    this._storeName
                ], 'readonly');
                const objectStore = transaction.objectStore(this._storeName);
                const request = objectStore.get(k);
                request.onerror = (event)=>{
                    reject(event);
                };
                request.onsuccess = (_event)=>{
                    if (request.result) {
                        resolve(request.result);
                    } else {
                        resolve(null);
                    }
                };
            });
        });
    }
    setItem(k, v) {
        return __awaiter(this, void 0, void 0, function*() {
            const db = yield this._dbPromise;
            return new Promise((resolve, reject)=>{
                const transaction = db.transaction([
                    this._storeName
                ], 'readwrite');
                const objectStore = transaction.objectStore(this._storeName);
                const request = objectStore.put(v, k);
                request.onerror = (event)=>{
                    reject(event);
                };
                request.onsuccess = (_event)=>{
                    resolve();
                };
            });
        });
    }
} //# sourceMappingURL=IndexedDBStorage.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/WindowNetworkListener.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>WindowNetworkListener)
});
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class WindowNetworkListener {
    static getIsOnline() {
        return __awaiter(this, void 0, void 0, function*() {
            return navigator.onLine;
        });
    }
    static listen(f) {
        const onOnline = ()=>{
            f(true);
        };
        const onOffline = ()=>{
            f(false);
        };
        addEventListener('online', onOnline);
        addEventListener('offline', onOffline);
        return ()=>{
            removeEventListener('online', onOnline);
            removeEventListener('offline', onOffline);
        };
    }
} //# sourceMappingURL=WindowNetworkListener.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/fetch.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "jsonFetch": (()=>jsonFetch)
});
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function jsonFetch(input, init) {
    return __awaiter(this, void 0, void 0, function*() {
        const res = yield fetch(input, init);
        const json = yield res.json();
        return res.status === 200 ? Promise.resolve(json) : Promise.reject({
            status: res.status,
            body: json
        });
    });
} //# sourceMappingURL=fetch.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/authAPI.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "exchangeCodeForToken": (()=>exchangeCodeForToken),
    "sendMagicCode": (()=>sendMagicCode),
    "signInWithIdToken": (()=>signInWithIdToken),
    "signOut": (()=>signOut),
    "verifyMagicCode": (()=>verifyMagicCode),
    "verifyRefreshToken": (()=>verifyRefreshToken)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/fetch.js [app-client] (ecmascript)");
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
;
function sendMagicCode({ apiURI, appId, email }) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsonFetch"])(`${apiURI}/runtime/auth/send_magic_code`, {
        method: 'POST',
        headers: {
            'content-type': 'application/json'
        },
        body: JSON.stringify({
            'app-id': appId,
            email
        })
    });
}
function verifyMagicCode(_a) {
    return __awaiter(this, arguments, void 0, function*({ apiURI, appId, email, code }) {
        const res = yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsonFetch"])(`${apiURI}/runtime/auth/verify_magic_code`, {
            method: 'POST',
            headers: {
                'content-type': 'application/json'
            },
            body: JSON.stringify({
                'app-id': appId,
                email,
                code
            })
        });
        return res;
    });
}
function verifyRefreshToken(_a) {
    return __awaiter(this, arguments, void 0, function*({ apiURI, appId, refreshToken }) {
        const res = yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsonFetch"])(`${apiURI}/runtime/auth/verify_refresh_token`, {
            method: 'POST',
            headers: {
                'content-type': 'application/json'
            },
            body: JSON.stringify({
                'app-id': appId,
                'refresh-token': refreshToken
            })
        });
        return res;
    });
}
function exchangeCodeForToken(_a) {
    return __awaiter(this, arguments, void 0, function*({ apiURI, appId, code, codeVerifier }) {
        const res = yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsonFetch"])(`${apiURI}/runtime/oauth/token`, {
            method: 'POST',
            headers: {
                'content-type': 'application/json'
            },
            body: JSON.stringify({
                app_id: appId,
                code: code,
                code_verifier: codeVerifier
            })
        });
        return res;
    });
}
function signInWithIdToken(_a) {
    return __awaiter(this, arguments, void 0, function*({ apiURI, appId, nonce, idToken, clientName, refreshToken }) {
        const res = yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsonFetch"])(`${apiURI}/runtime/oauth/id_token`, {
            method: 'POST',
            headers: {
                'content-type': 'application/json'
            },
            body: JSON.stringify({
                app_id: appId,
                nonce,
                id_token: idToken,
                client_name: clientName,
                refresh_token: refreshToken
            })
        });
        return res;
    });
}
function signOut(_a) {
    return __awaiter(this, arguments, void 0, function*({ apiURI, appId, refreshToken }) {
        const res = yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsonFetch"])(`${apiURI}/runtime/signout`, {
            method: 'POST',
            headers: {
                'content-type': 'application/json'
            },
            body: JSON.stringify({
                app_id: appId,
                refresh_token: refreshToken
            })
        });
        return res;
    });
} //# sourceMappingURL=authAPI.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/StorageAPI.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "deleteFile": (()=>deleteFile),
    "getDownloadUrl": (()=>getDownloadUrl),
    "getSignedUploadUrl": (()=>getSignedUploadUrl),
    "upload": (()=>upload),
    "uploadFile": (()=>uploadFile)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/fetch.js [app-client] (ecmascript)");
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
;
function uploadFile(_a) {
    return __awaiter(this, arguments, void 0, function*({ apiURI, appId, path, file, refreshToken, contentType, contentDisposition }) {
        const headers = {
            app_id: appId,
            path,
            authorization: `Bearer ${refreshToken}`,
            'content-type': contentType || file.type
        };
        if (contentDisposition) {
            headers['content-disposition'] = contentDisposition;
        }
        const data = yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsonFetch"])(`${apiURI}/storage/upload`, {
            method: 'PUT',
            headers,
            body: file
        });
        return data;
    });
}
function deleteFile(_a) {
    return __awaiter(this, arguments, void 0, function*({ apiURI, appId, path, refreshToken }) {
        const { data } = yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsonFetch"])(`${apiURI}/storage/files?app_id=${appId}&filename=${encodeURIComponent(path)}`, {
            method: 'DELETE',
            headers: {
                'content-type': 'application/json',
                authorization: `Bearer ${refreshToken}`
            }
        });
        return data;
    });
}
function getSignedUploadUrl(_a) {
    return __awaiter(this, arguments, void 0, function*({ apiURI, appId, fileName, refreshToken, metadata = {} }) {
        const { data } = yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsonFetch"])(`${apiURI}/storage/signed-upload-url`, {
            method: 'POST',
            headers: {
                'content-type': 'application/json',
                authorization: `Bearer ${refreshToken}`
            },
            body: JSON.stringify({
                app_id: appId,
                filename: fileName
            })
        });
        return data;
    });
}
function upload(presignedUrl, file) {
    return __awaiter(this, void 0, void 0, function*() {
        console.log('presignedUrl', presignedUrl);
        const response = yield fetch(presignedUrl, {
            method: 'PUT',
            body: file,
            headers: {
                'Content-Type': file.type
            }
        });
        return response.ok;
    });
}
function getDownloadUrl(_a) {
    return __awaiter(this, arguments, void 0, function*({ apiURI, appId, path, refreshToken }) {
        const { data } = yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsonFetch"])(`${apiURI}/storage/signed-download-url?app_id=${appId}&filename=${encodeURIComponent(path)}`, {
            method: 'GET',
            headers: {
                'content-type': 'application/json',
                authorization: `Bearer ${refreshToken}`
            }
        });
        return data;
    });
} //# sourceMappingURL=StorageAPI.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/pick.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "pick": (()=>pick)
});
function pick(obj, keys) {
    if (!keys) return obj;
    const ret = {};
    keys.forEach((key)=>{
        ret[key] = obj[key];
    });
    return ret;
} //# sourceMappingURL=pick.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/presence.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "buildPresenceSlice": (()=>buildPresenceSlice),
    "hasPresenceResponseChanged": (()=>hasPresenceResponseChanged)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$pick$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/pick.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/object.js [app-client] (ecmascript)");
;
;
function buildPresenceSlice(data, opts, userPeerId) {
    var _a, _b;
    const slice = {
        peers: {}
    };
    const includeUser = opts && 'user' in opts ? opts.user : true;
    if (includeUser) {
        const user = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$pick$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pick"])((_a = data.user) !== null && _a !== void 0 ? _a : {}, opts === null || opts === void 0 ? void 0 : opts.keys);
        slice.user = Object.assign(Object.assign({}, user), {
            peerId: userPeerId
        });
    }
    for (const id of Object.keys((_b = data.peers) !== null && _b !== void 0 ? _b : {})){
        const shouldIncludeAllPeers = (opts === null || opts === void 0 ? void 0 : opts.peers) === undefined;
        const isPeerIncluded = Array.isArray(opts === null || opts === void 0 ? void 0 : opts.peers) && (opts === null || opts === void 0 ? void 0 : opts.peers.includes(id));
        if (shouldIncludeAllPeers || isPeerIncluded) {
            const peer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$pick$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pick"])(data.peers[id], opts === null || opts === void 0 ? void 0 : opts.keys);
            slice.peers[id] = Object.assign(Object.assign({}, peer), {
                peerId: id
            });
        }
    }
    return slice;
}
function hasPresenceResponseChanged(a, b) {
    if (a.isLoading !== b.isLoading) return true;
    if (a.error !== b.error) return true;
    if (a.user || b.user) {
        if (!a.user || !b.user) return true;
        const same = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["areObjectsShallowEqual"])(a.user, b.user);
        if (!same) return true;
    }
    const sameKeys = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["areObjectKeysEqual"])(a.peers, b.peers);
    if (!sameKeys) return true;
    for (const id of Object.keys(a.peers)){
        const same = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["areObjectsShallowEqual"])(a.peers[id], b.peers[id]);
        if (!same) return true;
    }
    return false;
} //# sourceMappingURL=presence.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/Deferred.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Deferred": (()=>Deferred)
});
class Deferred {
    constructor(){
        this.promise = new Promise((resolve, reject)=>{
            this._resolve = resolve;
            this._reject = reject;
        });
    }
    resolve(value) {
        this._resolve(value);
    }
    reject(reason) {
        this._reject(reason);
    }
} //# sourceMappingURL=Deferred.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/PersistedObject.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "PersistedObject": (()=>PersistedObject)
});
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class PersistedObject {
    constructor(persister, key, defaultValue, onMerge, toJSON = (x)=>{
        return JSON.stringify(x);
    }, fromJSON = (x)=>{
        return JSON.parse(x);
    }, saveThrottleMs = 100){
        this._subs = [];
        this._persister = persister;
        this._key = key;
        this._onMerge = onMerge;
        this._loadedCbs = [];
        this._isLoading = true;
        this.currentValue = defaultValue;
        this.toJSON = toJSON;
        this.fromJSON = fromJSON;
        this._saveThrottleMs = saveThrottleMs;
        this._pendingSaveCbs = [];
        this._version = 0;
        this._load();
    }
    _load() {
        return __awaiter(this, void 0, void 0, function*() {
            const fromStorage = this.fromJSON((yield this._persister.getItem(this._key)));
            this._isLoading = false;
            this._onMerge(fromStorage, this.currentValue);
            for (const cb of this._loadedCbs){
                cb();
            }
        });
    }
    waitForLoaded() {
        return __awaiter(this, void 0, void 0, function*() {
            if (!this._isLoading) {
                return;
            }
            const loadedPromise = new Promise((resolve)=>{
                this._loadedCbs.push(resolve);
            });
            yield loadedPromise;
        });
    }
    isLoading() {
        return this._isLoading;
    }
    version() {
        return this._version;
    }
    waitForSync() {
        return __awaiter(this, void 0, void 0, function*() {
            if (!this._nextSave) {
                return;
            }
            const syncedPromise = new Promise((resolve)=>{
                this._pendingSaveCbs.push(resolve);
            });
            yield syncedPromise;
        });
    }
    _writeToStorage() {
        this._persister.setItem(this._key, this.toJSON(this.currentValue));
        for (const cb of this._pendingSaveCbs){
            cb();
        }
        this._pendingSaveCbs.length = 0;
    }
    flush() {
        return __awaiter(this, void 0, void 0, function*() {
            if (!this._nextSave) {
                return;
            }
            clearTimeout(this._nextSave);
            this._writeToStorage();
        });
    }
    _enqueuePersist(cb) {
        if (this._nextSave) {
            if (cb) {
                this._pendingSaveCbs.push(cb);
            }
            return;
        }
        this._nextSave = setTimeout(()=>{
            this._nextSave = null;
            this._writeToStorage();
        }, this._saveThrottleMs);
    }
    set(f, cb) {
        this._version++;
        this.currentValue = f(this.currentValue);
        if (this._isLoading) {
            this._loadedCbs.push(()=>this._enqueuePersist(cb));
        } else {
            this._enqueuePersist(cb);
        }
        for (const sub of this._subs){
            sub(this.currentValue);
        }
    }
    subscribe(cb) {
        this._subs.push(cb);
        cb(this.currentValue);
        return ()=>{
            this._subs = this._subs.filter((x)=>x !== cb);
        };
    }
} //# sourceMappingURL=PersistedObject.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/model/instaqlResult.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "extractTriples": (()=>extractTriples)
});
function _extractTriplesHelper(idNodes, acc = []) {
    idNodes.forEach((idNode)=>{
        const { data } = idNode;
        const { 'datalog-result': datalogResult } = data;
        const { 'join-rows': joinRows } = datalogResult;
        for (const rows of joinRows){
            for (const triple of rows){
                acc.push(triple);
            }
        }
        _extractTriplesHelper(idNode['child-nodes'], acc);
    });
}
function extractTriples(idNodes) {
    const triples = [];
    _extractTriplesHelper(idNodes, triples);
    return triples;
} //# sourceMappingURL=instaqlResult.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/linkIndex.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "createLinkIndex": (()=>createLinkIndex)
});
function createLinkIndex(schema) {
    return Object.values(schema.links).reduce((linkIndex, link)=>{
        var _a, _b;
        var _c, _d;
        (_a = linkIndex[_c = link.forward.on]) !== null && _a !== void 0 ? _a : linkIndex[_c] = {};
        linkIndex[link.forward.on][link.forward.label] = {
            isForward: true,
            isSingular: link.forward.has === 'one',
            link
        };
        (_b = linkIndex[_d = link.reverse.on]) !== null && _b !== void 0 ? _b : linkIndex[_d] = {};
        linkIndex[link.reverse.on][link.reverse.label] = {
            isForward: false,
            isSingular: link.reverse.has === 'one',
            link
        };
        return linkIndex;
    }, {});
} //# sourceMappingURL=linkIndex.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/version.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// Autogenerated by publish_packages.clj
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const version = 'v0.17.21';
const __TURBOPACK__default__export__ = version;
 //# sourceMappingURL=version.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/Reactor.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>Reactor)
});
// @ts-check
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/log.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/weakHash.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$instaql$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/instaql.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$instaml$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/instaml.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/store.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$uuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/uuid.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$IndexedDBStorage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/IndexedDBStorage.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$WindowNetworkListener$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/WindowNetworkListener.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$authAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/authAPI.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$StorageAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/StorageAPI.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$presence$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/presence.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$Deferred$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/Deferred.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$PersistedObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/PersistedObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$model$2f$instaqlResult$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/model/instaqlResult.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/object.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$linkIndex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/linkIndex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/version.js [app-client] (ecmascript)");
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const STATUS = {
    CONNECTING: 'connecting',
    OPENED: 'opened',
    AUTHENTICATED: 'authenticated',
    CLOSED: 'closed',
    ERRORED: 'errored'
};
const QUERY_ONCE_TIMEOUT = 30000;
const WS_CONNECTING_STATUS = 0;
const WS_OPEN_STATUS = 1;
const defaultConfig = {
    apiURI: 'https://api.instantdb.com',
    websocketURI: 'wss://api.instantdb.com/runtime/session'
};
// Param that the backend adds if this is an oauth redirect
const OAUTH_REDIRECT_PARAM = '_instant_oauth_redirect';
const currentUserKey = `currentUser`;
let _wsId = 0;
function createWebSocket(uri) {
    const ws = new WebSocket(uri);
    // @ts-ignore
    ws._id = _wsId++;
    return ws;
}
function isClient() {
    const hasWindow = typeof window !== 'undefined';
    // this checks if we are running in a chrome extension
    // @ts-expect-error
    const isChrome = typeof chrome !== 'undefined';
    return hasWindow || isChrome;
}
const ignoreLogging = {
    'set-presence': true,
    'set-presence-ok': true,
    'refresh-presence': true,
    'patch-presence': true
};
function querySubsFromJSON(str) {
    var _a;
    const parsed = JSON.parse(str);
    for(const key in parsed){
        const v = parsed[key];
        if ((_a = v === null || v === void 0 ? void 0 : v.result) === null || _a === void 0 ? void 0 : _a.store) {
            v.result.store = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.fromJSON(v.result.store);
        }
    }
    return parsed;
}
function querySubsToJSON(querySubs) {
    var _a;
    const jsonSubs = {};
    for(const key in querySubs){
        const sub = querySubs[key];
        const jsonSub = Object.assign({}, sub);
        if ((_a = sub.result) === null || _a === void 0 ? void 0 : _a.store) {
            jsonSub.result = Object.assign(Object.assign({}, sub.result), {
                store: __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toJSON(sub.result.store)
            });
        }
        jsonSubs[key] = jsonSub;
    }
    return JSON.stringify(jsonSubs);
}
class Reactor {
    constructor(config, Storage = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$IndexedDBStorage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], NetworkListener = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$WindowNetworkListener$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], versions){
        this._isOnline = true;
        this._isShutdown = false;
        this.status = STATUS.CONNECTING;
        /** @type {Record<string, Array<{ q: any, cb: (data: any) => any }>>} */ this.queryCbs = {};
        /** @type {Record<string, Array<{ q: any, eventId: string, dfd: Deferred }>>} */ this.queryOnceDfds = {};
        this.authCbs = [];
        this.attrsCbs = [];
        this.mutationErrorCbs = [];
        this.connectionStatusCbs = [];
        this.mutationDeferredStore = new Map();
        this._reconnectTimeoutId = null;
        this._reconnectTimeoutMs = 0;
        this._localIdPromises = {};
        this._errorMessage = null;
        /** @type {Promise<null | {error: {message: string}}>}**/ this._oauthCallbackResponse = null;
        /** @type {null | import('./utils/linkIndex').LinkIndex}} */ this._linkIndex = null;
        /** @type {Record<string, {isConnected: boolean; error: any}>} */ this._rooms = {};
        /** @type {Record<string, boolean>} */ this._roomsPendingLeave = {};
        this._presence = {};
        this._broadcastQueue = [];
        this._broadcastSubs = {};
        this._currentUserCached = {
            isLoading: true,
            error: undefined,
            user: undefined
        };
        this._beforeUnloadCbs = [];
        this._dataForQueryCache = {};
        /**
         *  merge querySubs from storage and in memory. Has the following side
         *  effects:
         *  - We notify all queryCbs because results may been added during merge
         */ this._onMergeQuerySubs = (_storageSubs, inMemorySubs)=>{
            const storageSubs = _storageSubs || {};
            const ret = Object.assign({}, inMemorySubs);
            // Consider an inMemorySub with no result;
            // If we have a result from storageSubs, let's add it
            Object.entries(inMemorySubs).forEach(([hash, querySub])=>{
                var _a;
                const storageResult = (_a = storageSubs === null || storageSubs === void 0 ? void 0 : storageSubs[hash]) === null || _a === void 0 ? void 0 : _a.result;
                const memoryResult = querySub.result;
                if (storageResult && !memoryResult) {
                    ret[hash].result = storageResult;
                }
            });
            // Consider a storageSub with no corresponding inMemorySub
            // This means that at least at this point,
            // the user has not asked to subscribe to the query.
            // We may _still_ want to add it, because in just a
            // few milliseconds, the user will ask to subscribe to the
            // query.
            // For now, we can't really tell if the user will ask to subscribe
            // or not. So for now let's just add the first 10 queries from storage.
            // Eventually, we could be smarter about this. For example,
            // we can keep usage information about which queries are popular.
            const storageKsToAdd = Object.keys(storageSubs).filter((k)=>!inMemorySubs[k]).slice(0, 10);
            storageKsToAdd.forEach((k)=>{
                ret[k] = storageSubs[k];
            });
            // Okay, now we have merged our querySubs
            this.querySubs.set((_)=>ret);
            this.loadedNotifyAll();
        };
        /**
         * merge pendingMutations from storage and in memory. Has a side effect of
         * sending mutations that were stored but not acked
         */ this._onMergePendingMutations = (storageMuts, inMemoryMuts)=>{
            const ret = new Map([
                ...storageMuts.entries(),
                ...inMemoryMuts.entries()
            ]);
            this.pendingMutations.set((_)=>ret);
            this.loadedNotifyAll();
            const rewrittenStorageMuts = this._rewriteMutations(this.attrs, storageMuts);
            rewrittenStorageMuts.forEach((mut, k)=>{
                if (!inMemoryMuts.has(k) && !mut['tx-id']) {
                    this._sendMutation(k, mut);
                }
            });
        };
        // ---------------------------
        // Queries
        this.getPreviousResult = (q)=>{
            const hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(q);
            return this.dataForQuery(hash);
        };
        /** Re-run instaql and call all callbacks with new data */ this.notifyOne = (hash)=>{
            var _a, _b;
            const cbs = (_a = this.queryCbs[hash]) !== null && _a !== void 0 ? _a : [];
            const prevData = (_b = this._dataForQueryCache[hash]) === null || _b === void 0 ? void 0 : _b.data;
            const data = this.dataForQuery(hash);
            if (!data) return;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["areObjectsDeepEqual"])(data, prevData)) return;
            cbs.forEach((r)=>r.cb(data));
        };
        this.notifyOneQueryOnce = (hash)=>{
            var _a;
            const dfds = (_a = this.queryOnceDfds[hash]) !== null && _a !== void 0 ? _a : [];
            const data = this.dataForQuery(hash);
            dfds.forEach((r)=>{
                this._completeQueryOnce(r.q, hash, r.dfd);
                r.dfd.resolve(data);
            });
        };
        this.notifyQueryError = (hash, error)=>{
            const cbs = this.queryCbs[hash] || [];
            cbs.forEach((r)=>r.cb({
                    error
                }));
        };
        /** Applies transactions locally and sends transact message to server */ this.pushTx = (chunks)=>{
            try {
                const txSteps = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$instaml$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.transform({
                    attrs: this.optimisticAttrs(),
                    schema: this.config.schema
                }, chunks);
                return this.pushOps(txSteps);
            } catch (e) {
                return this.pushOps([], e);
            }
        };
        /**
         * @param {*} txSteps
         * @param {*} [error]
         * @returns
         */ this.pushOps = (txSteps, error)=>{
            const eventId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$uuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
            const mutation = {
                op: 'transact',
                'tx-steps': txSteps,
                error
            };
            this.pendingMutations.set((prev)=>{
                prev.set(eventId, mutation);
                return prev;
            });
            const dfd = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$Deferred$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Deferred"]();
            this.mutationDeferredStore.set(eventId, dfd);
            this._sendMutation(eventId, mutation);
            this.notifyAll();
            return dfd.promise;
        };
        this._wsOnOpen = (e)=>{
            const targetWs = e.target;
            if (this._ws !== targetWs) {
                __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].info('[socket][open]', targetWs._id, 'skip; this is no longer the current ws');
                return;
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].info('[socket][open]', this._ws._id);
            this._setStatus(STATUS.OPENED);
            this.getCurrentUser().then((resp)=>{
                var _a;
                this._trySend((0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$uuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(), {
                    op: 'init',
                    'app-id': this.config.appId,
                    'refresh-token': (_a = resp.user) === null || _a === void 0 ? void 0 : _a['refresh_token'],
                    versions: this.versions,
                    // If an admin token is provided for an app, we will
                    // skip all permission checks. This is an advanced feature,
                    // to let users write internal tools
                    // This option is not exposed in `Config`, as it's
                    // not ready for prme time
                    '__admin-token': this.config.__adminToken
                });
            });
        };
        this._wsOnMessage = (e)=>{
            const targetWs = e.target;
            const m = JSON.parse(e.data.toString());
            if (this._ws !== targetWs) {
                __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].info('[socket][message]', targetWs._id, m, 'skip; this is no longer the current ws');
                return;
            }
            this._handleReceive(targetWs._id, JSON.parse(e.data.toString()));
        };
        this._wsOnError = (e)=>{
            const targetWs = e.target;
            if (this._ws !== targetWs) {
                __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].info('[socket][error]', targetWs._id, 'skip; this is no longer the current ws');
                return;
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].error('[socket][error]', targetWs._id, e);
        };
        this._wsOnClose = (e)=>{
            const targetWs = e.target;
            if (this._ws !== targetWs) {
                __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].info('[socket][close]', targetWs._id, 'skip; this is no longer the current ws');
                return;
            }
            this._setStatus(STATUS.CLOSED);
            for (const room of Object.values(this._rooms)){
                room.isConnected = false;
            }
            if (this._isShutdown) {
                __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].info('[socket][close]', targetWs._id, 'Reactor has been shut down and will not reconnect');
                return;
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].info('[socket][close]', targetWs._id, 'schedule reconnect, ms =', this._reconnectTimeoutMs);
            setTimeout(()=>{
                this._reconnectTimeoutMs = Math.min(this._reconnectTimeoutMs + 1000, 10000);
                if (!this._isOnline) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].info('[socket][close]', targetWs._id, 'we are offline, no need to start socket');
                    return;
                }
                this._startSocket();
            }, this._reconnectTimeoutMs);
        };
        this.config = Object.assign(Object.assign({}, defaultConfig), config);
        this.versions = Object.assign(Object.assign({}, versions || {}), {
            '@instantdb/core': __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
        });
        if (this.config.schema) {
            this._linkIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$linkIndex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createLinkIndex"])(this.config.schema);
        }
        // This is to protect us against running
        // server-side.
        if (!isClient()) {
            return;
        }
        if (typeof BroadcastChannel === 'function') {
            this._broadcastChannel = new BroadcastChannel('@instantdb');
            this._broadcastChannel.addEventListener('message', (e)=>__awaiter(this, void 0, void 0, function*() {
                    var _a;
                    if (((_a = e.data) === null || _a === void 0 ? void 0 : _a.type) === 'auth') {
                        const res = yield this.getCurrentUser();
                        this.updateUser(res.user);
                    }
                }));
        }
        this._oauthCallbackResponse = this._oauthLoginInit();
        this._initStorage(Storage);
        // kick off a request to cache it
        this.getCurrentUser();
        NetworkListener.getIsOnline().then((isOnline)=>{
            this._isOnline = isOnline;
            this._startSocket();
            NetworkListener.listen((isOnline)=>{
                // We do this because react native's NetInfo
                // fires multiple online events.
                // We only want to handle one state change
                if (isOnline === this._isOnline) {
                    return;
                }
                __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].info('[network] online =', isOnline);
                this._isOnline = isOnline;
                if (this._isOnline) {
                    this._startSocket();
                } else {
                    __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].info('Changing status from', this.status, 'to', STATUS.CLOSED);
                    this._setStatus(STATUS.CLOSED);
                }
            });
        });
        if (typeof addEventListener !== 'undefined') {
            this._beforeUnload = this._beforeUnload.bind(this);
            addEventListener('beforeunload', this._beforeUnload);
        }
    }
    _initStorage(Storage) {
        this._persister = new Storage(`instant_${this.config.appId}_5`);
        this.querySubs = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$PersistedObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PersistedObject"](this._persister, 'querySubs', {}, this._onMergeQuerySubs, querySubsToJSON, querySubsFromJSON);
        this.pendingMutations = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$PersistedObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PersistedObject"](this._persister, 'pendingMutations', new Map(), this._onMergePendingMutations, (x)=>{
            return JSON.stringify([
                ...x.entries()
            ]);
        }, (x)=>{
            return new Map(JSON.parse(x));
        });
        this._beforeUnloadCbs.push(()=>{
            this.pendingMutations.flush();
            this.querySubs.flush();
        });
    }
    _beforeUnload() {
        for (const cb of this._beforeUnloadCbs){
            cb();
        }
    }
    /**
     * @param {'enqueued' | 'pending' | 'synced' | 'timeout' |  'error' } status
     * @param string clientId
     * @param {{message?: string, hint?: string, error?: Error}} [errDetails]
     */ _finishTransaction(status, clientId, errDetails) {
        const dfd = this.mutationDeferredStore.get(clientId);
        this.mutationDeferredStore.delete(clientId);
        const ok = status !== 'error' && status !== 'timeout';
        if (!dfd && !ok) {
            // console.erroring here, as there are no listeners to let know
            console.error('Mutation failed', Object.assign({
                status,
                clientId
            }, errDetails));
        }
        if (!dfd) {
            return;
        }
        if (ok) {
            dfd.resolve({
                status,
                clientId
            });
        } else {
            dfd.reject(Object.assign({
                status,
                clientId
            }, errDetails));
        }
    }
    _setStatus(status, err) {
        this.status = status;
        this._errorMessage = err;
        this.notifyConnectionStatusSubs(status);
    }
    _flushEnqueuedRoomData(roomId) {
        var _a, _b;
        const enqueuedUserPresence = (_b = (_a = this._presence[roomId]) === null || _a === void 0 ? void 0 : _a.result) === null || _b === void 0 ? void 0 : _b.user;
        const enqueuedBroadcasts = this._broadcastQueue[roomId];
        this._broadcastQueue[roomId] = [];
        if (enqueuedUserPresence) {
            this._trySetPresence(roomId, enqueuedUserPresence);
        }
        if (enqueuedBroadcasts) {
            for (const item of enqueuedBroadcasts){
                const { topic, roomType, data } = item;
                this._tryBroadcast(roomId, roomType, topic, data);
            }
        }
    }
    _handleReceive(wsId, msg) {
        var _a, _b, _c, _d;
        // opt-out, enabled by default if schema
        const enableCardinalityInference = Boolean(this.config.schema) && ('cardinalityInference' in this.config ? Boolean(this.config.cardinalityInference) : true);
        if (!ignoreLogging[msg.op]) {
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].info('[receive]', wsId, msg.op, msg);
        }
        switch(msg.op){
            case 'init-ok':
                this._setStatus(STATUS.AUTHENTICATED);
                this._reconnectTimeoutMs = 0;
                this._setAttrs(msg.attrs);
                this._flushPendingMessages();
                // (EPH): set session-id, so we know
                // which item is us
                this._sessionId = msg['session-id'];
                for (const roomId of Object.keys(this._rooms)){
                    this._tryJoinRoom(roomId);
                }
                break;
            case 'add-query-exists':
                this.notifyOneQueryOnce((0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(msg.q));
                break;
            case 'add-query-ok':
                const { q, result } = msg;
                const hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(q);
                const pageInfo = (_b = (_a = result === null || result === void 0 ? void 0 : result[0]) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b['page-info'];
                const aggregate = (_d = (_c = result === null || result === void 0 ? void 0 : result[0]) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d['aggregate'];
                const triples = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$model$2f$instaqlResult$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extractTriples"])(result);
                const store = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.createStore(this.attrs, triples, enableCardinalityInference, this._linkIndex);
                this.querySubs.set((prev)=>{
                    prev[hash].result = {
                        store,
                        pageInfo,
                        aggregate
                    };
                    return prev;
                });
                this.notifyOne(hash);
                this.notifyOneQueryOnce(hash);
                break;
            case 'refresh-ok':
                const { computations, attrs } = msg;
                this._setAttrs(attrs);
                const updates = computations.map((x)=>{
                    var _a, _b, _c, _d;
                    const q = x['instaql-query'];
                    const result = x['instaql-result'];
                    const hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(q);
                    const triples = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$model$2f$instaqlResult$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extractTriples"])(result);
                    const store = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.createStore(this.attrs, triples, enableCardinalityInference, this._linkIndex);
                    const pageInfo = (_b = (_a = result === null || result === void 0 ? void 0 : result[0]) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b['page-info'];
                    const aggregate = (_d = (_c = result === null || result === void 0 ? void 0 : result[0]) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d['aggregate'];
                    return {
                        hash,
                        store,
                        pageInfo,
                        aggregate
                    };
                });
                updates.forEach(({ hash, store, pageInfo, aggregate })=>{
                    this.querySubs.set((prev)=>{
                        prev[hash].result = {
                            store,
                            pageInfo,
                            aggregate
                        };
                        return prev;
                    });
                });
                updates.forEach(({ hash })=>{
                    this.notifyOne(hash);
                });
                break;
            case 'transact-ok':
                const { 'client-event-id': eventId, 'tx-id': txId } = msg;
                const muts = this._rewriteMutations(this.attrs, this.pendingMutations.currentValue);
                const prevMutation = muts.get(eventId);
                if (!prevMutation) {
                    break;
                }
                // Now that this transaction is accepted,
                // We can delete it from our queue.
                this.pendingMutations.set((prev)=>{
                    prev.delete(eventId);
                    return prev;
                });
                // We apply this transaction to all our existing queries
                const txStepsToApply = prevMutation['tx-steps'];
                this.querySubs.set((prev)=>{
                    var _a;
                    for (const [hash, sub] of Object.entries(prev)){
                        const store = (_a = sub === null || sub === void 0 ? void 0 : sub.result) === null || _a === void 0 ? void 0 : _a.store;
                        if (!store) {
                            continue;
                        }
                        const newStore = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.transact(store, txStepsToApply);
                        prev[hash].result.store = newStore;
                    }
                    return prev;
                });
                const newAttrs = prevMutation['tx-steps'].filter(([action, ..._args])=>action === 'add-attr').map(([_action, attr])=>attr).concat(Object.values(this.attrs));
                this._setAttrs(newAttrs);
                this._finishTransaction('synced', eventId);
                break;
            case 'patch-presence':
                {
                    const roomId = msg['room-id'];
                    this._patchPresencePeers(roomId, msg['edits']);
                    this._notifyPresenceSubs(roomId);
                    break;
                }
            case 'refresh-presence':
                {
                    const roomId = msg['room-id'];
                    this._setPresencePeers(roomId, msg['data']);
                    this._notifyPresenceSubs(roomId);
                    break;
                }
            case 'server-broadcast':
                const room = msg['room-id'];
                const topic = msg.topic;
                this._notifyBroadcastSubs(room, topic, msg);
                break;
            case 'join-room-ok':
                const loadingRoomId = msg['room-id'];
                const joinedRoom = this._rooms[loadingRoomId];
                if (!joinedRoom) {
                    if (this._roomsPendingLeave[loadingRoomId]) {
                        this._tryLeaveRoom(loadingRoomId);
                        delete this._roomsPendingLeave[loadingRoomId];
                    }
                    break;
                }
                joinedRoom.isConnected = true;
                this._notifyPresenceSubs(loadingRoomId);
                this._flushEnqueuedRoomData(loadingRoomId);
                break;
            case 'join-room-error':
                const errorRoomId = msg['room-id'];
                const errorRoom = this._rooms[errorRoomId];
                if (errorRoom) {
                    errorRoom.error = msg['error'];
                }
                this._notifyPresenceSubs(errorRoomId);
                break;
            case 'error':
                this._handleReceiveError(msg);
                break;
            default:
                break;
        }
    }
    /**
     * @param {'timeout' | 'error'} status
     * @param {string} eventId
     * @param {{message?: string, hint?: string, error?: Error}} errDetails
     */ _handleMutationError(status, eventId, errDetails) {
        const mut = this.pendingMutations.currentValue.get(eventId);
        if (mut && (status !== 'timeout' || !mut['tx-id'])) {
            this.pendingMutations.set((prev)=>{
                prev.delete(eventId);
                return prev;
            });
            this.notifyAll();
            this.notifyAttrsSubs();
            this.notifyMutationErrorSubs(errDetails);
            this._finishTransaction(status, eventId, errDetails);
        }
    }
    _handleReceiveError(msg) {
        var _a, _b, _c, _d, _e;
        const eventId = msg['client-event-id'];
        const prevMutation = this.pendingMutations.currentValue.get(eventId);
        const errorMessage = {
            message: msg.message || 'Uh-oh, something went wrong. Ping Joe & Stopa.'
        };
        if (msg.hint) {
            errorMessage.hint = msg.hint;
        }
        if (prevMutation) {
            // This must be a transaction error
            const errDetails = {
                message: msg.message,
                hint: msg.hint
            };
            this._handleMutationError('error', eventId, errDetails);
            return;
        }
        if (((_a = msg['original-event']) === null || _a === void 0 ? void 0 : _a.hasOwnProperty('q')) && ((_b = msg['original-event']) === null || _b === void 0 ? void 0 : _b.op) === 'add-query') {
            const q = (_c = msg['original-event']) === null || _c === void 0 ? void 0 : _c.q;
            const hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(q);
            this.notifyQueryError((0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(q), errorMessage);
            this.notifyQueryOnceError(q, hash, eventId, errorMessage);
            return;
        }
        const isInitError = ((_d = msg['original-event']) === null || _d === void 0 ? void 0 : _d.op) === 'init';
        if (isInitError) {
            if (msg.type === 'record-not-found' && ((_e = msg.hint) === null || _e === void 0 ? void 0 : _e['record-type']) === 'app-user') {
                // User has been logged out
                this.changeCurrentUser(null);
                return;
            }
            // We failed to init
            this._setStatus(STATUS.ERRORED, errorMessage);
            this.notifyAll();
            return;
        }
        // We've caught some error which has no corresponding listener.
        // Let's console.error to let the user know.
        const errorObj = Object.assign({}, msg);
        delete errorObj.message;
        delete errorObj.hint;
        console.error(msg.message, errorObj);
        if (msg.hint) {
            console.error('This error comes with some debugging information. Here it is: \n', msg.hint);
        }
    }
    notifyQueryOnceError(q, hash, eventId, e) {
        var _a;
        const r = (_a = this.queryOnceDfds[hash]) === null || _a === void 0 ? void 0 : _a.find((r)=>r.eventId === eventId);
        if (!r) return;
        r.dfd.reject(e);
        this._completeQueryOnce(q, hash, r.dfd);
    }
    _setAttrs(attrs) {
        this.attrs = attrs.reduce((acc, attr)=>{
            acc[attr.id] = attr;
            return acc;
        }, {});
        this.notifyAttrsSubs();
    }
    _startQuerySub(q, hash) {
        const eventId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$uuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
        this.querySubs.set((prev)=>{
            prev[hash] = prev[hash] || {
                q,
                result: null,
                eventId
            };
            return prev;
        });
        this._trySendAuthed(eventId, {
            op: 'add-query',
            q
        });
        return eventId;
    }
    /**
     *  When a user subscribes to a query the following side effects occur:
     *
     *  - We update querySubs to include the new query
     *  - We update queryCbs to include the new cb
     *  - If we already have a result for the query we call cb immediately
     *  - We send the server an `add-query` message
     *
     *  Returns an unsubscribe function
     */ subscribeQuery(q, cb) {
        var _a;
        const hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(q);
        const prevResult = this.getPreviousResult(q);
        if (prevResult) {
            cb(prevResult);
        }
        this.queryCbs[hash] = (_a = this.queryCbs[hash]) !== null && _a !== void 0 ? _a : [];
        this.queryCbs[hash].push({
            q,
            cb
        });
        this._startQuerySub(q, hash);
        return ()=>{
            this._unsubQuery(q, hash, cb);
        };
    }
    queryOnce(q) {
        var _a;
        const dfd = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$Deferred$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Deferred"]();
        if (!this._isOnline) {
            dfd.reject(new Error("We can't run `queryOnce`, because the device is offline."));
            return dfd.promise;
        }
        if (!this.querySubs) {
            dfd.reject(new Error("We can't run `queryOnce` on the backend. Use adminAPI.query instead: https://www.instantdb.com/docs/backend#query"));
            return dfd.promise;
        }
        const hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(q);
        const eventId = this._startQuerySub(q, hash);
        this.queryOnceDfds[hash] = (_a = this.queryOnceDfds[hash]) !== null && _a !== void 0 ? _a : [];
        this.queryOnceDfds[hash].push({
            q,
            dfd,
            eventId
        });
        setTimeout(()=>dfd.reject(new Error('Query timed out')), QUERY_ONCE_TIMEOUT);
        return dfd.promise;
    }
    _completeQueryOnce(q, hash, dfd) {
        if (!this.queryOnceDfds[hash]) return;
        this.queryOnceDfds[hash] = this.queryOnceDfds[hash].filter((r)=>r.dfd !== dfd);
        this._cleanupQuery(q, hash);
    }
    _unsubQuery(q, hash, cb) {
        if (!this.queryCbs[hash]) return;
        this.queryCbs[hash] = this.queryCbs[hash].filter((r)=>r.cb !== cb);
        this._cleanupQuery(q, hash);
    }
    _cleanupQuery(q, hash) {
        var _a, _b;
        const hasListeners = ((_a = this.queryCbs[hash]) === null || _a === void 0 ? void 0 : _a.length) || ((_b = this.queryOnceDfds[hash]) === null || _b === void 0 ? void 0 : _b.length);
        if (hasListeners) return;
        delete this.queryCbs[hash];
        delete this.queryOnceDfds[hash];
        this._trySendAuthed((0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$uuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(), {
            op: 'remove-query',
            q
        });
    }
    // When we `pushTx`, it's possible that we don't yet have `this.attrs`
    // This means that `tx-steps` in `pendingMutations` will include `add-attr`
    // commands for attrs that already exist.
    //
    // This will also affect `add-triple` and `retract-triple` which
    // reference attr-ids that do not match the server.
    //
    // We fix this by rewriting `tx-steps` in each `pendingMutation`.
    // We remove `add-attr` commands for attrs that already exist.
    // We update `add-triple` and `retract-triple` commands to use the
    // server attr-ids.
    _rewriteMutations(attrs, muts) {
        if (!attrs) return muts;
        const findExistingAttr = (attr)=>{
            const [_, etype, label] = attr['forward-identity'];
            const existing = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$instaml$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.getAttrByFwdIdentName(attrs, etype, label);
            return existing;
        };
        const findReverseAttr = (attr)=>{
            const [_, etype, label] = attr['forward-identity'];
            const revAttr = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$instaml$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.getAttrByReverseIdentName(attrs, etype, label);
            return revAttr;
        };
        const mapping = {
            attrIdMap: {},
            refSwapAttrIds: new Set()
        };
        const rewriteTxSteps = (txSteps)=>{
            const retTxSteps = [];
            for (const txStep of txSteps){
                const [action] = txStep;
                // Handles add-attr
                // If existing, we drop it, and track it
                // to update add/retract triples
                if (action === 'add-attr') {
                    const [_action, attr] = txStep;
                    const existing = findExistingAttr(attr);
                    if (existing) {
                        mapping.attrIdMap[attr.id] = existing.id;
                        continue;
                    }
                    if (attr['value-type'] === 'ref') {
                        const revAttr = findReverseAttr(attr);
                        if (revAttr) {
                            mapping.attrIdMap[attr.id] = revAttr.id;
                            mapping.refSwapAttrIds.add(attr.id);
                            continue;
                        }
                    }
                }
                // Handles add-triple|retract-triple
                // If in mapping, we update the attr-id
                const newTxStep = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$instaml$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.rewriteStep(mapping, txStep);
                retTxSteps.push(newTxStep);
            }
            return retTxSteps;
        };
        const rewritten = new Map();
        for (const [k, mut] of muts.entries()){
            rewritten.set(k, Object.assign(Object.assign({}, mut), {
                'tx-steps': rewriteTxSteps(mut['tx-steps'])
            }));
        }
        return rewritten;
    }
    // ---------------------------
    // Transact
    optimisticAttrs() {
        var _a;
        const pendingMutationSteps = [
            ...this.pendingMutations.currentValue.values()
        ] // hack due to Map()
        .flatMap((x)=>x['tx-steps']);
        const deletedAttrIds = new Set(pendingMutationSteps.filter(([action, _attr])=>action === 'delete-attr').map(([_action, id])=>id));
        const pendingAttrs = [];
        for (const [_action, attr] of pendingMutationSteps){
            if (_action === 'add-attr') {
                pendingAttrs.push(attr);
            } else if (_action === 'update-attr' && attr.id && ((_a = this.attrs) === null || _a === void 0 ? void 0 : _a[attr.id])) {
                const fullAttr = Object.assign(Object.assign({}, this.attrs[attr.id]), attr);
                pendingAttrs.push(fullAttr);
            }
        }
        const attrsWithoutDeleted = [
            ...Object.values(this.attrs || {}),
            ...pendingAttrs
        ].filter((a)=>!deletedAttrIds.has(a.id));
        const attrsRecord = Object.fromEntries(attrsWithoutDeleted.map((a)=>[
                a.id,
                a
            ]));
        return attrsRecord;
    }
    /** Runs instaql on a query and a store */ dataForQuery(hash) {
        const errorMessage = this._errorMessage;
        if (errorMessage) {
            return {
                error: errorMessage
            };
        }
        if (!this.querySubs) return;
        if (!this.pendingMutations) return;
        const querySubVersion = this.querySubs.version();
        const querySubs = this.querySubs.currentValue;
        const pendingMutationsVersion = this.pendingMutations.version();
        const pendingMutations = this.pendingMutations.currentValue;
        const { q, result } = querySubs[hash] || {};
        if (!result) return;
        const cached = this._dataForQueryCache[hash];
        if (cached && querySubVersion === cached.querySubVersion && pendingMutationsVersion === cached.pendingMutationsVersion) {
            return cached.data;
        }
        const { store, pageInfo, aggregate } = result;
        const muts = this._rewriteMutations(store.attrs, pendingMutations);
        const txSteps = [
            ...muts.values()
        ].flatMap((x)=>x['tx-steps']);
        const newStore = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.transact(store, txSteps);
        const resp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$instaql$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({
            store: newStore,
            pageInfo,
            aggregate
        }, q);
        this._dataForQueryCache[hash] = {
            querySubVersion,
            pendingMutationsVersion,
            data: resp
        };
        return resp;
    }
    /** Re-compute all subscriptions */ notifyAll() {
        Object.keys(this.queryCbs).forEach((hash)=>{
            this.notifyOne(hash);
        });
    }
    loadedNotifyAll() {
        if (this.pendingMutations.isLoading() || this.querySubs.isLoading()) return;
        this.notifyAll();
    }
    shutdown() {
        var _a;
        this._isShutdown = true;
        (_a = this._ws) === null || _a === void 0 ? void 0 : _a.close();
    }
    /**
     * Sends mutation to server and schedules a timeout to cancel it if
     * we don't hear back in time.
     * Note: If we're offline we don't schedule a timeout, we'll schedule it
     * later once we're back online and send the mutation again
     *
     */ _sendMutation(eventId, mutation) {
        if (mutation.error) {
            this._handleMutationError('error', eventId, {
                error: mutation.error,
                message: mutation.error.message
            });
            return;
        }
        if (this.status !== STATUS.AUTHENTICATED) {
            this._finishTransaction('enqueued', eventId);
            return;
        }
        const timeoutMs = Math.max(5000, this.pendingMutations.currentValue.size * 5000);
        if (!this._isOnline) {
            this._finishTransaction('enqueued', eventId);
        } else {
            this._trySend(eventId, mutation);
            // If a transaction is pending for over 3 seconds,
            // we want to unblock the UX, so mark it as pending
            // and keep trying to process the transaction in the background
            setTimeout(()=>{
                this._finishTransaction('pending', eventId);
            }, 3000);
            setTimeout(()=>{
                if (!this._isOnline) {
                    return;
                }
                // If we are here, this means that we have sent this mutation, we are online
                // but we have not received a response. If it's this long, something must be wrong,
                // so we error with a timeout.
                this._handleMutationError('timeout', eventId, {
                    message: 'transaction timed out'
                });
            }, timeoutMs);
        }
    }
    // ---------------------------
    // Websocket
    /** Send messages we accumulated while we were connecting */ _flushPendingMessages() {
        const subs = Object.keys(this.queryCbs).map((hash)=>{
            return this.querySubs.currentValue[hash];
        });
        // Note: we should not have any nulls in subs, but we're
        // doing this defensively just in case.
        const safeSubs = subs.filter((x)=>x);
        safeSubs.forEach(({ eventId, q })=>{
            this._trySendAuthed(eventId, {
                op: 'add-query',
                q
            });
        });
        Object.values(this.queryOnceDfds).flat().forEach(({ eventId, q })=>{
            this._trySendAuthed(eventId, {
                op: 'add-query',
                q
            });
        });
        const muts = this._rewriteMutations(this.attrs, this.pendingMutations.currentValue);
        muts.forEach((mut, eventId)=>{
            if (!mut['tx-id']) {
                this._sendMutation(eventId, mut);
            }
        });
    }
    _trySendAuthed(...args) {
        if (this.status !== STATUS.AUTHENTICATED) {
            return;
        }
        this._trySend(...args);
    }
    _trySend(eventId, msg, opts) {
        if (this._ws.readyState !== WS_OPEN_STATUS) {
            return;
        }
        if (!ignoreLogging[msg.op]) {
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].info('[send]', this._ws._id, msg.op, msg);
        }
        this._ws.send(JSON.stringify(Object.assign({
            'client-event-id': eventId
        }, msg)));
    }
    _startSocket() {
        if (this._ws && this._ws.readyState == WS_CONNECTING_STATUS) {
            // Our current websocket is in a 'connecting' state.
            // There's no need to start another one, as the socket is
            // effectively fresh.
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].info('[socket][start]', this._ws._id, 'maintained as current ws, we were still in a connecting state');
            return;
        }
        const prevWs = this._ws;
        this._ws = createWebSocket(`${this.config.websocketURI}?app_id=${this.config.appId}`);
        this._ws.onopen = this._wsOnOpen;
        this._ws.onmessage = this._wsOnMessage;
        this._ws.onclose = this._wsOnClose;
        this._ws.onerror = this._wsOnError;
        __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].info('[socket][start]', this._ws._id);
        if ((prevWs === null || prevWs === void 0 ? void 0 : prevWs.readyState) === WS_OPEN_STATUS) {
            // When the network dies, it doesn't always mean that our
            // socket connection will fire a close event.
            //
            // We _could_ re-use the old socket, if the network drop was a
            // few seconds. But, to be safe right now we always create a new socket.
            //
            // This means that we have to make sure to kill the previous one ourselves.
            // c.f https://issues.chromium.org/issues/41343684
            __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].info('[socket][start]', this._ws._id, 'close previous ws id = ', prevWs._id);
            prevWs.close();
        }
    }
    /**
     * Given a key, returns a stable local id, unique to this device and app.
     *
     * This can be useful if you want to create guest ids for example.
     *
     * Note: If the user deletes their local storage, this id will change.
     *
     * We use this._localIdPromises to ensure that we only generate a local
     * id once, even if multiple callers call this function concurrently.
     */ getLocalId(name) {
        return __awaiter(this, void 0, void 0, function*() {
            const k = `localToken_${name}`;
            const id = yield this._persister.getItem(k);
            if (id) return id;
            if (this._localIdPromises[k]) {
                return this._localIdPromises[k];
            }
            const newId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$uuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
            this._localIdPromises[k] = this._persister.setItem(k, newId).then(()=>newId);
            return this._localIdPromises[k];
        });
    }
    // ----
    // Auth
    _replaceUrlAfterOAuth() {
        if (typeof URL === 'undefined') {
            return;
        }
        const url = new URL(window.location.href);
        if (url.searchParams.get(OAUTH_REDIRECT_PARAM)) {
            const startUrl = url.toString();
            url.searchParams.delete(OAUTH_REDIRECT_PARAM);
            url.searchParams.delete('code');
            url.searchParams.delete('error');
            const newPath = url.pathname + (url.searchParams.size ? '?' + url.searchParams : '') + url.hash;
            // Note: In next.js, this will revert to the old state if user navigates
            //       back. We would need to allow framework specific routing to work
            //       around that problem.
            history.replaceState(history.state, '', newPath);
            // navigation is part of the HTML spec, but not supported by Safari
            // or Firefox yet:
            // https://developer.mozilla.org/en-US/docs/Web/API/Navigation_API#browser_compatibility
            if (// @ts-ignore (waiting for ts support)
            typeof navigation === 'object' && // @ts-ignore (waiting for ts support)
            typeof navigation.addEventListener === 'function' && // @ts-ignore (waiting for ts support)
            typeof navigation.removeEventListener === 'function') {
                let ran = false;
                // The next.js app router will reset the URL when the router loads.
                // This puts it back after the router loads.
                const listener = (e)=>{
                    var _a;
                    if (!ran) {
                        ran = true;
                        // @ts-ignore (waiting for ts support)
                        navigation.removeEventListener('navigate', listener);
                        if (!e.userInitiated && e.navigationType === 'replace' && ((_a = e.destination) === null || _a === void 0 ? void 0 : _a.url) === startUrl) {
                            history.replaceState(history.state, '', newPath);
                        }
                    }
                };
                // @ts-ignore (waiting for ts support)
                navigation.addEventListener('navigate', listener);
            }
        }
    }
    /**
     *
     * @returns Promise<null | {error: {message: string}}>
     */ _oauthLoginInit() {
        return __awaiter(this, void 0, void 0, function*() {
            var _a, _b, _c, _d;
            if (typeof window === 'undefined' || typeof window.location === 'undefined' || typeof URLSearchParams === 'undefined') {
                return null;
            }
            const params = new URLSearchParams(window.location.search);
            if (!params.get(OAUTH_REDIRECT_PARAM)) {
                return null;
            }
            const error = params.get('error');
            if (error) {
                this._replaceUrlAfterOAuth();
                return {
                    error: {
                        message: error
                    }
                };
            }
            const code = params.get('code');
            if (!code) {
                return null;
            }
            this._replaceUrlAfterOAuth();
            try {
                const { user } = yield __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$authAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.exchangeCodeForToken({
                    apiURI: this.config.apiURI,
                    appId: this.config.appId,
                    code
                });
                this.setCurrentUser(user);
                return null;
            } catch (e) {
                if (((_a = e === null || e === void 0 ? void 0 : e.body) === null || _a === void 0 ? void 0 : _a.type) === 'record-not-found' && ((_c = (_b = e === null || e === void 0 ? void 0 : e.body) === null || _b === void 0 ? void 0 : _b.hint) === null || _c === void 0 ? void 0 : _c['record-type']) === 'app-oauth-code' && (yield this._hasCurrentUser())) {
                    // We probably just weren't able to clean up the URL, so
                    // let's just ignore this error
                    return null;
                }
                const message = ((_d = e === null || e === void 0 ? void 0 : e.body) === null || _d === void 0 ? void 0 : _d.message) || 'Error logging in.';
                return {
                    error: {
                        message
                    }
                };
            }
        });
    }
    _waitForOAuthCallbackResponse() {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this._oauthCallbackResponse;
        });
    }
    __subscribeMutationErrors(cb) {
        this.mutationErrorCbs.push(cb);
        return ()=>{
            this.mutationErrorCbs = this.mutationErrorCbs.filter((x)=>x !== cb);
        };
    }
    subscribeAuth(cb) {
        this.authCbs.push(cb);
        const currUserCached = this._currentUserCached;
        if (!currUserCached.isLoading) {
            cb(this._currentUserCached);
        }
        let unsubbed = false;
        this.getCurrentUser().then((resp)=>{
            if (unsubbed) return;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["areObjectsDeepEqual"])(resp, currUserCached)) return;
            cb(resp);
        });
        return ()=>{
            unsubbed = true;
            this.authCbs = this.authCbs.filter((x)=>x !== cb);
        };
    }
    getAuth() {
        return __awaiter(this, void 0, void 0, function*() {
            const { user, error } = yield this.getCurrentUser();
            if (error) {
                throw error;
            }
            return user;
        });
    }
    subscribeConnectionStatus(cb) {
        this.connectionStatusCbs.push(cb);
        return ()=>{
            this.connectionStatusCbs = this.connectionStatusCbs.filter((x)=>x !== cb);
        };
    }
    subscribeAttrs(cb) {
        this.attrsCbs.push(cb);
        if (this.attrs) {
            cb(this.attrs);
        }
        return ()=>{
            this.attrsCbs = this.attrsCbs.filter((x)=>x !== cb);
        };
    }
    notifyAuthSubs(user) {
        this.authCbs.forEach((cb)=>cb(user));
    }
    notifyMutationErrorSubs(error) {
        this.mutationErrorCbs.forEach((cb)=>cb(error));
    }
    notifyAttrsSubs() {
        if (!this.attrs) return;
        const oas = this.optimisticAttrs();
        this.attrsCbs.forEach((cb)=>cb(oas));
    }
    notifyConnectionStatusSubs(status) {
        this.connectionStatusCbs.forEach((cb)=>cb(status));
    }
    setCurrentUser(user) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this._persister.setItem(currentUserKey, JSON.stringify(user));
        });
    }
    getCurrentUserCached() {
        return this._currentUserCached;
    }
    getCurrentUser() {
        return __awaiter(this, void 0, void 0, function*() {
            const oauthResp = yield this._waitForOAuthCallbackResponse();
            if (oauthResp === null || oauthResp === void 0 ? void 0 : oauthResp.error) {
                const errorV = {
                    error: oauthResp.error,
                    user: undefined
                };
                this._currentUserCached = Object.assign({
                    isLoading: false
                }, errorV);
                return errorV;
            }
            const user = yield this._persister.getItem(currentUserKey);
            const userV = {
                user: JSON.parse(user),
                error: undefined
            };
            this._currentUserCached = Object.assign({
                isLoading: false
            }, userV);
            return userV;
        });
    }
    _hasCurrentUser() {
        return __awaiter(this, void 0, void 0, function*() {
            const user = yield this._persister.getItem(currentUserKey);
            return JSON.parse(user) != null;
        });
    }
    changeCurrentUser(newUser) {
        return __awaiter(this, void 0, void 0, function*() {
            var _a;
            const { user: oldUser } = yield this.getCurrentUser();
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["areObjectsDeepEqual"])(oldUser, newUser)) {
                // We were already logged in as the newUser, don't
                // bother updating
                return;
            }
            yield this.setCurrentUser(newUser);
            // We need to remove all `result` from querySubs,
            // as they are no longer valid for the new user
            this.updateUser(newUser);
            try {
                (_a = this._broadcastChannel) === null || _a === void 0 ? void 0 : _a.postMessage({
                    type: 'auth'
                });
            } catch (error) {
                console.error('Error posting message to broadcast channel', error);
            }
        });
    }
    updateUser(newUser) {
        const newV = {
            error: undefined,
            user: newUser
        };
        this._currentUserCached = Object.assign({
            isLoading: false
        }, newV);
        this._dataForQueryCache = {};
        this.querySubs.set((prev)=>{
            Object.keys(prev).forEach((k)=>{
                delete prev[k].result;
            });
            return prev;
        });
        this._reconnectTimeoutMs = 0;
        this._ws.close();
        this._oauthCallbackResponse = null;
        this.notifyAuthSubs(newV);
    }
    sendMagicCode({ email }) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$authAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.sendMagicCode({
            apiURI: this.config.apiURI,
            appId: this.config.appId,
            email: email
        });
    }
    signInWithMagicCode(_a) {
        return __awaiter(this, arguments, void 0, function*({ email, code }) {
            const res = yield __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$authAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.verifyMagicCode({
                apiURI: this.config.apiURI,
                appId: this.config.appId,
                email,
                code
            });
            yield this.changeCurrentUser(res.user);
            return res;
        });
    }
    signInWithCustomToken(authToken) {
        return __awaiter(this, void 0, void 0, function*() {
            const res = yield __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$authAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.verifyRefreshToken({
                apiURI: this.config.apiURI,
                appId: this.config.appId,
                refreshToken: authToken
            });
            yield this.changeCurrentUser(res.user);
            return res;
        });
    }
    signOut() {
        return __awaiter(this, void 0, void 0, function*() {
            var _a;
            const currentUser = yield this.getCurrentUser();
            const refreshToken = (_a = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _a === void 0 ? void 0 : _a.refresh_token;
            if (refreshToken) {
                try {
                    yield __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$authAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.signOut({
                        apiURI: this.config.apiURI,
                        appId: this.config.appId,
                        refreshToken
                    });
                } catch (e) {}
            }
            yield this.changeCurrentUser(null);
        });
    }
    /**
     * Creates an OAuth authorization URL.
     * @param {Object} params - The parameters to create the authorization URL.
     * @param {string} params.clientName - The name of the client requesting authorization.
     * @param {string} params.redirectURL - The URL to redirect users to after authorization.
     * @returns {string} The created authorization URL.
     */ createAuthorizationURL({ clientName, redirectURL }) {
        const { apiURI, appId } = this.config;
        return `${apiURI}/runtime/oauth/start?app_id=${appId}&client_name=${clientName}&redirect_uri=${redirectURL}`;
    }
    /**
     * @param {Object} params
     * @param {string} params.code - The code received from the OAuth service.
     * @param {string} [params.codeVerifier] - The code verifier used to generate the code challenge.
     */ exchangeCodeForToken(_a) {
        return __awaiter(this, arguments, void 0, function*({ code, codeVerifier }) {
            const res = yield __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$authAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.exchangeCodeForToken({
                apiURI: this.config.apiURI,
                appId: this.config.appId,
                code: code,
                codeVerifier
            });
            yield this.changeCurrentUser(res.user);
            return res;
        });
    }
    issuerURI() {
        const { apiURI, appId } = this.config;
        return `${apiURI}/runtime/${appId}`;
    }
    /**
     * @param {Object} params
     * @param {string} params.clientName - The name of the client requesting authorization.
     * @param {string} params.idToken - The id_token from the external service
     * @param {string | null | undefined} [params.nonce] - The nonce used when requesting the id_token from the external service
     */ signInWithIdToken(_a) {
        return __awaiter(this, arguments, void 0, function*({ idToken, clientName, nonce }) {
            var _b;
            const currentUser = yield this.getCurrentUser();
            const refreshToken = (_b = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _b === void 0 ? void 0 : _b.refresh_token;
            const res = yield __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$authAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.signInWithIdToken({
                apiURI: this.config.apiURI,
                appId: this.config.appId,
                idToken,
                clientName,
                nonce,
                refreshToken
            });
            yield this.changeCurrentUser(res.user);
            return res;
        });
    }
    // --------
    // Rooms
    joinRoom(roomId) {
        if (!this._rooms[roomId]) {
            this._rooms[roomId] = {
                isConnected: false,
                error: undefined
            };
        }
        this._presence[roomId] = this._presence[roomId] || {};
        this._tryJoinRoom(roomId);
        return ()=>{
            this._cleanupRoom(roomId);
        };
    }
    _cleanupRoom(roomId) {
        var _a, _b, _c, _d;
        if (!((_b = (_a = this._presence[roomId]) === null || _a === void 0 ? void 0 : _a.handlers) === null || _b === void 0 ? void 0 : _b.length) && !Object.keys((_c = this._broadcastSubs[roomId]) !== null && _c !== void 0 ? _c : {}).length) {
            const isConnected = (_d = this._rooms[roomId]) === null || _d === void 0 ? void 0 : _d.isConnected;
            delete this._rooms[roomId];
            delete this._presence[roomId];
            delete this._broadcastSubs[roomId];
            if (isConnected) {
                this._tryLeaveRoom(roomId);
            } else {
                this._roomsPendingLeave[roomId] = true;
            }
        }
    }
    // --------
    // Presence
    // TODO: look into typing again
    getPresence(roomType, roomId, opts = {}) {
        const room = this._rooms[roomId];
        const presence = this._presence[roomId];
        if (!room || !presence || !presence.result) return null;
        return Object.assign(Object.assign({}, (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$presence$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["buildPresenceSlice"])(presence.result, opts, this._sessionId)), {
            isLoading: !room.isConnected,
            error: room.error
        });
    }
    // TODO: look into typing again
    publishPresence(roomType, roomId, partialData) {
        const room = this._rooms[roomId];
        const presence = this._presence[roomId];
        if (!room || !presence) {
            return;
        }
        presence.result = presence.result || {};
        const data = Object.assign(Object.assign({}, presence.result.user), partialData);
        presence.result.user = data;
        if (!room.isConnected) {
            return;
        }
        this._trySetPresence(roomId, data);
        this._notifyPresenceSubs(roomId);
    }
    _trySetPresence(roomId, data) {
        this._trySendAuthed((0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$uuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(), {
            op: 'set-presence',
            'room-id': roomId,
            data
        });
    }
    _tryJoinRoom(roomId) {
        this._trySendAuthed((0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$uuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(), {
            op: 'join-room',
            'room-id': roomId
        });
        delete this._roomsPendingLeave[roomId];
    }
    _tryLeaveRoom(roomId) {
        this._trySendAuthed((0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$uuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(), {
            op: 'leave-room',
            'room-id': roomId
        });
    }
    // TODO: look into typing again
    subscribePresence(roomType, roomId, opts, cb) {
        const leaveRoom = this.joinRoom(roomId);
        const handler = Object.assign(Object.assign({}, opts), {
            roomId,
            cb,
            prev: null
        });
        this._presence[roomId] = this._presence[roomId] || {};
        this._presence[roomId].handlers = this._presence[roomId].handlers || [];
        this._presence[roomId].handlers.push(handler);
        this._notifyPresenceSub(roomId, handler);
        return ()=>{
            var _a, _b, _c;
            this._presence[roomId].handlers = (_c = (_b = (_a = this._presence[roomId]) === null || _a === void 0 ? void 0 : _a.handlers) === null || _b === void 0 ? void 0 : _b.filter((x)=>x !== handler)) !== null && _c !== void 0 ? _c : [];
            leaveRoom();
        };
    }
    _notifyPresenceSubs(roomId) {
        var _a, _b;
        (_b = (_a = this._presence[roomId]) === null || _a === void 0 ? void 0 : _a.handlers) === null || _b === void 0 ? void 0 : _b.forEach((handler)=>{
            this._notifyPresenceSub(roomId, handler);
        });
    }
    _notifyPresenceSub(roomId, handler) {
        const slice = this.getPresence('', roomId, handler);
        if (!slice) {
            return;
        }
        if (handler.prev && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$presence$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasPresenceResponseChanged"])(slice, handler.prev)) {
            return;
        }
        handler.prev = slice;
        handler.cb(slice);
    }
    _patchPresencePeers(roomId, edits) {
        var _a, _b, _c, _d;
        const peers = ((_b = (_a = this._presence[roomId]) === null || _a === void 0 ? void 0 : _a.result) === null || _b === void 0 ? void 0 : _b.peers) || {};
        let sessions = Object.fromEntries(Object.entries(peers).map(([k, v])=>[
                k,
                {
                    data: v
                }
            ]));
        sessions[this._sessionId] = {
            data: (_d = (_c = this._presence[roomId]) === null || _c === void 0 ? void 0 : _c.result) === null || _d === void 0 ? void 0 : _d.user
        };
        for (let [path, op, value] of edits){
            if (op === '+' || op === 'r') {
                sessions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assocIn"])(sessions, path, value);
            }
            if (op === '-') {
                sessions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dissocIn"])(sessions, path);
            }
        }
        this._setPresencePeers(roomId, sessions);
    }
    _setPresencePeers(roomId, data) {
        const sessions = Object.assign({}, data);
        // no need to keep track of `user`
        delete sessions[this._sessionId];
        const peers = Object.fromEntries(Object.entries(sessions).map(([k, v])=>[
                k,
                v.data
            ]));
        this._presence = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assocIn"])(this._presence, [
            roomId,
            'result',
            'peers'
        ], peers);
    }
    // --------
    // Broadcast
    publishTopic({ roomType, roomId, topic, data }) {
        var _a;
        const room = this._rooms[roomId];
        if (!room) {
            return;
        }
        if (!room.isConnected) {
            this._broadcastQueue[roomId] = (_a = this._broadcastQueue[roomId]) !== null && _a !== void 0 ? _a : [];
            this._broadcastQueue[roomId].push({
                topic,
                roomType,
                data
            });
            return;
        }
        this._tryBroadcast(roomId, roomType, topic, data);
    }
    _tryBroadcast(roomId, roomType, topic, data) {
        this._trySendAuthed((0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$uuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(), {
            op: 'client-broadcast',
            'room-id': roomId,
            roomType,
            topic,
            data
        });
    }
    subscribeTopic(roomId, topic, cb) {
        const leaveRoom = this.joinRoom(roomId);
        this._broadcastSubs[roomId] = this._broadcastSubs[roomId] || {};
        this._broadcastSubs[roomId][topic] = this._broadcastSubs[roomId][topic] || [];
        this._broadcastSubs[roomId][topic].push(cb);
        this._presence[roomId] = this._presence[roomId] || {};
        return ()=>{
            this._broadcastSubs[roomId][topic] = this._broadcastSubs[roomId][topic].filter((x)=>x !== cb);
            if (!this._broadcastSubs[roomId][topic].length) {
                delete this._broadcastSubs[roomId][topic];
            }
            leaveRoom();
        };
    }
    _notifyBroadcastSubs(room, topic, msg) {
        var _a, _b, _c;
        (_c = (_b = (_a = this._broadcastSubs) === null || _a === void 0 ? void 0 : _a[room]) === null || _b === void 0 ? void 0 : _b[topic]) === null || _c === void 0 ? void 0 : _c.forEach((cb)=>{
            var _a, _b, _c, _d, _e, _f;
            const data = (_a = msg.data) === null || _a === void 0 ? void 0 : _a.data;
            const peer = msg.data['peer-id'] === this._sessionId ? (_c = (_b = this._presence[room]) === null || _b === void 0 ? void 0 : _b.result) === null || _c === void 0 ? void 0 : _c.user : (_f = (_e = (_d = this._presence[room]) === null || _d === void 0 ? void 0 : _d.result) === null || _e === void 0 ? void 0 : _e.peers) === null || _f === void 0 ? void 0 : _f[msg.data['peer-id']];
            return cb(data, peer);
        });
    }
    // --------
    // Storage
    uploadFile(path, file, opts) {
        return __awaiter(this, void 0, void 0, function*() {
            var _a;
            const currentUser = yield this.getCurrentUser();
            const refreshToken = (_a = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _a === void 0 ? void 0 : _a.refresh_token;
            return __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$StorageAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.uploadFile(Object.assign(Object.assign({}, opts), {
                apiURI: this.config.apiURI,
                appId: this.config.appId,
                path: path,
                file,
                refreshToken: refreshToken
            }));
        });
    }
    deleteFile(path) {
        return __awaiter(this, void 0, void 0, function*() {
            var _a;
            const currentUser = yield this.getCurrentUser();
            const refreshToken = (_a = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _a === void 0 ? void 0 : _a.refresh_token;
            const result = yield __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$StorageAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.deleteFile({
                apiURI: this.config.apiURI,
                appId: this.config.appId,
                path,
                refreshToken: refreshToken
            });
            return result;
        });
    }
    // Deprecated Storage API (Jan 2025)
    // ---------------------------------
    upload(path, file) {
        return __awaiter(this, void 0, void 0, function*() {
            var _a;
            const currentUser = yield this.getCurrentUser();
            const refreshToken = (_a = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _a === void 0 ? void 0 : _a.refresh_token;
            const fileName = path || file.name;
            const url = yield __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$StorageAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.getSignedUploadUrl({
                apiURI: this.config.apiURI,
                appId: this.config.appId,
                fileName: fileName,
                refreshToken: refreshToken
            });
            const isSuccess = yield __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$StorageAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.upload(url, file);
            return isSuccess;
        });
    }
    getDownloadUrl(path) {
        return __awaiter(this, void 0, void 0, function*() {
            var _a;
            const currentUser = yield this.getCurrentUser();
            const refreshToken = (_a = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _a === void 0 ? void 0 : _a.refresh_token;
            const url = yield __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$StorageAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.getDownloadUrl({
                apiURI: this.config.apiURI,
                appId: this.config.appId,
                path: path,
                refreshToken: refreshToken
            });
            return url;
        });
    }
} //# sourceMappingURL=Reactor.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/schemaTypes.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "DataAttrDef": (()=>DataAttrDef),
    "EntityDef": (()=>EntityDef),
    "InstantGraph": (()=>InstantGraph),
    "InstantSchemaDef": (()=>InstantSchemaDef),
    "LinkAttrDef": (()=>LinkAttrDef)
});
class DataAttrDef {
    constructor(valueType, required, config = {
        indexed: false,
        unique: false
    }){
        this.valueType = valueType;
        this.required = required;
        this.config = config;
    }
    optional() {
        return new DataAttrDef(this.valueType, false);
    }
    unique() {
        return new DataAttrDef(this.valueType, this.required, Object.assign(Object.assign({}, this.config), {
            unique: true
        }));
    }
    indexed() {
        return new DataAttrDef(this.valueType, this.required, Object.assign(Object.assign({}, this.config), {
            indexed: true
        }));
    }
}
class LinkAttrDef {
    constructor(cardinality, entityName){
        this.cardinality = cardinality;
        this.entityName = entityName;
    }
}
class EntityDef {
    constructor(attrs, links){
        this.attrs = attrs;
        this.links = links;
    }
    asType() {
        return new EntityDef(this.attrs, this.links);
    }
}
class InstantSchemaDef {
    constructor(entities, links, rooms){
        this.entities = entities;
        this.links = links;
        this.rooms = rooms;
    }
    /**
     * @deprecated
     * `withRoomSchema` is deprecated. Define your schema in `rooms` directly:
     *
     * @example
     * // Before:
     * const schema = i.schema({
     *   // ...
     * }).withRoomSchema<RoomSchema>()
     *
     * // After
     * const schema = i.schema({
     *  rooms: {
     *    // ...
     *  }
     * })
     *
     * @see https://instantdb.com/docs/presence-and-topics#typesafety
     */ withRoomSchema() {
        return new InstantSchemaDef(this.entities, this.links, {});
    }
}
class InstantGraph {
    constructor(entities, links){
        this.entities = entities;
        this.links = links;
    }
    withRoomSchema() {
        return new InstantGraph(this.entities, this.links);
    }
} //# sourceMappingURL=schemaTypes.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/schema.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "i": (()=>i)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/schemaTypes.js [app-client] (ecmascript)");
;
// ==========
// API
/**
 * @deprecated
 * `i.graph` is deprecated. Use `i.schema` instead.
 *
 * @example
 * // Before
 * i.graph(entities, links).withRoomSchema<RoomType>();
 *
 * // After
 * i.schema({ entities, links, rooms })
 *
 * @see
 * https://instantdb.com/docs/schema
 */ function graph(entities, links) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantSchemaDef"](enrichEntitiesWithLinks(entities, links), // (XXX): LinksDef<any> stems from TypeScripts inability to reconcile the
    // type EntitiesWithLinks<EntitiesWithoutLinks, Links> with
    // EntitiesWithoutLinks. TypeScript is strict about ensuring that types are
    // correctly aligned and does not allow for substituting a type that might
    // be broader or have additional properties.
    links, undefined);
}
/**
 * Creates an entity definition, to be used in conjunction with `i.graph`.
 *
 * @see https://instantdb.com/docs/schema
 * @example
 *   {
 *     posts: i.entity({
 *       title: i.string(),
 *       body: i.string(),
 *     }),
 *     comments: i.entity({
 *       body: i.string(),
 *     })
 *   }
 */ function entity(attrs) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EntityDef"](attrs, {});
}
function string() {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataAttrDef"]('string', true);
}
function number() {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataAttrDef"]('number', true);
}
function boolean() {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataAttrDef"]('boolean', true);
}
function date() {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataAttrDef"]('date', true);
}
function json() {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataAttrDef"]('json', true);
}
function any() {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataAttrDef"]('json', true);
}
// ==========
// internal
function enrichEntitiesWithLinks(entities, links) {
    var _a, _b, _c, _d;
    const linksIndex = {
        fwd: {},
        rev: {}
    };
    for (const linkDef of Object.values(links)){
        (_a = linksIndex.fwd)[_b = linkDef.forward.on] || (_a[_b] = {});
        (_c = linksIndex.rev)[_d = linkDef.reverse.on] || (_c[_d] = {});
        linksIndex.fwd[linkDef.forward.on][linkDef.forward.label] = {
            entityName: linkDef.reverse.on,
            cardinality: linkDef.forward.has
        };
        linksIndex.rev[linkDef.reverse.on][linkDef.reverse.label] = {
            entityName: linkDef.forward.on,
            cardinality: linkDef.reverse.has
        };
    }
    const enrichedEntities = Object.fromEntries(Object.entries(entities).map(([name, def])=>[
            name,
            new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EntityDef"](def.attrs, Object.assign(Object.assign({}, linksIndex.fwd[name]), linksIndex.rev[name]))
        ]));
    return enrichedEntities;
}
/**
 * Lets you define a schema for your database.
 *
 * You can define entities, links between entities, and if you use
 * presence, you can define rooms.
 *
 * You can push this schema to your database with the CLI,
 * or use it inside `init`, to get typesafety and autocompletion.
 *
 * @see https://instantdb.com/docs/schema
 * @example
 *   i.schema({
 *     entities: { },
 *     links: { },
 *     rooms: { }
 *   });
 */ function schema({ entities, links, rooms }) {
    const linksDef = links !== null && links !== void 0 ? links : {};
    const roomsDef = rooms !== null && rooms !== void 0 ? rooms : {};
    return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantSchemaDef"](enrichEntitiesWithLinks(entities, linksDef), // (XXX): LinksDef<any> stems from TypeScripts inability to reconcile the
    // type EntitiesWithLinks<EntitiesWithoutLinks, Links> with
    // EntitiesWithoutLinks. TypeScript is strict about ensuring that types are
    // correctly aligned and does not allow for substituting a type that might
    // be broader or have additional properties.
    linksDef, roomsDef);
}
const i = {
    // constructs
    graph,
    schema,
    entity,
    // value types
    string,
    number,
    boolean,
    date,
    json,
    any
}; //# sourceMappingURL=schema.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/devtool.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "createDevtool": (()=>createDevtool)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$flags$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/flags.js [app-client] (ecmascript)");
;
let currentDevtool;
function createDevtool(appId, config) {
    currentDevtool === null || currentDevtool === void 0 ? void 0 : currentDevtool.dispose();
    const iframeContrainer = createIframeContainer(config);
    const toggler = createToggler(config, toggleView);
    const iframe = createIframe(getSrc(appId));
    function onPostMessage(event) {
        var _a;
        if (event.source !== iframe.element.contentWindow) return;
        if (((_a = event.data) === null || _a === void 0 ? void 0 : _a.type) === 'close' && iframeContrainer.isVisible()) {
            toggleView();
        }
    }
    function onKeyDown(event) {
        const isToggleShortcut = event.shiftKey && event.ctrlKey && event.key === '0';
        const isEsc = event.key === 'Escape' || event.key === 'Esc';
        if (isToggleShortcut) {
            toggleView();
        } else if (isEsc && iframeContrainer.isVisible()) {
            toggleView();
        }
    }
    function toggleView() {
        if (iframeContrainer.isVisible()) {
            iframeContrainer.element.style.display = 'none';
        } else {
            iframeContrainer.element.style.display = 'block';
            // lazily render iframe on first open
            if (!iframeContrainer.element.contains(iframe.element)) {
                iframeContrainer.element.appendChild(iframe.element);
            }
        }
    }
    function dispose() {
        iframeContrainer.element.remove();
        toggler.element.remove();
        removeEventListener('keydown', onKeyDown);
        removeEventListener('message', onPostMessage);
    }
    function create() {
        document.body.appendChild(iframeContrainer.element);
        document.body.appendChild(toggler.element);
        addEventListener('keydown', onKeyDown);
        addEventListener('message', onPostMessage);
        currentDevtool = {
            dispose
        };
    }
    return create();
}
function getSrc(appId) {
    const useLocalDashboard = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$flags$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.devBackend || __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$flags$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.devtoolLocalDashboard;
    const src = `${useLocalDashboard ? 'http://localhost:3000' : 'https://instantdb.com'}/_devtool?appId=${appId}`;
    return src;
}
function createIframe(src) {
    const element = document.createElement('iframe');
    element.src = src;
    element.className = 'instant-devtool-iframe';
    Object.assign(element.style, {
        width: '100%',
        height: '100%',
        backgroundColor: 'white',
        border: 'none'
    });
    return {
        element
    };
}
function createToggler(config, onClick) {
    const logoSVG = `
    <svg width="32" height="32" viewBox="0 0 512 512" fill="none" xmlns="http://www.w3.org/2000/svg">
      <rect width="512" height="512" fill="black"/>
      <rect x="97.0973" y="91.3297" width="140" height="330" fill="white"/>
    </svg>
  `;
    const element = document.createElement('button');
    element.innerHTML = logoSVG;
    element.className = 'instant-devtool-toggler';
    Object.assign(element.style, Object.assign(Object.assign({
        // pos
        position: 'fixed'
    }, cssPositionForToggler(config.position)), {
        height: '32px',
        width: '32px',
        // layout
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: '9010',
        // look
        padding: '0',
        margin: '0',
        border: 'none',
        cursor: 'pointer'
    }));
    element.addEventListener('click', onClick);
    return {
        element
    };
}
function cssPositionForToggler(position) {
    switch(position){
        case 'bottom-left':
            return {
                bottom: '24px',
                left: '24px'
            };
        case 'bottom-right':
            return {
                bottom: '24px',
                right: '24px'
            };
        case 'top-right':
            return {
                top: '24px',
                right: '24px'
            };
        case 'top-left':
            return {
                top: '24px',
                left: '24px'
            };
    }
}
function cssPositionForIframeContainer(position) {
    switch(position){
        case 'bottom-left':
            return {
                bottom: '24px',
                right: '24px',
                left: '60px',
                top: '72px'
            };
        case 'bottom-right':
            return {
                bottom: '24px',
                left: '24px',
                right: '60px',
                top: '72px'
            };
        case 'top-right':
            return {
                top: '24px',
                left: '24px',
                right: '60px',
                bottom: '72px'
            };
        case 'top-left':
            return {
                top: '24px',
                right: '24px',
                left: '60px',
                bottom: '72px'
            };
    }
}
function createIframeContainer(config) {
    const element = document.createElement('div');
    Object.assign(element.style, Object.assign(Object.assign({
        position: 'fixed'
    }, cssPositionForIframeContainer(config.position)), {
        display: 'block',
        borderRadius: '4px',
        border: '1px #ccc solid',
        boxShadow: '0px 0px 8px #00000044',
        backgroundColor: '#eee',
        zIndex: '999990'
    }));
    element.style.display = 'none';
    element.className = 'instant-devtool-container';
    function isVisible() {
        return element.style.display !== 'none';
    }
    return {
        element,
        isVisible
    };
} //# sourceMappingURL=devtool.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Auth": (()=>Auth),
    "InstantCoreDatabase": (()=>InstantCoreDatabase),
    "Storage": (()=>Storage),
    "coerceQuery": (()=>coerceQuery),
    "init": (()=>init),
    "init_experimental": (()=>init_experimental)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$instatx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/instatx.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$Reactor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/Reactor.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$IndexedDBStorage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/IndexedDBStorage.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$WindowNetworkListener$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/WindowNetworkListener.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/version.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$devtool$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/devtool.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
const defaultOpenDevtool = true;
// consts
const defaultConfig = {
    apiURI: 'https://api.instantdb.com',
    websocketURI: 'wss://api.instantdb.com/runtime/session'
};
// hmr
function initGlobalInstantCoreStore() {
    var _a;
    globalThis.__instantDbStore = (_a = globalThis.__instantDbStore) !== null && _a !== void 0 ? _a : {};
    return globalThis.__instantDbStore;
}
const globalInstantCoreStore = initGlobalInstantCoreStore();
/**
 * Functions to log users in and out.
 *
 * @see https://instantdb.com/docs/auth
 */ class Auth {
    constructor(db){
        this.db = db;
        /**
         * Sends a magic code to the user's email address.
         *
         * Once you send the magic code, see {@link auth.signInWithMagicCode} to let the
         * user verify.
         *
         * @see https://instantdb.com/docs/auth
         * @example
         *  db.auth.sendMagicCode({email: "example@gmail.com"})
         *    .catch((err) => console.error(err.body?.message))
         */ this.sendMagicCode = (params)=>{
            return this.db.sendMagicCode(params);
        };
        /**
         * Verify a magic code that was sent to the user's email address.
         *
         * @see https://instantdb.com/docs/auth
         *
         * @example
         *  db.auth.signInWithMagicCode({email: "example@gmail.com", code: "123456"})
         *       .catch((err) => console.error(err.body?.message))
         */ this.signInWithMagicCode = (params)=>{
            return this.db.signInWithMagicCode(params);
        };
        /**
         * Sign in a user with a refresh token
         *
         * @see https://instantdb.com/docs/backend#frontend-auth-sign-in-with-token
         *
         * @example
         *   // Get the token from your backend
         *   const token = await fetch('/signin', ...);
         *   //Sign in
         *   db.auth.signInWithToken(token);
         */ this.signInWithToken = (token)=>{
            return this.db.signInWithCustomToken(token);
        };
        /**
         * Create an authorization url to sign in with an external provider
         *
         * @see https://instantdb.com/docs/auth
         *
         * @example
         *   // Get the authorization url from your backend
         *   const url = db.auth.createAuthorizationUrl({
         *     clientName: "google",
         *     redirectURL: window.location.href,
         *   });
         *
         *   // Put it in a sign in link
         *   <a href={url}>Log in with Google</a>
         */ this.createAuthorizationURL = (params)=>{
            return this.db.createAuthorizationURL(params);
        };
        /**
         * Sign in with the id_token from an external provider like Google
         *
         * @see https://instantdb.com/docs/auth
         * @example
         *   db.auth
         *  .signInWithIdToken({
         *    // Token from external service
         *    idToken: id_token,
         *    // The name you gave the client when you registered it with Instant
         *    clientName: "google",
         *    // The nonce, if any, that you used when you initiated the auth flow
         *    // with the external service.
         *    nonce: your_nonce
         *  })
         *  .catch((err) => console.error(err.body?.message));
         *
         */ this.signInWithIdToken = (params)=>{
            return this.db.signInWithIdToken(params);
        };
        /**
         * Sign in with the id_token from an external provider like Google
         *
         * @see https://instantdb.com/docs/auth
         * @example
         *   db.auth
         *  .exchangeOAuthCode({
         *    // code received in redirect from OAuth callback
         *    code: code
         *    // The PKCE code_verifier, if any, that you used when you
         *    // initiated the auth flow
         *    codeVerifier: your_code_verifier
         *  })
         *  .catch((err) => console.error(err.body?.message));
         *
         */ this.exchangeOAuthCode = (params)=>{
            return this.db.exchangeCodeForToken(params);
        };
        /**
         * OpenID Discovery path for use with tools like
         * expo-auth-session that use auto-discovery of
         * OAuth parameters.
         *
         * @see https://instantdb.com/docs/auth
         * @example
         *   const discovery = useAutoDiscovery(
         *     db.auth.issuerURI()
         *   );
         */ this.issuerURI = ()=>{
            return this.db.issuerURI();
        };
        /**
         * Sign out the current user
         */ this.signOut = ()=>{
            return this.db.signOut();
        };
    }
}
/**
 * Functions to manage file storage.
 */ class Storage {
    constructor(db){
        this.db = db;
        /**
         * Uploads file at the provided path.
         *
         * @see https://instantdb.com/docs/storage
         * @example
         *   const [file] = e.target.files; // result of file input
         *   const data = await db.storage.uploadFile('photos/demo.png', file);
         */ this.uploadFile = (path, file, opts = {})=>{
            return this.db.uploadFile(path, file, opts);
        };
        /**
         * Deletes a file by path name.
         *
         * @see https://instantdb.com/docs/storage
         * @example
         *   await db.storage.delete('photos/demo.png');
         */ this.delete = (pathname)=>{
            return this.db.deleteFile(pathname);
        };
        // Deprecated Storage API (Jan 2025)
        // ---------------------------------
        /**
         * @deprecated. Use `db.storage.uploadFile` instead
         * remove in the future.
         */ this.upload = (pathname, file)=>{
            return this.db.upload(pathname, file);
        };
        /**
         * @deprecated Use `db.storage.uploadFile` instead
         */ this.put = this.upload;
        /**
         * @deprecated. getDownloadUrl will be removed in the future.
         * Use `useQuery` instead to query and fetch for valid urls
         *
         * db.useQuery({
         *   $files: {
         *     $: {
         *       where: {
         *         path: "moop.png"
         *       }
         *     }
         *   }
         * })
         */ this.getDownloadUrl = (pathname)=>{
            return this.db.getDownloadUrl(pathname);
        };
    }
}
// util
function coerceQuery(o) {
    // stringify and parse to remove undefined values
    return JSON.parse(JSON.stringify(o));
}
class InstantCoreDatabase {
    constructor(reactor){
        this.tx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$instatx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["txInit"])();
        this._reactor = reactor;
        this.auth = new Auth(this._reactor);
        this.storage = new Storage(this._reactor);
    }
    /**
     * Use this to write data! You can create, update, delete, and link objects
     *
     * @see https://instantdb.com/docs/instaml
     *
     * @example
     *   // Create a new object in the `goals` namespace
     *   const goalId = id();
     *   db.transact(tx.goals[goalId].update({title: "Get fit"}))
     *
     *   // Update the title
     *   db.transact(tx.goals[goalId].update({title: "Get super fit"}))
     *
     *   // Delete it
     *   db.transact(tx.goals[goalId].delete())
     *
     *   // Or create an association:
     *   todoId = id();
     *   db.transact([
     *    tx.todos[todoId].update({ title: 'Go on a run' }),
     *    tx.goals[goalId].link({todos: todoId}),
     *  ])
     */ transact(chunks) {
        return this._reactor.pushTx(chunks);
    }
    getLocalId(name) {
        return this._reactor.getLocalId(name);
    }
    /**
     * Use this to query your data!
     *
     * @see https://instantdb.com/docs/instaql
     *
     * @example
     *  // listen to all goals
     *  db.subscribeQuery({ goals: {} }, (resp) => {
     *    console.log(resp.data.goals)
     *  })
     *
     *  // goals where the title is "Get Fit"
     *  db.subscribeQuery(
     *    { goals: { $: { where: { title: "Get Fit" } } } },
     *    (resp) => {
     *      console.log(resp.data.goals)
     *    }
     *  )
     *
     *  // all goals, _alongside_ their todos
     *  db.subscribeQuery({ goals: { todos: {} } }, (resp) => {
     *    console.log(resp.data.goals)
     *  });
     */ subscribeQuery(query, cb) {
        return this._reactor.subscribeQuery(query, cb);
    }
    /**
     * Listen for the logged in state. This is useful
     * for deciding when to show a login screen.
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *   const unsub = db.subscribeAuth((auth) => {
     *     if (auth.user) {
     *     console.log('logged in as', auth.user.email)
     *    } else {
     *      console.log('logged out')
     *    }
     *  })
     */ subscribeAuth(cb) {
        return this._reactor.subscribeAuth(cb);
    }
    /**
     * One time query for the logged in state. This is useful
     * for scenarios where you want to know the current auth
     * state without subscribing to changes.
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *   const user = await db.getAuth();
     *   console.log('logged in as', user.email)
     */ getAuth() {
        return this._reactor.getAuth();
    }
    /**
     * Listen for connection status changes to Instant. This is useful
     * for building things like connectivity indicators
     *
     * @see https://www.instantdb.com/docs/patterns#connection-status
     * @example
     *   const unsub = db.subscribeConnectionStatus((status) => {
     *     const connectionState =
     *       status === 'connecting' || status === 'opened'
     *         ? 'authenticating'
     *       : status === 'authenticated'
     *         ? 'connected'
     *       : status === 'closed'
     *         ? 'closed'
     *       : status === 'errored'
     *         ? 'errored'
     *       : 'unexpected state';
     *
     *     console.log('Connection status:', connectionState);
     *   });
     */ subscribeConnectionStatus(cb) {
        return this._reactor.subscribeConnectionStatus(cb);
    }
    /**
     * Join a room to publish and subscribe to topics and presence.
     *
     * @see https://instantdb.com/docs/presence-and-topics
     * @example
     * // init
     * const db = init();
     * const room = db.joinRoom(roomType, roomId);
     * // usage
     * const unsubscribeTopic = room.subscribeTopic("foo", console.log);
     * const unsubscribePresence = room.subscribePresence({}, console.log);
     * room.publishTopic("hello", { message: "hello world!" });
     * room.publishPresence({ name: "joe" });
     * // later
     * unsubscribePresence();
     * unsubscribeTopic();
     * room.leaveRoom();
     */ joinRoom(roomType = '_defaultRoomType', roomId = '_defaultRoomId') {
        const leaveRoom = this._reactor.joinRoom(roomId);
        return {
            leaveRoom,
            subscribeTopic: (topic, onEvent)=>this._reactor.subscribeTopic(roomId, topic, onEvent),
            subscribePresence: (opts, onChange)=>this._reactor.subscribePresence(roomType, roomId, opts, onChange),
            publishTopic: (topic, data)=>this._reactor.publishTopic({
                    roomType,
                    roomId,
                    topic,
                    data
                }),
            publishPresence: (data)=>this._reactor.publishPresence(roomType, roomId, data),
            getPresence: (opts)=>this._reactor.getPresence(roomType, roomId, opts)
        };
    }
    shutdown() {
        delete globalInstantCoreStore[this._reactor.config.appId];
        this._reactor.shutdown();
    }
    /**
     * Use this for one-off queries.
     * Returns local data if available, otherwise fetches from the server.
     * Because we want to avoid stale data, this method will throw an error
     * if the user is offline or there is no active connection to the server.
     *
     * @see https://instantdb.com/docs/instaql
     *
     * @example
     *
     *  const resp = await db.queryOnce({ goals: {} });
     *  console.log(resp.data.goals)
     */ queryOnce(query) {
        return this._reactor.queryOnce(query);
    }
}
/**
 *
 * The first step: init your application!
 *
 * Visit https://instantdb.com/dash to get your `appId` :)
 *
 * @example
 *  import { init } from "@instantdb/core"
 *
 *  const db = init({ appId: "my-app-id" })
 *
 *  // You can also provide a schema for type safety and editor autocomplete!
 *
 *  import { init } from "@instantdb/core"
 *  import schema from ""../instant.schema.ts";
 *
 *  const db = init({ appId: "my-app-id", schema })
 *
 *  // To learn more: https://instantdb.com/docs/modeling-data
 */ function init(config, Storage, NetworkListener, versions) {
    const existingClient = globalInstantCoreStore[config.appId];
    if (existingClient) {
        return existingClient;
    }
    const reactor = new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$Reactor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](Object.assign(Object.assign(Object.assign({}, defaultConfig), config), {
        cardinalityInference: config.schema ? true : false
    }), Storage || __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$IndexedDBStorage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], NetworkListener || __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$WindowNetworkListener$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], Object.assign(Object.assign({}, versions || {}), {
        '@instantdb/core': __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
    }));
    const client = new InstantCoreDatabase(reactor);
    globalInstantCoreStore[config.appId] = client;
    handleDevtool(config.appId, config.devtool);
    return client;
}
function handleDevtool(appId, devtool) {
    if (typeof window === 'undefined' || typeof window.location === 'undefined') {
        return;
    }
    if (typeof devtool === 'boolean' && !devtool) {
        return;
    }
    const config = Object.assign({
        position: 'bottom-right',
        allowedHosts: [
            'localhost'
        ]
    }, typeof devtool === 'object' ? devtool : {});
    if (!config.allowedHosts.includes(window.location.hostname)) {
        return;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$devtool$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDevtool"])(appId, config);
}
/**
 * @deprecated
 * `init_experimental` is deprecated. You can replace it with `init`.
 *
 * @example
 *
 * // Before
 * import { init_experimental } from "@instantdb/core"
 * const db = init_experimental({  ...  });
 *
 * // After
 * import { init } from "@instantdb/core"
 * const db = init({ ...  });
 */ const init_experimental = init;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$Reactor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/Reactor.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$instatx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/instatx.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/weakHash.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$uuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/uuid.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$IndexedDBStorage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/IndexedDBStorage.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$WindowNetworkListener$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/WindowNetworkListener.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/schema.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$devtool$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/devtool.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/version.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/weakHash.js [app-client] (ecmascript) <export default as weakHash>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "weakHash": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/weakHash.js [app-client] (ecmascript)");
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/react/dist/module/useQuery.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "useQueryInternal": (()=>useQueryInternal)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__weakHash$3e$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/weakHash.js [app-client] (ecmascript) <export default as weakHash>");
;
;
const defaultState = {
    isLoading: true,
    data: undefined,
    pageInfo: undefined,
    error: undefined
};
function stateForResult(result) {
    return Object.assign({
        isLoading: !Boolean(result),
        data: undefined,
        pageInfo: undefined,
        error: undefined
    }, result ? result : {});
}
function useQueryInternal(_core, _query) {
    const query = _query ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["coerceQuery"])(_query) : null;
    const queryHash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__weakHash$3e$__["weakHash"])(query);
    // We use a ref to store the result of the query.
    // This is becuase `useSyncExternalStore` uses `Object.is`
    // to compare the previous and next state.
    // If we don't use a ref, the state will always be considered different, so
    // the component will always re-render.
    const resultCacheRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(stateForResult(_core._reactor.getPreviousResult(query)));
    // Similar to `resultCacheRef`, `useSyncExternalStore` will unsubscribe
    // if `subscribe` changes, so we use `useCallback` to memoize the function.
    const subscribe = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useQueryInternal.useCallback[subscribe]": (cb)=>{
            // Don't subscribe if query is null
            if (!query) {
                const unsubscribe = {
                    "useQueryInternal.useCallback[subscribe].unsubscribe": ()=>{}
                }["useQueryInternal.useCallback[subscribe].unsubscribe"];
                return unsubscribe;
            }
            const unsubscribe = _core.subscribeQuery(query, {
                "useQueryInternal.useCallback[subscribe].unsubscribe": (result)=>{
                    resultCacheRef.current = Object.assign({
                        isLoading: !Boolean(result),
                        data: undefined,
                        pageInfo: undefined,
                        error: undefined
                    }, result);
                    cb();
                }
            }["useQueryInternal.useCallback[subscribe].unsubscribe"]);
            return unsubscribe;
        }
    }["useQueryInternal.useCallback[subscribe]"], // Build a new subscribe function if the query changes
    [
        queryHash
    ]);
    const state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(subscribe, {
        "useQueryInternal.useSyncExternalStore[state]": ()=>resultCacheRef.current
    }["useQueryInternal.useSyncExternalStore[state]"], {
        "useQueryInternal.useSyncExternalStore[state]": ()=>defaultState
    }["useQueryInternal.useSyncExternalStore[state]"]);
    return {
        state,
        query
    };
} //# sourceMappingURL=useQuery.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/react/dist/module/useTimeout.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "useTimeout": (()=>useTimeout)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
function useTimeout() {
    const timeoutRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useTimeout.useEffect": ()=>{
            clear();
        }
    }["useTimeout.useEffect"], []);
    function set(delay, fn) {
        clearTimeout(timeoutRef.current);
        timeoutRef.current = setTimeout(fn, delay);
    }
    function clear() {
        clearTimeout(timeoutRef.current);
    }
    return {
        set,
        clear
    };
} //# sourceMappingURL=useTimeout.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/react/dist/module/InstantReactRoom.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "InstantReactRoom": (()=>InstantReactRoom),
    "defaultActivityStopTimeout": (()=>defaultActivityStopTimeout),
    "rooms": (()=>rooms),
    "usePresence": (()=>usePresence),
    "usePublishTopic": (()=>usePublishTopic),
    "useSyncPresence": (()=>useSyncPresence),
    "useTopicEffect": (()=>useTopicEffect),
    "useTypingIndicator": (()=>useTypingIndicator)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$react$2f$dist$2f$module$2f$useTimeout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/react/dist/module/useTimeout.js [app-client] (ecmascript)");
;
;
const defaultActivityStopTimeout = 1000;
function useTopicEffect(room, topic, onEvent) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useTopicEffect.useEffect": ()=>{
            const unsub = room._core._reactor.subscribeTopic(room.id, topic, {
                "useTopicEffect.useEffect.unsub": (event, peer)=>{
                    onEvent(event, peer);
                }
            }["useTopicEffect.useEffect.unsub"]);
            return unsub;
        }
    }["useTopicEffect.useEffect"], [
        room.id,
        topic
    ]);
}
function usePublishTopic(room, topic) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "usePublishTopic.useEffect": ()=>room._core._reactor.joinRoom(room.id)
    }["usePublishTopic.useEffect"], [
        room.id
    ]);
    const publishTopic = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "usePublishTopic.useCallback[publishTopic]": (data)=>{
            room._core._reactor.publishTopic({
                roomType: room.type,
                roomId: room.id,
                topic,
                data
            });
        }
    }["usePublishTopic.useCallback[publishTopic]"], [
        room.id,
        topic
    ]);
    return publishTopic;
}
function usePresence(room, opts = {}) {
    var _a, _b;
    const [state, setState] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        "usePresence.useState": ()=>{
            var _a;
            return (_a = room._core._reactor.getPresence(room.type, room.id, opts)) !== null && _a !== void 0 ? _a : {
                peers: {},
                isLoading: true
            };
        }
    }["usePresence.useState"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "usePresence.useEffect": ()=>{
            const unsub = room._core._reactor.subscribePresence(room.type, room.id, opts, {
                "usePresence.useEffect.unsub": (data)=>{
                    setState(data);
                }
            }["usePresence.useEffect.unsub"]);
            return unsub;
        }
    }["usePresence.useEffect"], [
        room.id,
        opts.user,
        (_a = opts.peers) === null || _a === void 0 ? void 0 : _a.join(),
        (_b = opts.keys) === null || _b === void 0 ? void 0 : _b.join()
    ]);
    const publishPresence = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "usePresence.useCallback[publishPresence]": (data)=>{
            room._core._reactor.publishPresence(room.type, room.id, data);
        }
    }["usePresence.useCallback[publishPresence]"], [
        room.type,
        room.id
    ]);
    const ret = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "usePresence.useMemo[ret]": ()=>{
            return Object.assign(Object.assign({}, state), {
                publishPresence
            });
        }
    }["usePresence.useMemo[ret]"], [
        state,
        publishPresence
    ]);
    return ret;
}
function useSyncPresence(room, data, deps) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useSyncPresence.useEffect": ()=>room._core._reactor.joinRoom(room.id)
    }["useSyncPresence.useEffect"], [
        room.id
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useSyncPresence.useEffect": ()=>{
            return room._core._reactor.publishPresence(room.type, room.id, data);
        }
    }["useSyncPresence.useEffect"], [
        room.type,
        room.id,
        deps !== null && deps !== void 0 ? deps : JSON.stringify(data)
    ]);
}
function useTypingIndicator(room, inputName, opts = {}) {
    const timeout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$react$2f$dist$2f$module$2f$useTimeout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useTimeout"])();
    const observedPresence = rooms.usePresence(room, {
        keys: [
            inputName
        ]
    });
    const active = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useTypingIndicator.useMemo[active]": ()=>{
            var _a;
            const presenceSnapshot = room._core._reactor.getPresence(room.type, room.id);
            return (opts === null || opts === void 0 ? void 0 : opts.writeOnly) ? [] : Object.values((_a = presenceSnapshot === null || presenceSnapshot === void 0 ? void 0 : presenceSnapshot.peers) !== null && _a !== void 0 ? _a : {}).filter({
                "useTypingIndicator.useMemo[active]": (p)=>p[inputName] === true
            }["useTypingIndicator.useMemo[active]"]);
        }
    }["useTypingIndicator.useMemo[active]"], [
        opts === null || opts === void 0 ? void 0 : opts.writeOnly,
        observedPresence
    ]);
    const setActive = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useTypingIndicator.useCallback[setActive]": (isActive)=>{
            var _a;
            room._core._reactor.publishPresence(room.type, room.id, {
                [inputName]: isActive
            });
            if (!isActive) return;
            if ((opts === null || opts === void 0 ? void 0 : opts.timeout) === null || (opts === null || opts === void 0 ? void 0 : opts.timeout) === 0) return;
            timeout.set((_a = opts === null || opts === void 0 ? void 0 : opts.timeout) !== null && _a !== void 0 ? _a : defaultActivityStopTimeout, {
                "useTypingIndicator.useCallback[setActive]": ()=>{
                    room._core._reactor.publishPresence(room.type, room.id, {
                        [inputName]: null
                    });
                }
            }["useTypingIndicator.useCallback[setActive]"]);
        }
    }["useTypingIndicator.useCallback[setActive]"], [
        room.type,
        room.id,
        inputName,
        opts === null || opts === void 0 ? void 0 : opts.timeout,
        timeout
    ]);
    const onKeyDown = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useTypingIndicator.useCallback[onKeyDown]": (e)=>{
            const isEnter = (opts === null || opts === void 0 ? void 0 : opts.stopOnEnter) && e.key === 'Enter';
            const isActive = !isEnter;
            setActive(isActive);
        }
    }["useTypingIndicator.useCallback[onKeyDown]"], [
        opts.stopOnEnter,
        setActive
    ]);
    const onBlur = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useTypingIndicator.useCallback[onBlur]": ()=>{
            setActive(false);
        }
    }["useTypingIndicator.useCallback[onBlur]"], [
        setActive
    ]);
    const inputProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useTypingIndicator.useMemo[inputProps]": ()=>{
            return {
                onKeyDown,
                onBlur
            };
        }
    }["useTypingIndicator.useMemo[inputProps]"], [
        onKeyDown,
        onBlur
    ]);
    return {
        active,
        setActive,
        inputProps
    };
}
const rooms = {
    useTopicEffect,
    usePublishTopic,
    usePresence,
    useSyncPresence,
    useTypingIndicator
};
class InstantReactRoom {
    constructor(_core, type, id){
        /**
         * @deprecated
         * `db.room(...).useTopicEffect` is deprecated. You can replace it with `db.rooms.useTopicEffect`.
         *
         * @example
         *
         * // Before
         * const room = db.room('chat', 'room-id');
         * room.useTopicEffect('emoji', (message, peer) => {  });
         *
         * // After
         * const room = db.room('chat', 'room-id');
         * db.rooms.useTopicEffect(room, 'emoji', (message, peer) => {  });
         */ this.useTopicEffect = (topic, onEvent)=>{
            rooms.useTopicEffect(this, topic, onEvent);
        };
        /**
         * @deprecated
         * `db.room(...).usePublishTopic` is deprecated. You can replace it with `db.rooms.usePublishTopic`.
         *
         * @example
         *
         * // Before
         * const room = db.room('chat', 'room-id');
         * const publish = room.usePublishTopic('emoji');
         *
         * // After
         * const room = db.room('chat', 'room-id');
         * const publish = db.rooms.usePublishTopic(room, 'emoji');
         */ this.usePublishTopic = (topic)=>{
            return rooms.usePublishTopic(this, topic);
        };
        /**
         * @deprecated
         * `db.room(...).usePresence` is deprecated. You can replace it with `db.rooms.usePresence`.
         *
         * @example
         *
         * // Before
         * const room = db.room('chat', 'room-id');
         * const { peers } = room.usePresence({ keys: ["name", "avatar"] });
         *
         * // After
         * const room = db.room('chat', 'room-id');
         * const { peers } = db.rooms.usePresence(room, { keys: ["name", "avatar"] });
         */ this.usePresence = (opts = {})=>{
            return rooms.usePresence(this, opts);
        };
        /**
         * @deprecated
         * `db.room(...).useSyncPresence` is deprecated. You can replace it with `db.rooms.useSyncPresence`.
         *
         * @example
         *
         * // Before
         * const room = db.room('chat', 'room-id');
         * room.useSyncPresence(room, { nickname });
         *
         * // After
         * const room = db.room('chat', 'room-id');
         * db.rooms.useSyncPresence(room, { nickname });
         */ this.useSyncPresence = (data, deps)=>{
            return rooms.useSyncPresence(this, data, deps);
        };
        /**
         * @deprecated
         * `db.room(...).useTypingIndicator` is deprecated. You can replace it with `db.rooms.useTypingIndicator`.
         *
         * @example
         *
         * // Before
         * const room = db.room('chat', 'room-id');
         * const typing = room.useTypingIndiactor(room, 'chat-input');
         *
         * // After
         * const room = db.room('chat', 'room-id');
         * const typing = db.rooms.useTypingIndiactor(room, 'chat-input');
         */ this.useTypingIndicator = (inputName, opts = {})=>{
            return rooms.useTypingIndicator(this, inputName, opts);
        };
        this._core = _core;
        this.type = type;
        this.id = id;
    }
} //# sourceMappingURL=InstantReactRoom.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/react/dist/module/InstantReactAbstractDatabase.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>InstantReactAbstractDatabase)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$react$2f$dist$2f$module$2f$useQuery$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/react/dist/module/useQuery.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$react$2f$dist$2f$module$2f$InstantReactRoom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/react/dist/module/InstantReactRoom.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$instatx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/instatx.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/index.js [app-client] (ecmascript) <locals>");
;
;
;
;
const defaultAuthState = {
    isLoading: true,
    user: undefined,
    error: undefined
};
class InstantReactAbstractDatabase {
    constructor(config, versions){
        this.tx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$instatx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["txInit"])();
        this.getLocalId = (name)=>{
            return this._core.getLocalId(name);
        };
        /**
         * Hooks for working with rooms
         *
         * @see https://instantdb.com/docs/presence-and-topics
         *
         * @example
         *  const room = db.room('chat', roomId);
         *  const { peers } = db.rooms.usePresence(room);
         *  const publish = db.rooms.usePublishTopic(room, 'emoji');
         *  // ...
         */ this.rooms = __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$react$2f$dist$2f$module$2f$InstantReactRoom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rooms"];
        /**
         * Use this to write data! You can create, update, delete, and link objects
         *
         * @see https://instantdb.com/docs/instaml
         *
         * @example
         *   // Create a new object in the `goals` namespace
         *   const goalId = id();
         *   db.transact(tx.goals[goalId].update({title: "Get fit"}))
         *
         *   // Update the title
         *   db.transact(tx.goals[goalId].update({title: "Get super fit"}))
         *
         *   // Delete it
         *   db.transact(tx.goals[goalId].delete())
         *
         *   // Or create an association:
         *   todoId = id();
         *   db.transact([
         *    tx.todos[todoId].update({ title: 'Go on a run' }),
         *    tx.goals[goalId].link({todos: todoId}),
         *  ])
         */ this.transact = (chunks)=>{
            return this._core.transact(chunks);
        };
        /**
         * Use this to query your data!
         *
         * @see https://instantdb.com/docs/instaql
         *
         * @example
         *  // listen to all goals
         *  db.useQuery({ goals: {} })
         *
         *  // goals where the title is "Get Fit"
         *  db.useQuery({ goals: { $: { where: { title: "Get Fit" } } } })
         *
         *  // all goals, _alongside_ their todos
         *  db.useQuery({ goals: { todos: {} } })
         *
         *  // skip if `user` is not logged in
         *  db.useQuery(auth.user ? { goals: {} } : null)
         */ this.useQuery = (query)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$react$2f$dist$2f$module$2f$useQuery$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useQueryInternal"])(this._core, query).state;
        };
        /**
         * Listen for the logged in state. This is useful
         * for deciding when to show a login screen.
         *
         * Check out the docs for an example `Login` component too!
         *
         * @see https://instantdb.com/docs/auth
         * @example
         *  function App() {
         *    const { isLoading, user, error } = db.useAuth()
         *    if (isLoading) {
         *      return <div>Loading...</div>
         *    }
         *    if (error) {
         *      return <div>Uh oh! {error.message}</div>
         *    }
         *    if (user) {
         *      return <Main user={user} />
         *    }
         *    return <Login />
         *  }
         *
         */ this.useAuth = ()=>{
            // We use a ref to store the result of the query.
            // This is becuase `useSyncExternalStore` uses `Object.is`
            // to compare the previous and next state.
            // If we don't use a ref, the state will always be considered different, so
            // the component will always re-render.
            const resultCacheRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(this._core._reactor._currentUserCached);
            // Similar to `resultCacheRef`, `useSyncExternalStore` will unsubscribe
            // if `subscribe` changes, so we use `useCallback` to memoize the function.
            const subscribe = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
                "useCallback[subscribe]": (cb)=>{
                    const unsubscribe = this._core.subscribeAuth({
                        "useCallback[subscribe].unsubscribe": (auth)=>{
                            resultCacheRef.current = Object.assign({
                                isLoading: false
                            }, auth);
                            cb();
                        }
                    }["useCallback[subscribe].unsubscribe"]);
                    return unsubscribe;
                }
            }["useCallback[subscribe]"], []);
            const state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(subscribe, {
                "useSyncExternalStore[state]": ()=>resultCacheRef.current
            }["useSyncExternalStore[state]"], {
                "useSyncExternalStore[state]": ()=>defaultAuthState
            }["useSyncExternalStore[state]"]);
            return state;
        };
        /**
         * Listen for connection status changes to Instant. Use this for things like
         * showing connection state to users
         *
         * @see https://www.instantdb.com/docs/patterns#connection-status
         * @example
         *  function App() {
         *    const status = db.useConnectionStatus()
         *    const connectionState =
         *      status === 'connecting' || status === 'opened'
         *        ? 'authenticating'
         *      : status === 'authenticated'
         *        ? 'connected'
         *      : status === 'closed'
         *        ? 'closed'
         *      : status === 'errored'
         *        ? 'errored'
         *      : 'unexpected state';
         *
         *    return <div>Connection state: {connectionState}</div>
         *  }
         */ this.useConnectionStatus = ()=>{
            const statusRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(this._core._reactor.status);
            const subscribe = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
                "useCallback[subscribe]": (cb)=>{
                    const unsubscribe = this._core.subscribeConnectionStatus({
                        "useCallback[subscribe].unsubscribe": (newStatus)=>{
                            if (newStatus !== statusRef.current) {
                                statusRef.current = newStatus;
                                cb();
                            }
                        }
                    }["useCallback[subscribe].unsubscribe"]);
                    return unsubscribe;
                }
            }["useCallback[subscribe]"], []);
            const status = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(subscribe, {
                "useSyncExternalStore[status]": ()=>statusRef.current
            }["useSyncExternalStore[status]"], {
                "useSyncExternalStore[status]": // For SSR, always return 'connecting' as the initial state
                ()=>'connecting'
            }["useSyncExternalStore[status]"]);
            return status;
        };
        /**
         * Use this for one-off queries.
         * Returns local data if available, otherwise fetches from the server.
         * Because we want to avoid stale data, this method will throw an error
         * if the user is offline or there is no active connection to the server.
         *
         * @see https://instantdb.com/docs/instaql
         *
         * @example
         *
         *  const resp = await db.queryOnce({ goals: {} });
         *  console.log(resp.data.goals)
         */ this.queryOnce = (query)=>{
            return this._core.queryOnce(query);
        };
        this._core = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["init"])(config, // @ts-expect-error because TS can't resolve subclass statics
        this.constructor.Storage, // @ts-expect-error because TS can't resolve subclass statics
        this.constructor.NetworkListener, versions);
        this.auth = this._core.auth;
        this.storage = this._core.storage;
    }
    /**
     * Obtain a handle to a room, which allows you to listen to topics and presence data
     *
     * If you don't provide a `type` or `id`, Instant will default to `_defaultRoomType` and `_defaultRoomId`
     * as the room type and id, respectively.
     *
     * @see https://instantdb.com/docs/presence-and-topics
     *
     * @example
     *  const room = db.room('chat', roomId);
     *  const { peers } = db.rooms.usePresence(room);
     */ room(type = '_defaultRoomType', id = '_defaultRoomId') {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$react$2f$dist$2f$module$2f$InstantReactRoom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantReactRoom"](this._core, type, id);
    }
    /**
     * One time query for the logged in state. This is useful
     * for scenarios where you want to know the current auth
     * state without subscribing to changes.
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *   const user = await db.getAuth();
     *   console.log('logged in as', user.email)
     */ getAuth() {
        return this._core.getAuth();
    }
} //# sourceMappingURL=InstantReactAbstractDatabase.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/react/dist/module/InstantReactWebDatabase.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>InstantReactWebDatabase)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$react$2f$dist$2f$module$2f$InstantReactAbstractDatabase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/react/dist/module/InstantReactAbstractDatabase.js [app-client] (ecmascript)");
;
class InstantReactWebDatabase extends __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$react$2f$dist$2f$module$2f$InstantReactAbstractDatabase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
} //# sourceMappingURL=InstantReactWebDatabase.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/react/dist/module/version.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// Autogenerated by publish_packages.clj
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
const version = 'v0.17.21';
const __TURBOPACK__default__export__ = version;
 //# sourceMappingURL=version.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/react/dist/module/init.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "init": (()=>init),
    "init_experimental": (()=>init_experimental)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$react$2f$dist$2f$module$2f$InstantReactWebDatabase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/react/dist/module/InstantReactWebDatabase.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$react$2f$dist$2f$module$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/react/dist/module/version.js [app-client] (ecmascript)");
;
;
function init(config) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$react$2f$dist$2f$module$2f$InstantReactWebDatabase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](config, {
        '@instantdb/react': __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$react$2f$dist$2f$module$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
    });
}
const init_experimental = init; //# sourceMappingURL=init.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/react/dist/module/Cursors.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Cursors": (()=>Cursors)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
;
function Cursors({ as = 'div', spaceId: _spaceId, room, className, style, userCursorColor, children, renderCursor, propagate, zIndex }) {
    const spaceId = _spaceId || `cursors-space-default--${String(room.type)}-${room.id}`;
    const cursorsPresence = room.usePresence({
        keys: [
            spaceId
        ]
    });
    const fullPresence = room._core._reactor.getPresence(room.type, room.id);
    function publishCursor(rect, touch) {
        const x = touch.clientX;
        const y = touch.clientY;
        const xPercent = (x - rect.left) / rect.width * 100;
        const yPercent = (y - rect.top) / rect.height * 100;
        cursorsPresence.publishPresence({
            [spaceId]: {
                x,
                y,
                xPercent,
                yPercent,
                color: userCursorColor
            }
        });
    }
    function onMouseMove(e) {
        if (!propagate) {
            e.stopPropagation();
        }
        const rect = e.currentTarget.getBoundingClientRect();
        publishCursor(rect, e);
    }
    function onMouseOut(e) {
        cursorsPresence.publishPresence({
            [spaceId]: undefined
        });
    }
    function onTouchMove(e) {
        if (e.touches.length !== 1) {
            return;
        }
        const touch = e.touches[0];
        if (touch.target instanceof Element) {
            if (!propagate) {
                e.stopPropagation();
            }
            const rect = touch.target.getBoundingClientRect();
            publishCursor(rect, touch);
        }
    }
    function onTouchEnd(e) {
        cursorsPresence.publishPresence({
            [spaceId]: undefined
        });
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(as, {
        onMouseMove,
        onMouseOut,
        onTouchMove,
        onTouchEnd,
        className,
        style: Object.assign({
            position: 'relative'
        }, style)
    }, [
        children,
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("div", {
            style: Object.assign(Object.assign(Object.assign({}, absStyles), inertStyles), {
                zIndex: zIndex !== undefined ? zIndex : defaultZ
            }),
            children: Object.entries(cursorsPresence.peers).map(([id, presence])=>{
                const cursor = presence[spaceId];
                if (!cursor) return null;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("div", {
                    style: Object.assign(Object.assign({}, absStyles), {
                        transform: `translate(${cursor.xPercent}%, ${cursor.yPercent}%)`,
                        transformOrigin: '0 0',
                        transition: 'transform 100ms'
                    }),
                    children: renderCursor ? renderCursor({
                        color: cursor.color,
                        presence: fullPresence.peers[id]
                    }) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(Cursor, Object.assign({}, cursor))
                }, id);
            })
        }, spaceId)
    ]);
}
function Cursor({ color }) {
    const size = 35;
    const fill = color || 'black';
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        style: {
            height: size,
            width: size
        },
        viewBox: `0 0 ${size} ${size}`,
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("g", {
                fill: "rgba(0,0,0,.2)",
                transform: "matrix(1, 0, 0, 1, -11.999999046325684, -8.406899452209473)",
                children: [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z"
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z"
                    })
                ]
            }),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("g", {
                fill: "white",
                transform: "matrix(1, 0, 0, 1, -11.999999046325684, -8.406899452209473)",
                children: [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z"
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z"
                    })
                ]
            }),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("g", {
                fill: fill,
                transform: "matrix(1, 0, 0, 1, -11.999999046325684, -8.406899452209473)",
                children: [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        d: "m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z"
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        d: "m13 10.814v11.188l2.969-2.866.428-.139h4.768z"
                    })
                ]
            })
        ]
    });
}
const absStyles = {
    position: 'absolute',
    top: 0,
    left: 0,
    bottom: 0,
    right: 0
};
const inertStyles = {
    overflow: 'hidden',
    pointerEvents: 'none',
    userSelect: 'none'
};
const defaultZ = 99999; //# sourceMappingURL=Cursors.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/react/dist/module/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({});
;
;
;
;
;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/react/dist/module/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$react$2f$dist$2f$module$2f$InstantReactAbstractDatabase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/react/dist/module/InstantReactAbstractDatabase.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$react$2f$dist$2f$module$2f$InstantReactWebDatabase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/react/dist/module/InstantReactWebDatabase.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$react$2f$dist$2f$module$2f$init$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/react/dist/module/init.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$react$2f$dist$2f$module$2f$Cursors$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/react/dist/module/Cursors.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$react$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/react/dist/module/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/uuid.js [app-client] (ecmascript) <export default as id>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "id": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$uuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$Documents$2f$instant$2d$demo$2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$module$2f$utils$2f$uuid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/Documents/instant-demo/node_modules/@instantdb/core/dist/module/utils/uuid.js [app-client] (ecmascript)");
}}),
}]);

//# sourceMappingURL=node_modules_c07253._.js.map